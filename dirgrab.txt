---
DIRECTORY STRUCTURE
---
- .gitignore
- README.md
- client/
  - admin.html
  - admin.js
  - config.js
  - environment.js
  - game.html
  - gameState.js
  - index.html
  - index.js
  - main.js
  - sceneSetup.js
  - settings.html
  - settings.js
  - socket.js
  - style.css
  - tree.js
  - ui/
    - controlsHandlers.js
    - elements.js
    - gameOver.js
    - leaderboard.js
    - messageHandler.js
    - setupListeners.js
    - update.js
    - updateAdmin.js
- server/
  - config.js
  - game/
    - GameInstance.js
    - GameInstanceManager.js
    - GameState.js
    - gameLogic.js
    - simulation.js
  - network/
    - connection.js
    - stateBroadcaster.js
  - package.json
  - server.js

---
FILE CONTENTS
---

--- FILE: client/settings.js ---
// settings.js (in project root)

document.addEventListener('DOMContentLoaded', () => {
    const playerNameInput = document.getElementById('player-name');
    const leafColorInput = document.getElementById('leaf-color');
    const trunkColorInput = document.getElementById('trunk-color');
    const saveButton = document.getElementById('save-settings');

    // --- Load existing settings from localStorage ---
    function loadSettings() {
        const storedName = localStorage.getItem('playerName');
        const storedLeafColor = localStorage.getItem('leafColor');
        const storedTrunkColor = localStorage.getItem('trunkColor');

        if (playerNameInput) {
            playerNameInput.value = storedName || 'Treebard'; // Use default if not set
        }
        if (leafColorInput) {
            leafColorInput.value = storedLeafColor || '#228B22'; // Default green
        }
        if (trunkColorInput) {
            trunkColorInput.value = storedTrunkColor || '#8B4513'; // Default brown
        }
        console.log('Settings loaded from localStorage');
    }

    // --- Save current settings to localStorage ---
    function saveSettings() {
        if (playerNameInput) {
            localStorage.setItem('playerName', playerNameInput.value || 'Treebard');
        }
        if (leafColorInput) {
            localStorage.setItem('leafColor', leafColorInput.value);
        }
        if (trunkColorInput) {
            localStorage.setItem('trunkColor', trunkColorInput.value);
        }
        console.log('Settings saved to localStorage');
    }

    // --- Event Listener for Save Button ---
    if (saveButton) {
        saveButton.addEventListener('click', () => {
            saveSettings();
            // Navigate back to the root landing page route
            window.location.href = '/';
        });
    }

    // --- Initial Load ---
    loadSettings();
});

--- FILE: client/config.js ---
// config.js (Project Root - Client-Side Config)

// --- UI & Display Constants ---
export const MAX_CARBON = 200; // Used for UI bar calculation
export const BASE_HYDRAULIC = 50; // Fallback for UI bar if player state not ready

// --- Rendering & Visual Defaults ---
export const INITIAL_TRUNK_HEIGHT = 2; // Used as fallback for camera target
export const ISLAND_RADIUS = 50; // <<-- Ensure this is present and correct
export const WATER_LEVEL = 0; // <<-- Ensure this is present and correct
export const ISLAND_LEVEL = 0.1; // Needed for positioning trees? Check tree.js usage.
export const DEFAULT_LEAF_COLOR = '#228B22'; // Forest Green - Used if server doesn't send color? Or for material fallback.
export const DEFAULT_TRUNK_COLOR = '#8B4513'; // Saddle Brown - Used if server doesn't send color? Or for material fallback.

// --- Canopy Tile Configuration (Client needs for rendering) ---
export const CANOPY_TILE_GRID_SIZE = 10;
export const CANOPY_TILE_THICKNESS = 0.1;

// --- Tree Structure Ratio (Client needs for rendering calculations) ---
export const k_TA_LA_RATIO = 0.01; // Trunk cross-section area / Leaf Area ratio
export const INITIAL_LEAF_AREA = 5; // Used in tree.js for calculating initial tile size

// --- Environment Visuals (Client needs for environment.js defaults/calcs) ---
export const PERIOD_DURATION = 7.0;
export const NUM_DAY_PERIODS = 3;
export const DAY_TOTAL_DURATION = PERIOD_DURATION * NUM_DAY_PERIODS;
export const NIGHT_DURATION = 3.0;
export const TOTAL_CYCLE_DURATION = DAY_TOTAL_DURATION + NIGHT_DURATION;
export const LIGHT_MULT_SUNNY = 1.0;
export const LIGHT_MULT_CLOUDY = 0.4;
export const DROUGHT_MULT_BASE = 1.0;
export const DROUGHT_VARIATION = 0.4;


// NOTE: Simulation rates, costs, probabilities, etc., are now primarily server-side
// in server/config.js and should NOT be duplicated here unless specifically
// needed for some client-side prediction or display logic (which we currently don't have).

--- FILE: README.md ---
# FOREST ROYALE: A Plant Ecophysiology Game

## 1. Overview

**Forest Royale** (formerly Island Canopy Sim) is an interactive web-based simulation game designed to teach fundamental concepts of plant ecophysiology, specifically focusing on tree "decision-making" under environmental constraints. Developed as part of PhD research in plant ecophysiology, this project uses trees as a model system for studying resource allocation and survival strategies in sessile organisms facing dynamic environmental conditions.

The primary goal is to create an engaging, accessible (playable on web/mobile), and scientifically grounded experience. The game aims to translate complex physiological processes and trade-offs into intuitive game mechanics.

We approach trees not just as passive responders, but as agents making strategic "decisions" (e.g., stomatal aperture, carbon allocation) to maximize lifetime fitness (represented by reproductive output) within the bounds of physical and chemical laws governing water transport and photosynthesis, under a changing environment. The game now includes a client-server architecture to support multiplayer gameplay.

## 2. Core Concept

Players control an individual tree on a simulated island, competing against others (in multiplayer) or playing solo. The objective is to survive environmental challenges (dynamic light, drought, rain) and maximize lifetime seed production. This requires balancing competing demands:

*   **Growth:** Investing carbon into increasing height and leaf area can improve light capture but increases water demand and respiration costs.
*   **Reproduction:** Allocating carbon to seeds directly contributes to the player's score but detracts from growth and reserves.
*   **Survival (Savings & Safety):** Maintaining sufficient carbon reserves and hydraulic safety is essential to survive periods of stress (e.g., drought, low light, cloudy periods) and nightly respiration costs.

Players make real-time decisions (stomatal aperture) and periodic strategic decisions (carbon allocation) to navigate these trade-offs in response to fluctuating weather conditions, broadcast uniformly from a central server.

## 3. Scientific Principles Demonstrated

This simulation aims to illustrate key concepts in plant ecophysiology:

*   **Resource Allocation Trade-offs:** The fundamental conflict between allocating limited resources (carbon) towards growth, reproduction, storage (savings), and defense (implicit via survival).
*   **Photosynthesis-Transpiration Compromise:** The need to open stomata for CO2 uptake (photosynthesis) inevitably leads to water loss (transpiration), requiring players to manage stomatal aperture based on water availability (hydraulic safety) and carbon demand, influenced by current weather.
*   **Hydraulic Limits & Dynamics:** Demonstrating that exceeding the water transport capacity (represented by low `hydraulicSafety`) leads to physiological damage (canopy dieback) and potentially death. Hydraulic safety is dynamic, influenced by transpiration (affected by drought factor) and recovery (boosted by rain, potential night uptake). The maximum hydraulic buffer scales with tree size.
*   **Carbon Balance:** The dynamic interplay between carbon gain (photosynthesis, affected by light levels) and carbon loss (respiration, growth, reproduction), requiring players to manage reserves (capped at `MAX_CARBON`) to avoid starvation.
*   **Environmental Response:** How changing conditions (light intensity, drought factor, rain) broadcast by the server affect physiological processes and strategic decisions for all players simultaneously.
*   **Within-Generation Plasticity:** How a tree's "strategy" (control inputs) can change over its lifetime based on its state and environment.
*   **(Future) Competition:** How interactions with neighbors (e.g., shading) influence resource capture and survival.

## 4. Current Features & Architecture (As of this README update)

*   **Client-Server Architecture:**
    *   **Node.js Backend:** Uses Express for basic routing and Socket.IO for real-time WebSocket communication.
    *   **Authoritative Server:** The server manages the core game state (all players' resources, positions, time, weather), runs the simulation loop, and broadcasts state updates to all clients.
    *   **Client-Side Rendering:** The client receives state updates and renders the 3D scene (Three.js), updates UI, and sends user input back to the server.
*   **Game Modes & Flow:**
    *   **Single Player:** Accessed via dedicated button. Server detects single connection, bypasses lobby/countdown, and starts the game immediately.
    *   **Multiplayer (Lobby):** Accessed via dedicated button. Players join a shared lobby.
        *   **Spawn Selection:** Players click on the 3D island model during the lobby phase to select a starting location. Visual markers indicate chosen spots. Server validates positions (bounds, proximity to others). Players who don't choose are assigned a random offset position near the center at game start.
        *   **Countdown:** Any player in the lobby can initiate a short (e.g., 5s) countdown.
        *   **Game Start:** Game begins for all connected players after the countdown.
*   **Shared Environment:** All players experience the same synchronized day/night cycle and dynamic weather conditions (Sunny/Cloudy, Drought Factor, Rain) generated and broadcast by the server.
*   **Visuals & Effects:**
    *   3D island environment (Three.js).
    *   Synchronized sky color, fog, and lighting transitions.
    *   Rain particle effect during rainy periods.
    *   Starfield effect on clear nights.
*   **Core Tree Model:**
    *   Represents multiple player trees visually.
    *   Handles growth (trunk/canopy scaling) based on server state.
    *   Tiled canopy visually degrades based on `damagedLAPercentage` from server.
    *   Trees positioned according to chosen or assigned spawn points.
*   **Player Controls & State:**
    *   Real-time stomatal aperture slider input sent to server.
    *   Nightly allocation strategy (Savings %, Growth/Seed Ratio %) sliders' input sent to server.
    *   Server uses player inputs for its simulation calculations.
    *   Client UI displays player-specific resource bars (Carbon, Hydraulics) and seed count based on server data.
*   **Real-time Leaderboard:** UI panel displays all connected players, sorted by seed count (during game/end) or name (in lobby), indicating alive/dead status.
*   **Game Over:**
    *   Server detects when all players are dead (`isAlive=false`).
    *   Server determines winner (player with highest seed count).
    *   Server broadcasts `gameOver` event with reason and winner ID.
    *   Client displays a modal with results. "Play Again" button reloads client, returning to landing page. Server resets game state upon last player disconnect.
*   **Refactored Code Structure:**
    *   Client-side code moved into a `client/` directory.
    *   Server-side code moved into a `server/` directory, further modularized into `game/` (state, simulation, logic) and `network/` (connection, broadcast) sub-directories.
    *   Client and Server maintain separate `config.js` files for their respective needs.

## 5. Technology Stack

*   **Backend:** Node.js, Express, Socket.IO
*   **Frontend:** HTML5, CSS3, JavaScript (ES6 Modules)
*   **3D Rendering:** Three.js
*   **Camera Controls:** `OrbitControls`

## 6. Project Structure (Current)

```
.
├── .gitignore
├── README.md
├── client/
│   ├── config.js             # Client-specific configuration
│   ├── environment.js
│   ├── game.html
│   ├── gameState.js          # Client-side state cache
│   ├── index.html            # Landing page
│   ├── index.js              # Landing page script
│   ├── main.js               # Client entry point, game loop
│   ├── sceneSetup.js
│   ├── settings.html
│   ├── settings.js
│   ├── style.css
│   ├── tree.js               # Handles tree visuals
│   └── ui/                   # UI modules
│       ├── controlsHandlers.js
│       ├── elements.js
│       ├── gameOver.js
│       ├── leaderboard.js    # (Empty)
│       ├── messageHandler.js
│       ├── setupListeners.js
│       └── update.js
└── server/
    ├── config.js             # Server-specific configuration
    ├── game/
    │   ├── GameState.js      # Manages server game state
    │   ├── gameLogic.js      # High-level logic (start/end game, countdown)
    │   └── simulation.js     # Core physiological simulation tick
    ├── network/
    │   ├── connection.js     # Handles socket connections, disconnections, events
    │   └── stateBroadcaster.js # Creates and sends state snapshots
    ├── node_modules/
    ├── package-lock.json
    ├── package.json
    └── server.js             # Server entry point, Express/SocketIO setup, main loop interval
```

## 7. Getting Started / Running the Project

1.  **Clone Repository:** Get the project files.
2.  **Install Server Dependencies:** Navigate to the `server/` directory and run `npm install`.
3.  **Run the Server:** From the `server/` directory, run `node server.js`.
4.  **Open in Browser:** Navigate to `http://localhost:3000`.
5.  **Play:** Choose "Single Player" or "Multiplayer" (open multiple tabs/browsers for multiplayer testing).

## 8. Gameplay Mechanics (Multiplayer Focus)

*   **Objective:** Be the player with the most seeds when the game ends (currently when all players die).
*   **Lobby:** When joining multiplayer, you enter a lobby. Click on the island to choose your start location (green marker confirms your spot, orange markers show others'). Anyone can click "Start Game Countdown".
*   **Gameplay:** Once started, control your tree's stomata and allocation strategy. Monitor resources. All players experience the same weather. See other players' trees grow/die in real-time.
*   **Leaderboard:** Tracks seed counts and player status live.
*   **Game End:** Game ends when all trees are dead. A modal shows the winner.

## 9. Key Learnings & Decisions During Multiplayer Implementation

*   **Client-Server Split:** Clearly separated simulation logic (server) from rendering/input handling (client).
*   **Authoritative Server:** Server dictates all game state; client is a "dumb" renderer of that state.
*   **State Synchronization:** Using Socket.IO to broadcast regular state snapshots (`gameStateUpdate`). Key challenge is balancing data volume with update frequency.
*   **Input Handling:** Client immediately sends input (slider changes, button clicks) to server; server validates and updates its state, which is then reflected back in the next broadcast.
*   **Game Flow Management:** Server manages transitions between phases (lobby, countdown, playing, ended). Connection/disconnection logic needs careful handling to maintain correct state and trigger resets.
*   **Refactoring:** Moved server logic into modules (`game/`, `network/`) and client code into `client/` directory for better organization as complexity increased.
*   **Configuration:** Separated client (`client/config.js`) and server (`server/config.js`) configurations.
*   **Spawn Selection:** Implemented via raycasting on the client, validation and state update on the server, feedback via markers and state broadcasts. Default server-side assignment handles non-choosers.

## 10. Immediate Next Steps (Current Focus)

1.  **Spectator Mode:**
    *   Add "Spectate" button/intent.
    *   Server identifies spectators, excludes from gameplay logic.
    *   Client UI adjusts for spectators (hides controls/status).
2.  **Admin Panel:**
    *   Password-protected `/admin` route.
    *   Admin client page (`admin.html`, `admin.js`) with game view + control buttons.
    *   Server authentication for admin sockets.
    *   Server listeners for admin commands (Force Start/End, Reset Countdown) executing `gameLogic` functions.
3.  **Refine Spawn Markers:** Improve visual appearance/feedback for spawn markers.
4.  **Deployment:** Deploy the application to a suitable host (targeting PaaS like Render/Fly.io initially).

## 11. Future Directions / Longer Term Roadmap

*   **Environment Polish:** Improve visuals (rain, clouds, wind effects), add sound.
*   **Gameplay Balancing:** Tune rates, costs, weather probabilities based on playtesting.
*   **Player Interaction:** Implement shading effects between player trees.
*   **Climate Catastrophes:** Add rare server-triggered events.
*   **Persistence:** Leaderboards across multiple game rounds, potentially player accounts.
*   **Robustness:** Improve server stability, error handling, reconnection logic.
*   **Enhanced Scientific Accuracy:** More complex physiology models (water potential, nutrients).
*   **Educational Context:** In-game tooltips, links to concepts.
*   **(Maybe) Different Game Modes:** E.g., timed rounds, specific objectives.

## 12. Contributing

[Optional: Add guidelines if you plan for others to contribute]

## 13. License

[Optional: Add a license]

## 14. Contact

Developed by [Your Name/Alias], PhD Student in Plant Ecophysiology.
[Optional: Add contact email or link]

--- FILE: client/index.js ---
// client/index.js (Landing Page Logic)

document.addEventListener('DOMContentLoaded', () => {
    const singlePlayerButton = document.getElementById('start-single-player');
    const multiPlayerButton = document.getElementById('start-multi-player');
    const spectateButton = document.getElementById('spectate-game');
    const settingsButton = document.getElementById('open-settings');
    const adminButton = document.getElementById('admin-panel-button'); // Get admin button

    // Function to set mode and navigate to game page
    function startGame(mode) {
        console.log(`Index: Setting mode to ${mode} and navigating to /game`);
        sessionStorage.setItem('gameModeIntent', mode); // Store intent
        window.location.href = '/game'; // Navigate to the game page
    }

    if (singlePlayerButton) {
        singlePlayerButton.addEventListener('click', () => {
            startGame('single');
        });
    }

    if (multiPlayerButton) {
        multiPlayerButton.disabled = false; // Ensure enabled
        multiPlayerButton.textContent = 'Multiplayer';
        multiPlayerButton.addEventListener('click', () => {
             startGame('multi');
        });
    }

    if (spectateButton) {
         spectateButton.addEventListener('click', () => {
             startGame('spectate');
         });
    }

    if (settingsButton) {
        settingsButton.addEventListener('click', () => {
            console.log("Navigating to Settings...");
            window.location.href = '/settings';
        });
    }

    // +++ Add listener for Admin Panel button +++
    if (adminButton) {
        adminButton.addEventListener('click', () => {
            console.log("Admin Panel button clicked.");
            // Use prompt() for simple password input
            const password = prompt("Enter Admin Password:", "");

            // Check if the user entered a password (prompt wasn't cancelled or left empty)
            if (password !== null && password !== "") {
                 console.log("Password entered, navigating to Admin Panel...");
                 // Navigate to the admin route with the password as a query parameter
                 window.location.href = `/admin?pw=${encodeURIComponent(password)}`;
            } else {
                 console.log("Admin password prompt cancelled or empty.");
                 // Optionally show a message or just do nothing
                 if (password === "") {
                     alert("Password cannot be empty.");
                 }
            }
        });
    }
});

--- FILE: client/settings.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Island Canopy Sim - Settings</title>
    <link rel="stylesheet" href="style.css"> <!-- Shared style or create settings.css -->
     <style>
        /* Basic Settings Page Specific Styles */
         body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #333;
            color: #f0f0f0;
            font-family: sans-serif;
        }
        .settings-container {
            background-color: rgba(0, 0, 0, 0.6);
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 500px; /* Limit max width */
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
         h2 {
            text-align: center;
            color: #ccc;
            margin-bottom: 25px;
        }
        .setting-item {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding-bottom: 15px;
            border-bottom: 1px solid #444;
        }
        .setting-item label {
            flex-basis: 120px; /* Fixed width for labels */
            flex-shrink: 0;
            font-weight: bold;
            color: #bbb;
        }
        .setting-item input[type="text"],
        .setting-item input[type="color"] {
             padding: 8px;
             border: 1px solid #555;
             background-color: #444;
             color: #eee;
             border-radius: 4px;
             flex-grow: 1; /* Allow input to take space */
        }
         .setting-item input[type="color"] {
            min-width: 50px; /* Ensure color picker is usable */
            height: 40px;
            padding: 2px;
            flex-grow: 0; /* Don't let color picker grow too much */
        }
        .placeholder { /* Style for future feature area */
            border: 1px dashed #555;
            padding: 15px;
            text-align: center;
            color: #777;
            font-style: italic;
            margin-top: 10px;
            width: 100%; /* Take full width */
        }
         .button-group {
            margin-top: 30px;
            text-align: center;
        }
         button {
             padding: 10px 20px;
             font-size: 1em;
             cursor: pointer;
             border: none;
             border-radius: 5px;
             background-color: #008080; /* Teal */
             color: #f0f0f0;
             transition: background-color 0.3s ease;
         }
         button:hover {
             background-color: #009999; /* Darker Teal */
         }
    </style>
</head>
<body>
    <div class="settings-container">
        <h2>Settings</h2>

        <div class="setting-item">
            <label for="player-name">Player Name:</label>
            <input type="text" id="player-name" maxlength="16" placeholder="Treebard">
        </div>

        <div class="setting-item">
            <label for="leaf-color">Leaf Color:</label>
            <input type="color" id="leaf-color" value="#228B22">
        </div>

        <div class="setting-item">
            <label for="trunk-color">Trunk Color:</label>
            <input type="color" id="trunk-color" value="#8B4513">
        </div>

         <div class="setting-item">
             <label>Canopy Style:</label>
             <div class="placeholder">
                 Advanced Customization (Paint / Image Upload) Coming Soon!
             </div>
         </div>


        <div class="button-group">
            <button id="save-settings">Save & Back</button>
        </div>

    </div>

    <script src="settings.js"></script>
</body>
</html>

--- FILE: client/ui/controlsHandlers.js ---
// client/ui/controlsHandlers.js
import { uiElements } from './elements.js';
// Import the socket instance from the new dedicated module
import { socket } from '../socket.js'; // <<< UPDATED PATH
// We no longer directly modify gameState here

/**
 * Handles changes to the Stomata Slider input.
 * Updates the UI display and sends the new value to the server.
 * @param {Event} e - The input event object.
 */
export function handleStomataChange(e) {
    const newValue = parseFloat(e.target.value);

    // Update UI display immediately for responsiveness
    if (uiElements.stomataValueUI) {
        uiElements.stomataValueUI.textContent = `${Math.round(newValue * 100)}%`;
    }

    // --- Send update to server ---
    if (socket && socket.connected) {
        // console.log(`UI->Server: Emitting updateStomata: ${newValue}`); // Debug log
        socket.emit('updateStomata', { value: newValue });
    } else {
        console.warn("Socket not connected, cannot send stomata update.");
    }
}

/**
 * Handles changes to EITHER the Savings or Growth Ratio sliders.
 * Updates the UI display and sends the new allocation intent to the server.
 */
export function handleAllocationSliderChange() {
    // Check required elements exist
    if (!uiElements.savingsSlider || !uiElements.growthRatioSlider ||
        !uiElements.savingsPercentageUI || !uiElements.growthRatioPercentageUI) {
            console.warn("Allocation slider UI elements missing in handler.");
            return;
        }

    // Read current values from both sliders
    const savingsPercent = parseInt(uiElements.savingsSlider.value) || 0;
    const growthRatioPercent = parseInt(uiElements.growthRatioSlider.value) || 0;

    // Update percentage displays immediately
    uiElements.savingsPercentageUI.textContent = `${savingsPercent}%`;
    const seedRatioPercent = 100 - growthRatioPercent;
    uiElements.growthRatioPercentageUI.textContent = `${growthRatioPercent}%/${seedRatioPercent}%`;

    // --- Send update to server ---
    if (socket && socket.connected) {
         // console.log(`UI->Server: Emitting updateAllocation: Savings=${savingsPercent}, GrowthRatio=${growthRatioPercent}`); // Debug log
         socket.emit('updateAllocation', {
             savings: savingsPercent,
             growthRatio: growthRatioPercent
         });
    } else {
         console.warn("Socket not connected, cannot send allocation update.");
    }
}

--- FILE: server/package.json ---
{
  "name": "server",
  "version": "1.0.0",
  "main": "server.js",
  "type": "module",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "express": "^5.1.0",
    "socket.io": "^4.8.1",
    "uuid": "^11.1.0"
  }
}

--- FILE: client/main.js ---
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; // Keep if OrbitControls is used here
import { socket } from './socket.js'; // <<< Import from new module
import { gameState, loadClientSettings, getMyPlayerState } from './gameState.js';
import * as Config from './config.js';
import { initScene, renderer, camera, controls, scene } from './sceneSetup.js';
import { createOrUpdateTree, removeTree, disposeAllTrees } from './tree.js';
import { uiElements, cacheDOMElements } from './ui/elements.js'; // Import uiElements
import { setupUIListeners } from './ui/setupListeners.js';
import { updateUI } from './ui/update.js';
import { showMessage, clearMessage, attachServerMessageListener } from './ui/messageHandler.js';
import { hideGameOverModal, showGameOverUI } from './ui/gameOver.js';
import { updateEnvironmentVisuals, updateRain, setWeatherTargets, startRain, stopRain } from './environment.js';


// --- Global Variables ---
let clock = new THREE.Clock();
let animationFrameId = null;
// let socket = null; // <<< REMOVE: No longer defined here
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();
let islandMesh = null;
let spawnMarkers = new Map();
let tempSpawnMarker = null;
let messageListenerAttached = false; // Module-level flag for message listener


// --- Initialization Function ---
function initializeApp() {
    console.log("*********************************************");
    console.log("*** main.js initializeApp() Starting... ***");
    console.log("*********************************************");

    const intent = sessionStorage.getItem('gameModeIntent') || 'single'; // Default to single if nothing stored
    gameState.isSpectator = (intent === 'spectate');
    console.log(`Client: Detected intent: ${intent}, Is Spectator: ${gameState.isSpectator}`);

    loadClientSettings(); cacheDOMElements(); // Cache elements including the new button

    const canvas = uiElements.canvas; // Use cached element
    if (!canvas) { console.error("Canvas element #game-canvas not found!"); return; }
    initScene(canvas);

    islandMesh = scene.getObjectByName('island');
    if (!islandMesh) console.error("Spawn Error: Island mesh 'island' not found in scene!");
    // Only add spawn click listener if not spectator
    if (!gameState.isSpectator && canvas) {
        canvas.addEventListener('pointerup', handleSpawnClick, false);
        console.log("Spawn click listener added.");
    } else {
         console.log("Spectator mode: Spawn click listener skipped.");
    }


    // +++ Add Back Button Listener +++
    if (uiElements.backButton) {
        uiElements.backButton.addEventListener('click', () => {
            console.log("Client: Back to Menu button clicked.");
            if (socket && socket.connected) {
                socket.disconnect(); // Gracefully disconnect before navigating
            }
            window.location.href = '/'; // Navigate to main menu
        });
        console.log("Back button listener added.");
    } else {
         console.warn("Back button UI element not found during init.");
    }

    // Socket is already connecting via socket.js
    console.log("main.js: Socket connection managed by socket.js. Setting up listeners.");

    setupSocketListeners(intent); // Pass intent (listeners will attach to the imported socket)
    setupUIListeners(); // Sets up listeners for game controls etc.
    updateUI(); clearMessage();
    console.log("Client Initialization complete.");
}

// --- Spawn Selection Click Handler ---
function handleSpawnClick(event) {
    const myState = getMyPlayerState();
    // Check all conditions: lobby phase, not spectator, player state exists, hasn't chosen, island exists, not pointer locked
    if (gameState.gamePhase !== 'lobby' || gameState.isSpectator || !myState || myState.hasChosenSpawn || !islandMesh || document.pointerLockElement === renderer.domElement) {
        return;
    }
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(islandMesh);
    if (intersects.length > 0) {
        const intersectionPoint = intersects[0].point;
        const islandRadius = Config.ISLAND_RADIUS || 50;
        // Check bounds relative to island center (0,0)
        if (intersectionPoint.x**2 + intersectionPoint.z**2 > islandRadius*islandRadius) {
            showMessage("Cannot spawn outside island!", "warning");
            return;
        }
        showTemporaryMarker(intersectionPoint);
        if (socket && socket.connected) {
            console.log(`Client: Emitting selectSpawnPoint: { x: ${intersectionPoint.x.toFixed(2)}, z: ${intersectionPoint.z.toFixed(2)} }`);
            socket.emit('selectSpawnPoint', { x: intersectionPoint.x, z: intersectionPoint.z });
        } else {
            showMessage("Not connected!", "error");
            removeTemporaryMarker();
        }
    }
}

// --- Spawn Marker Visuals ---
const markerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 16);
const tempMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.7 });
const confirmedMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
const otherPlayerMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500 });

function showTemporaryMarker(position) {
     removeTemporaryMarker();
     if (!tempSpawnMarker) {
         tempSpawnMarker = new THREE.Mesh(markerGeometry, tempMarkerMaterial);
         tempSpawnMarker.name = "tempSpawnMarker";
     }
     const baseLevel = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
     tempSpawnMarker.position.set(position.x, baseLevel + 0.1, position.z); // Position just above island level
     if (!tempSpawnMarker.parent) scene.add(tempSpawnMarker);
}
function removeTemporaryMarker() { if (tempSpawnMarker && tempSpawnMarker.parent) scene.remove(tempSpawnMarker); }

function addOrUpdateSpawnMarker(playerId, spawnPoint, isConfirmed) {
    if (!spawnPoint) return; // Guard against missing spawn point data
    let marker = spawnMarkers.get(playerId);
    if (!marker && isConfirmed) {
        const material = (playerId === gameState.myId && !gameState.isSpectator) ? confirmedMarkerMaterial.clone() : otherPlayerMarkerMaterial.clone();
        marker = new THREE.Mesh(markerGeometry.clone(), material);
        marker.name = `spawnMarker_${playerId}`;
        scene.add(marker);
        spawnMarkers.set(playerId, marker);
    }
    if (marker) {
         const baseLevel = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
        marker.position.set(spawnPoint.x, baseLevel + 0.1, spawnPoint.z);
        marker.visible = isConfirmed; // Only show confirmed markers
    }
}

function removeSpawnMarker(playerId) {
    const marker = spawnMarkers.get(playerId);
    if (marker) {
        if(marker.parent) scene.remove(marker);
        marker.geometry.dispose();
        if(marker.material) marker.material.dispose(); // Dispose material
        spawnMarkers.delete(playerId);
    }
}
function removeAllSpawnMarkers() {
    spawnMarkers.forEach((marker, playerId) => { removeSpawnMarker(playerId); }); // Use removeSpawnMarker for proper disposal
    spawnMarkers.clear();
    removeTemporaryMarker();
}

// --- Socket Event Listener Setup ---
function setupSocketListeners(intent) { // Socket is already defined via import
    // Listen for 'connect' event from the shared socket
    socket.on('connect', () => {
         // Check if we already sent the join request for this connection instance
         // (socket.id should be populated by the time 'connect' fires)
         if (socket.id && socket.id !== gameState.myId) { // Only join if ID changed or is new
             gameState.myId = socket.id; // Update local ID
             console.log(`main.js: Socket connected with ID: ${gameState.myId}. Sending join request (Intent: ${intent})...`);
             showMessage(`Connected! Joining as ${intent}...`, 'info');

             // --->>> READ SETTINGS AND LOG <<<---
             const playerName = localStorage.getItem('playerName') || `Tree_${socket.id.substring(0, 4)}`;
             const leafColor = localStorage.getItem('leafColor') || Config.DEFAULT_LEAF_COLOR; // Use client Config for default
             const trunkColor = localStorage.getItem('trunkColor') || Config.DEFAULT_TRUNK_COLOR; // Use client Config for default
             console.log(`main.js: Read from localStorage - Name: ${playerName}, Leaf: ${leafColor}, Trunk: ${trunkColor}`); // <<< LOGGING ADDED

             // --->>> SEND SETTINGS IN PAYLOAD <<<---
             socket.emit('playerJoinRequest', {
                 intent: intent,
                 playerName: playerName,    // Included
                 leafColor: leafColor,      // Included
                 trunkColor: trunkColor     // Included
              });
             sessionStorage.removeItem('gameModeIntent'); // Clean up intent storage

             // Attach the message listener *once* per logical connection attempt
             if (!messageListenerAttached) {
                 console.log("main.js: Attaching server message listener.");
                 attachServerMessageListener();
                 messageListenerAttached = true; // Set flag
             }
         } else if (!socket.id) {
              console.warn("main.js: 'connect' event fired but socket.id is still null?");
         } else {
              // Already connected with this ID, no need to send join request again
              console.log(`main.js: Socket already connected with ID ${socket.id}.`);
         }
    });

    // Keep the other listeners ('disconnect', 'connect_error', 'gameStateUpdate', etc.)
    socket.on('disconnect', (reason) => {
        console.log(`main.js: Disconnected: ${reason}`);
        showMessage("Disconnected!", "error");
        gameState.myId = null; // Clear ID
        messageListenerAttached = false; // Allow re-attaching message listener on next connect
        gameState.initialStateReceived = false;
        gameState.isSpectator = false; // Reset spectator status on disconnect
        gameState.gameOver = false; // Reset game over state
        gameState.players = {}; // Clear player cache
        if (animationFrameId !== null) cancelAnimationFrame(animationFrameId); animationFrameId = null;
        disposeAllTrees();
        removeAllSpawnMarkers();
        updateUI(); // Update UI to reflect disconnected state
    });

    // connect_error listener is now in socket.js

    // --- Game State Update Handler ---
    socket.on('gameStateUpdate', (serverState) => {
        const previousPhase = gameState.gamePhase;
        const playersFromServer = serverState.players || {};
        const myServerData = playersFromServer[gameState.myId];

        // Update core state properties
        Object.assign(gameState, {
            day: serverState.day, timeInCycle: serverState.timeInCycle, currentPeriodIndex: serverState.currentPeriodIndex,
            isNight: serverState.isNight, currentLightMultiplier: serverState.currentLightMultiplier, currentDroughtFactor: serverState.currentDroughtFactor,
            isRaining: serverState.isRaining, gamePhase: serverState.gamePhase, countdownTimer: serverState.countdownTimer,
            serverTime: serverState.serverTime,
            players: playersFromServer, // Update player cache
            allowPlayerCountdownStart: serverState.allowPlayerCountdownStart, // Sync admin toggle
        });

        // Update spectator status based *only* on server data for this client
        gameState.isSpectator = myServerData?.isSpectator ?? gameState.isSpectator;

        // First time setup
        if (!gameState.initialStateReceived && gameState.myId && myServerData) {
             console.log("First gameStateUpdate processed.");
             const myInitialState = myServerData;
             if (myInitialState && controls) {
                 const initialHeight = myInitialState.trunkHeight || Config.INITIAL_TRUNK_HEIGHT;
                 const targetX = myInitialState.spawnPoint?.x ?? 0;
                 const targetZ = myInitialState.spawnPoint?.z ?? 0;
                 const baseLevel = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
                 if(gameState.isSpectator) {
                     controls.target.set(0, 5, 0);
                     camera.position.set(15, 20, 15);
                 } else {
                      controls.target.set(targetX, initialHeight / 2 + baseLevel, targetZ);
                      camera.position.set(targetX + 8, initialHeight + 5, targetZ + 8);
                 }
                 controls.update();
             }
             setWeatherTargets(gameState.isNight, gameState.currentLightMultiplier < Config.LIGHT_MULT_SUNNY - 0.1, gameState.isRaining);
             updateEnvironmentVisuals(1000);
             if(gameState.isRaining) startRain(); else stopRain();
             gameState.initialStateReceived = true;
             startGameLoop();
             setTimeout(() => showMessage(`Game state: ${gameState.gamePhase}`, 'info'), 100);
         } else if (gameState.gamePhase !== previousPhase) {
             console.log(`Client phase updated from ${previousPhase} to: ${gameState.gamePhase}`);
             showMessage(`Game state: ${gameState.gamePhase}`, 'info');
             if ((previousPhase === 'lobby' || previousPhase === 'countdown') && (gameState.gamePhase !== 'lobby' && gameState.gamePhase !== 'countdown')) {
                 removeAllSpawnMarkers();
             }
         }

         // --- Continuous Updates ---
         const wasRaining = scene?.getObjectByName("rain")?.visible ?? false;
         setWeatherTargets(gameState.isNight, gameState.currentLightMultiplier < Config.LIGHT_MULT_SUNNY - 0.1, gameState.isRaining);
         if (gameState.isRaining && !wasRaining) startRain();
         else if (!gameState.isRaining && wasRaining) stopRain();

         const receivedPlayerIds = new Set(Object.keys(playersFromServer));
         for (const playerId in playersFromServer) {
             const playerData = playersFromServer[playerId];
             if (!playerData.isSpectator) {
                 createOrUpdateTree(playerId, playerData);
             } else {
                  removeTree(playerId);
             }
             if (gameState.gamePhase === 'lobby' || gameState.gamePhase === 'countdown') {
                 addOrUpdateSpawnMarker(playerId, playerData.spawnPoint, playerData.hasChosenSpawn);
             }
         }
         gameState.playerTrees.forEach((_, playerId) => { if (!receivedPlayerIds.has(playerId)) removeTree(playerId); });
         spawnMarkers.forEach((_, playerId) => { if (!receivedPlayerIds.has(playerId)) removeSpawnMarker(playerId); });
         if (gameState.gamePhase !== 'lobby' && gameState.gamePhase !== 'countdown' && spawnMarkers.size > 0) {
             removeAllSpawnMarkers();
         }

         // Update Camera Target
         const myCurrentState = getMyPlayerState();
         if (myCurrentState && myCurrentState.isAlive && !gameState.isSpectator && controls && gameState.playerTrees.has(gameState.myId)) {
             const myTreeGroup = gameState.playerTrees.get(gameState.myId);
             if (myTreeGroup) {
                 const baseLevel = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
                 const targetPos = new THREE.Vector3(myTreeGroup.position.x, myCurrentState.trunkHeight / 2 + baseLevel, myTreeGroup.position.z);
                 if (!controls.target.equals(targetPos)){ controls.target.lerp(targetPos, 0.1); }
             }
         } else if (controls && (gameState.isSpectator || !myCurrentState?.isAlive) && gameState.gamePhase !== 'lobby') {
             controls.target.lerp(new THREE.Vector3(0, 5, 0), 0.05);
         }

     }); // End gameStateUpdate

    // --- Spawn Handlers ---
    socket.on('spawnPointConfirmed', (confirmedPoint) => {
        if(gameState.isSpectator) return;
        console.log("Client: Spawn Confirmed", confirmedPoint);
        removeTemporaryMarker();
        const myId = gameState.myId;
        if (myId) {
            addOrUpdateSpawnMarker(myId, confirmedPoint, true);
            const myState = getMyPlayerState();
            if(myState) myState.hasChosenSpawn = true;
            showMessage("Spawn confirmed!", "success");
            updateUI();
        }
    });
    socket.on('spawnPointInvalid', (data) => {
        if(gameState.isSpectator) return;
        console.log("Client: Spawn Invalid", data);
        removeTemporaryMarker();
        showMessage(`Spawn invalid: ${data?.reason || 'Try again.'}`, "warning");
    });

    // --- Other handlers ---
    socket.on('playerDisconnected', (playerId) => {
        console.log(`Player ${playerId} disconnected.`);
        removeTree(playerId);
        removeSpawnMarker(playerId);
    });
    socket.on('gameOver', (data) => {
        console.log("Game Over received:", data);
        gameState.gameOver = true;
        gameState.gameOverReason = data.reason || "Game Ended!";
        gameState.winnerId = data.winnerId;
        removeAllSpawnMarkers();
        showGameOverUI();
    });

    // serverMessage listener is attached via attachServerMessageListener now

} // End of setupSocketListeners

// --- Main Game Loop & Helpers ---
function gameLoop() {
    animationFrameId=requestAnimationFrame(gameLoop);
    const dt=clock.getDelta();
    updateEnvironmentVisuals(dt);
    updateRain(dt);
    updateUI(); // Update UI every frame
    if(controls) controls.update();
    if(renderer && scene && camera) renderer.render(scene, camera);
    else { console.error("Render components missing!"); stopGameLoop(); }
}
function startGameLoop() {
    if(animationFrameId!==null) return;
    console.log("MAIN: Starting client render loop.");
    clock = new THREE.Clock(); // Reset clock
    gameLoop();
}
function stopGameLoop() {
    if(animationFrameId!==null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        console.log("MAIN: Stopped client render loop.");
    }
}

// --- handleRestart function was REMOVED from here ---


// --- Conditional Initialization ---
const mainScriptUrl = new URL('/main.js', window.location.origin).href;
if (import.meta.url === mainScriptUrl) {
    console.log("main.js detected as entry point script. Adding DOMContentLoaded listener.");
    document.addEventListener('DOMContentLoaded', initializeApp);
} else {
    console.log(`main.js imported as dependency (URL: ${import.meta.url}), skipping initializeApp listener.`);
}

--- FILE: client/admin.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Forest Royale - Admin Panel</title>
    <!-- Link to shared stylesheet -->
    <link rel="stylesheet" href="/style.css">
    <style>
        /* Admin specific styles */
        #admin-controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(150, 0, 0, 0.7);
            border: 1px solid #ff0000;
            padding: 15px;
            border-radius: 8px;
            z-index: 20; /* Above other UI panels */
            display: flex; /* Changed from none to flex, JS will hide/show */
            gap: 10px;
        }
        #admin-controls button {
            background-color: #a00;
            color: white;
            border: 1px solid #f00;
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 4px;
        }
         #admin-controls button:hover {
             background-color: #d00;
         }
         /* Ensure game container takes full space */
         #game-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
         #game-canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <!-- Game View Container -->
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
    </div>

    <!-- ================================== -->
    <!-- +++ Back to Menu Button +++ -->
    <!-- ================================== -->
    <!-- Use same ID and class as game.html for consistency -->
    <button id="back-to-menu-button" class="back-button">Back to Menu</button>

    <!-- Informational UI Panels (Similar to game.html, but no player status/controls) -->
    <div id="top-left-info" class="ui-panel">
         <p>Day: <span id="day-counter">1</span></p>
         <p>Time: <span id="time-of-day">Loading...</span></p>
         <p>Weather: <span id="weather-status">--</span></p>
         <p>Cycle Left: <span id="cycle-timer">--</span>s</p>
         <div id="message-log" class="message">ADMIN VIEW</div> <!-- Indicate admin view -->
         <!-- Lobby/Countdown Info -->
         <div id="lobby-info" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #555;">
             <h4>Lobby</h4>
             <p>Players (<span id="lobby-player-count">0</span>)</p>
             <p id="countdown-timer-display" style="font-weight: bold; color: #ffc107;"></p>
             <!-- No start button needed here -->
             <!-- No lobby instruction needed here -->
         </div>
    </div>

    <div id="top-right-leaderboard" class="ui-panel leaderboard">
         <h4 id="leaderboard-title">Leaderboard (-/-)</h4>
         <ul id="leaderboard-list">
             <li>Waiting for state...</li>
         </ul>
    </div>

    <!-- Admin Controls Panel (JS controls initial visibility based on auth) -->
    <div id="admin-controls" class="ui-panel" style="display: none;">
        <button id="admin-force-start">Force Start</button>
        <button id="admin-force-end">Force End</button>
        <button id="admin-reset-countdown">Reset Countdown</button>
        <!-- Add more controls later if needed -->
    </div>


    <!-- Game Over Modal (reuse from game.html structure) -->
     <div id="game-over-modal" class="modal hidden">
         <h2>Game Over!</h2>
        <p id="game-over-reason"></p>
        <p>Game ended by admin or naturally.</p> <!-- Generic message -->
        <!-- No Play Again button needed for admin? Or maybe a 'Reset Server State' button? -->
        <button id="admin-close-modal">Close</button>
    </div>


    <!-- Imports -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="/socket.io/socket.io.js"></script>
    <!-- Link to NEW Admin JS file -->
    <script type="module" src="/admin.js"></script>
</body>
</html>

--- FILE: server/game/GameState.js ---
// server/game/GameState.js
import * as Config from '../config.js'; // Use server config

// --- Core State Variables ---
let globalGameState = {
    day: 1,
    timeInCycle: 0.0,
    currentPeriodIndex: -1, // -1: Initial/Night, 0-2: Day periods
    isNight: false,
    currentLightMultiplier: Config.LIGHT_MULT_SUNNY, // Initial assumption
    currentDroughtFactor: Config.DROUGHT_MULT_BASE,
    isRaining: false,
    gamePhase: 'lobby', // 'lobby', 'countdown', 'playing', 'ended'
    countdownTimer: null, // Holds remaining countdown seconds, or null
};
let players = {}; // { socketId: playerData }

// --- State Management Functions ---

/** Creates initial state for a new player. */
function initializePlayerState(socketId) {
    const initialLA = Config.INITIAL_LEAF_AREA;
    const baseHeight = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
    const maxHydraulic = Config.BASE_HYDRAULIC + Config.HYDRAULIC_SCALE_PER_LA * initialLA;
    return {
        id: socketId,
        // --- Attributes ---
        playerName: `Player_${socketId.substring(0, 4)}`,
        leafColor: '#228B22', trunkColor: '#8B4513',
        spawnPoint: { x: 0, y: baseHeight, z: 0 }, // Default, updated later
        isAlive: false, // Starts not alive
        hasChosenSpawn: false,
        isSpectator: false, // Defaults to false
        // --- Resources ---
        carbonStorage: Config.INITIAL_CARBON, hydraulicSafety: Math.min(Config.INITIAL_HYDRAULICS, maxHydraulic), maxHydraulic: maxHydraulic,
        // --- Size & Structure ---
        currentLA: initialLA, effectiveLA: initialLA, trunkHeight: Config.INITIAL_TRUNK_HEIGHT,
        trunkWidth: Math.sqrt(initialLA * Config.k_TA_LA_RATIO), trunkDepth: Math.sqrt(initialLA * Config.k_TA_LA_RATIO),
        // --- Status & Output ---
        seedCount: 0, damagedLAPercentage: 0,
        // --- Inputs (Server authoritative) ---
        stomatalConductance: 0.5, lastSavingsPercent: 50, lastGrowthRatioPercent: 50,
        // --- Internal Sim State ---
        foliarUptakeAppliedThisNight: false, growthAppliedThisCycle: false,
    };
}

/** Adds a new player to the state. */
export function addPlayer(socketId) {
    if (!players[socketId]) {
        players[socketId] = initializePlayerState(socketId);
        console.log(`GameState: Added player ${socketId}. Total: ${Object.keys(players).length}`);
    } else {
        console.warn(`GameState: Player ${socketId} already exists.`);
    }
}

/** Removes a player from the state. */
export function removePlayer(socketId) {
    if (players[socketId]) {
        delete players[socketId];
        console.log(`GameState: Removed player ${socketId}. Remaining: ${Object.keys(players).length}`);
        return true;
    }
    return false;
}

/** Retrieves state for a specific player. */
export function getPlayerState(socketId) {
    return players[socketId] || null;
}

/** Retrieves the entire players object. */
export function getAllPlayers() {
    return players;
}

/** Retrieves the global game state object. */
export function getGlobalState() {
    return globalGameState;
}

/** Updates specific properties of the global state. */
export function updateGlobalState(updates) {
     Object.assign(globalGameState, updates);
}

/** Sets the current game phase. */
export function setGamePhase(phase) {
    if (['lobby', 'countdown', 'playing', 'ended'].includes(phase)) {
        if (globalGameState.gamePhase !== phase) {
             console.log(`GameState: Changing phase from ${globalGameState.gamePhase} to ${phase}`);
             globalGameState.gamePhase = phase;
             if (phase !== 'countdown') globalGameState.countdownTimer = null; // Reset timer unless entering countdown
        }
    } else { console.error(`GameState: Invalid phase: ${phase}`); }
}

/** Resets global state variables to defaults. */
export function resetGlobalStateValues() {
     console.log("GameState: Resetting global values...");
     Object.assign(globalGameState, {
        day: 1, timeInCycle: 0.0, currentPeriodIndex: -1, isNight: false,
        currentLightMultiplier: Config.LIGHT_MULT_SUNNY, currentDroughtFactor: Config.DROUGHT_MULT_BASE,
        isRaining: false, gamePhase: 'lobby', countdownTimer: null
     });
}

--- FILE: server/game/simulation.js ---
// server/game/simulation.js
// Core simulation logic has been moved into the GameInstance class (server/game/GameInstance.js)
// This file is kept temporarily for reference or can be deleted.

console.log("server/game/simulation.js loaded (logic moved to GameInstance)");

// export function updateSimulationTick(deltaTime, io) { ... } // REMOVED
// function updatePlayerPhysiology(playerState, globalState, deltaTime) { ... } // REMOVED
// function generatePeriodWeather(globalState) { ... } // REMOVED
// function generateNightWeather(globalState) { ... } // REMOVED
// function applyAllocation(playerState) { ... } // REMOVED

--- FILE: server/game/gameLogic.js ---
// server/game/gameLogic.js
// Core game logic (start/stop countdown, end game, reset)
// has been moved into the GameInstance class (server/game/GameInstance.js)
// This file is kept temporarily for reference or can be deleted.

console.log("server/game/gameLogic.js loaded (logic moved to GameInstance)");

// export function startLobbyCountdown(io) { ... } // REMOVED
// export function cancelLobbyCountdown() { ... } // REMOVED
// export function endGame(io, players, globalState, reason = "All trees have perished!") { ... } // REMOVED
// export function resetGame() { ... } // REMOVED

--- FILE: client/ui/elements.js ---
// client/ui/elements.js
export let uiElements = {};
export function cacheDOMElements() {
    console.log("UI: Caching DOM elements...");
    uiElements = {
        gameContainer: document.getElementById('game-container'),
        canvas: document.getElementById('game-canvas'),

        // +++ Add Back Button +++
        backButton: document.getElementById('back-to-menu-button'),

        // Top Left Elements
        dayCounterUI: document.getElementById('day-counter'),
        timeOfDayUI: document.getElementById('time-of-day'),
        weatherStatusUI: document.getElementById('weather-status'),
        cycleTimerUI: document.getElementById('cycle-timer'),
        messageLogUI: document.getElementById('message-log'),
        // Lobby Elements
        lobbyInfoPanel: document.getElementById('lobby-info'), // Container
        lobbyPlayerCountUI: document.getElementById('lobby-player-count'),
        lobbyInstructionUI: document.getElementById('lobby-instruction'), // Added previously
        countdownTimerDisplayUI: document.getElementById('countdown-timer-display'),
        startCountdownButton: document.getElementById('start-countdown-button'),

        // Top Right Elements
        leaderboardTitleUI: document.getElementById('leaderboard-title'),
        leaderboardListUI: document.getElementById('leaderboard-list'),

        // Bottom Left Elements
        bottomLeftStatus: document.getElementById('bottom-left-status'),
        carbonBar: document.getElementById('carbon-bar'),
        hydraulicBar: document.getElementById('hydraulic-bar'),
        carbonValueUI: document.getElementById('carbon-value'),
        hydraulicValueUI: document.getElementById('hydraulic-value'),
        seedCounterUI: document.getElementById('seed-counter'),

        // Bottom Right Controls
        controlPanelRight: document.getElementById('control-panel-right'),
        stomataSlider: document.getElementById('stomata-slider'),
        stomataValueUI: document.getElementById('stomata-value'),
        savingsSlider: document.getElementById('savings-slider'),
        savingsPercentageUI: document.getElementById('savings-percentage'),
        growthRatioSlider: document.getElementById('growth-ratio-slider'),
        growthRatioPercentageUI: document.getElementById('growth-ratio-percentage'),

        // Game Over Elements
        gameOverModal: document.getElementById('game-over-modal'),
        gameOverReasonUI: document.getElementById('game-over-reason'),
        finalDayUI: document.getElementById('final-day'),
        finalSeedsUI: document.getElementById('final-seeds'),
        restartButton: document.getElementById('restart-button'),

        // Admin specific elements (might be null on game page)
        adminControls: document.getElementById('admin-controls'),
        adminCloseModalButton: document.getElementById('admin-close-modal'),
    };

     // Verification log
     let foundCount = 0; let missing = [];
     const isGamePage = !!document.getElementById('start-countdown-button');
     const isAdminPage = !!document.getElementById('admin-controls');

     for (const key in uiElements) {
         if (uiElements[key]) {
             foundCount++;
         } else {
             // Refined checks to reduce noise based on page context
             const isOptionalOnGame = ['adminControls', 'adminCloseModalButton'].includes(key);
             const isOptionalOnAdmin = [
                'lobbyInstructionUI', 'startCountdownButton', 'bottomLeftStatus', 'carbonBar', 'hydraulicBar',
                'carbonValueUI', 'hydraulicValueUI', 'seedCounterUI', 'controlPanelRight', 'stomataSlider',
                'stomataValueUI', 'savingsSlider', 'savingsPercentageUI', 'growthRatioSlider',
                'growthRatioPercentageUI', 'finalDayUI', 'finalSeedsUI', 'restartButton'
             ].includes(key);

             if (isGamePage && !isOptionalOnGame && !uiElements[key]) {
                 console.warn(`UI element not found (Game Page): ${key}`); missing.push(key);
             } else if (isAdminPage && !isOptionalOnAdmin && !uiElements[key]) {
                  console.warn(`UI element not found (Admin Page): ${key}`); missing.push(key);
             } else if (!isGamePage && !isAdminPage && key !== 'gameContainer' && key !== 'canvas'){
                 // Ignore missing elements on other pages (like index, settings)
             }
         }
     }
      if (isGamePage || isAdminPage) {
          console.log(`UI: Cached ${foundCount} DOM elements. Missing: ${missing.length > 0 ? missing.join(', ') : 'None'}`);
      } else {
          console.log(`UI: Cached ${foundCount} DOM elements (non-game/admin page).`);
      }
}

--- FILE: client/ui/updateAdmin.js ---
// client/ui/updateAdmin.js - UI Updater for Admin Panel
import { gameState } from '../gameState.js';
import * as Config from '../config.js';
import { uiElements } from './elements.js'; // Use cached elements

/** Updates admin UI elements based on the current gameState. */
export function updateUI() { // Renamed function locally
    // Wait until elements are cached, no need to wait for initial state like player view
    if (!uiElements.dayCounterUI) { return; }

    const phase = gameState.gamePhase;
    const allConnections = gameState.players;
    const playersOnly = Object.values(allConnections).filter(p => !p.isSpectator);
    const playerCount = playersOnly.length;
    const aliveCount = playersOnly.filter(p => p.isAlive).length;

    // --- Update Info (Top Left) ---
    // (Same as regular update.js)
    if (uiElements.dayCounterUI) uiElements.dayCounterUI.textContent = (phase !== 'loading') ? gameState.day : '-';
    if (uiElements.timeOfDayUI) { let timeText = ''; if (phase === 'lobby' || phase === 'loading' || phase === 'ended') timeText = phase.charAt(0).toUpperCase() + phase.slice(1); else if (phase === 'countdown') timeText = 'Starting Soon!'; else if (phase === 'playing') { if (gameState.isNight) timeText = 'Night'; else if (gameState.currentPeriodIndex >= 0) timeText = `Day Period ${gameState.currentPeriodIndex + 1}`; else timeText = 'Starting...'; } else timeText = 'Unknown Phase'; uiElements.timeOfDayUI.textContent = timeText; }
    if (uiElements.cycleTimerUI) { let timeLeft = 0; if (phase === 'playing') { if (gameState.isNight) { const timeIntoNight = gameState.timeInCycle - Config.DAY_TOTAL_DURATION; timeLeft = Config.NIGHT_DURATION - timeIntoNight; } else if (gameState.currentPeriodIndex >= 0) { const timeIntoPeriod = gameState.timeInCycle - (gameState.currentPeriodIndex * Config.PERIOD_DURATION); timeLeft = Config.PERIOD_DURATION - timeIntoPeriod; } else { timeLeft = Config.PERIOD_DURATION - gameState.timeInCycle; } uiElements.cycleTimerUI.textContent = Math.max(0, Math.floor(timeLeft)); } else { uiElements.cycleTimerUI.textContent = '--'; } }
    if (uiElements.weatherStatusUI) { let weatherText = ''; if(phase === 'lobby' || phase === 'loading' || phase === 'ended' || phase === 'countdown') weatherText = '--'; else if (phase === 'playing') { if (gameState.isNight) weatherText = 'Night'; else weatherText = (gameState.currentLightMultiplier === Config.LIGHT_MULT_SUNNY) ? 'Sunny' : 'Cloudy'; if (gameState.isRaining) weatherText += ', Raining'; if (gameState.currentDroughtFactor > Config.DROUGHT_MULT_BASE + Config.DROUGHT_VARIATION * 0.6) weatherText += ' (Dry)'; else if (gameState.currentDroughtFactor < Config.DROUGHT_MULT_BASE - Config.DROUGHT_VARIATION * 0.6) weatherText += ' (Wet)'; } else weatherText = 'Initializing...'; uiElements.weatherStatusUI.textContent = weatherText; }

    // --- Update Lobby/Countdown Info (Top Left) ---
    // (Same as regular update.js, but button is hidden via HTML)
    if (uiElements.lobbyInfoPanel) {
        const showLobby = (phase === 'lobby' || phase === 'countdown');
        uiElements.lobbyInfoPanel.style.display = showLobby ? 'block' : 'none';
        if (showLobby) {
            if (uiElements.lobbyPlayerCountUI) uiElements.lobbyPlayerCountUI.textContent = Object.keys(allConnections).length;
             // No start button logic needed here
            if (uiElements.countdownTimerDisplayUI) { if (phase === 'countdown' && gameState.countdownTimer !== null) { uiElements.countdownTimerDisplayUI.textContent = `Starting in: ${gameState.countdownTimer}s`; uiElements.countdownTimerDisplayUI.style.display = 'block'; } else { uiElements.countdownTimerDisplayUI.style.display = 'none'; } }
        }
    }

    // --- Update Leaderboard / Player List (Top Right) ---
    // (Same as regular update.js - shows non-spectators)
    if (uiElements.leaderboardTitleUI) { if (phase === 'lobby' || phase === 'countdown') uiElements.leaderboardTitleUI.textContent = `Lobby (${Object.keys(allConnections).length})`; else uiElements.leaderboardTitleUI.textContent = `Leaderboard (${aliveCount}/${playerCount})`; }
    if (uiElements.leaderboardListUI) { let listHTML = ''; const playersToDisplay = Object.values(allConnections).filter(p => !p.isSpectator); playersToDisplay.sort((a, b) => { if (phase === 'lobby' || phase === 'countdown') { return (a?.playerName || '').localeCompare(b?.playerName || ''); } else { return (b?.seedCount ?? 0) - (a?.seedCount ?? 0); } }); playersToDisplay.forEach(player => { const isMe = player.id === gameState.myId; let status = ''; if (player.isSpectator) status = ' (Spectating)'; else if (phase === 'playing' || phase === 'ended') status = player.isAlive ? '' : ' (Dead)'; else if (phase === 'lobby' || phase === 'countdown') status = player.hasChosenSpawn ? ' (Placed)' : ''; const name = player.playerName || `Player ${player.id.substring(0,4)}`; const seeds = (phase === 'playing' || phase === 'ended') ? `: ${player.seedCount} Seeds` : ''; listHTML += `<li${isMe ? ' style="font-weight: bold;"' : ''}>${name}${status}${seeds}</li>`; }); if(listHTML === '' && phase !== 'loading') { if (Object.keys(allConnections).length > 0 && playerCount === 0) listHTML = '<li>Only spectators connected...</li>'; else if (Object.keys(allConnections).length === 0) listHTML = '<li>Waiting for server...</li>'; } uiElements.leaderboardListUI.innerHTML = listHTML; }

    // No need to update player status bars or controls for admin view
}

--- FILE: client/environment.js ---
// environment.js
// Manages visual aspects of the game environment (lighting, sky, effects)

import * as THREE from 'three';
import { scene, sunLight, ambientLight, camera } from './sceneSetup.js';
import { gameState } from './gameState.js'; // Import gameState to read server state

// --- Configuration (Keep as before) ---
const skyColors = { day_sunny: new THREE.Color(0x87CEEB), day_cloudy: new THREE.Color(0xB0C4DE), night: new THREE.Color(0x000020) };
const fogColors = { day_sunny: new THREE.Color(0x87CEEB), day_cloudy: new THREE.Color(0xA9A9A9), night: new THREE.Color(0x000010) };
const FOG_DAY_NEAR = 50; const FOG_DAY_FAR = 150;
const FOG_NIGHT_NEAR = 9999; const FOG_NIGHT_FAR = 10000;
const ambientIntensity = { day_sunny: 0.6, day_cloudy: 0.4, night: 0.1 };
const sunIntensity = { day_sunny: 1.5, day_cloudy: 0.5, night: 0.0 };
const starCount = 7000;
const SMOOTHING_SPEED = 1.5;
const RAIN_COUNT = 7000; const RAIN_AREA_SIZE = 60; const RAIN_HEIGHT = 50; const RAIN_SPEED = 80; const RAIN_COLOR = 0xAAAAFF;

// --- Module State for Lerping (Keep as before) ---
let stars = null;
let currentAmbientIntensity = ambientIntensity.day_sunny; // Initial default
let currentSunIntensity = sunIntensity.day_sunny;
let currentSkyColor = skyColors.day_sunny.clone();
let currentFogColor = fogColors.day_sunny.clone();
let currentFogNear = FOG_DAY_NEAR;
let currentFogFar = FOG_DAY_FAR;

let targetAmbientIntensity = currentAmbientIntensity;
let targetSunIntensity = currentSunIntensity;
let targetSkyColor = currentSkyColor.clone();
let targetFogColor = currentFogColor.clone();
let targetFogNear = currentFogNear;
let targetFogFar = currentFogFar;
let targetStarsVisible = false;

// Rain State
let rainParticles = null;
let rainGeometry = null;
let rainMaterial = null;
let rainPositions = null;
let rainVelocities = null;

// --- Initialization Functions (Keep createStars, createRainSystem as before) ---
export function createStars() {
    if (stars) { /* cleanup */ if(stars.geometry) stars.geometry.dispose(); if(stars.material) stars.material.dispose(); if(scene) scene.remove(stars); stars = null; }
    const starGeometry = new THREE.BufferGeometry(); const starVertices = [];
    const starMaterial = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 0.4, sizeAttenuation: true, transparent: true, opacity: 0.9, depthWrite: false, blending: THREE.AdditiveBlending });
    const radius = 500;
    for (let i = 0; i < starCount; i++) { const phi = Math.acos(-1 + (2 * Math.random())); const theta = Math.random() * Math.PI * 2; const x = radius * Math.sin(phi) * Math.cos(theta); const y = radius * Math.cos(phi); const z = radius * Math.sin(phi) * Math.sin(theta); if (y > -radius * 0.05) starVertices.push(x, y, z); }
    starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3)); stars = new THREE.Points(starGeometry, starMaterial); stars.name = "stars"; stars.visible = false; stars.renderOrder = 1; if (scene) scene.add(stars);
    console.log("Stars created (Additive White) and added to scene.");
}
export function createRainSystem() {
    if (rainParticles) return; rainGeometry = new THREE.BufferGeometry();
    rainMaterial = new THREE.PointsMaterial({ color: RAIN_COLOR, size: 0.08, sizeAttenuation: true, transparent: true, opacity: 0.6, blending: THREE.NormalBlending, depthWrite: false });
    rainPositions = new Float32Array(RAIN_COUNT * 3); rainVelocities = new Array(RAIN_COUNT); const halfArea = RAIN_AREA_SIZE / 2;
    for (let i = 0; i < RAIN_COUNT; i++) { const i3 = i * 3; rainPositions[i3 + 0] = Math.random() * RAIN_AREA_SIZE - halfArea; rainPositions[i3 + 1] = Math.random() * RAIN_HEIGHT; rainPositions[i3 + 2] = Math.random() * RAIN_AREA_SIZE - halfArea; rainVelocities[i] = -RAIN_SPEED * (0.8 + Math.random() * 0.4); }
    rainGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3)); rainParticles = new THREE.Points(rainGeometry, rainMaterial); rainParticles.name = "rain"; rainParticles.visible = false; if (scene) { scene.add(rainParticles); console.log("Rain particle system created."); } else { console.error("Scene not available for adding rain system."); }
}


// --- Update Functions ---

/**
 * Sets the TARGET visual state based on conditions read from gameState.
 * Now takes arguments derived from gameState in main.js.
 * @param {boolean} isNight
 * @param {boolean} isCloudy - True if light multiplier indicates cloudy
 * @param {boolean} isRaining
 */
export function setWeatherTargets(isNight, isCloudy, isRaining) {
    if (isNight) {
        targetAmbientIntensity = ambientIntensity.night; targetSunIntensity = sunIntensity.night;
        targetSkyColor = skyColors.night; targetFogColor = fogColors.night;
        targetFogNear = FOG_NIGHT_NEAR; targetFogFar = FOG_NIGHT_FAR;
        targetStarsVisible = !isRaining; // Stars visible only if night and not raining
    } else { // Daytime
        targetAmbientIntensity = isCloudy ? ambientIntensity.day_cloudy : ambientIntensity.day_sunny;
        targetSunIntensity = isCloudy ? sunIntensity.day_cloudy : sunIntensity.day_sunny;
        targetSkyColor = isCloudy ? skyColors.day_cloudy : skyColors.day_sunny;
        targetFogColor = isCloudy ? fogColors.day_cloudy : fogColors.day_sunny;
        targetFogNear = FOG_DAY_NEAR; targetFogFar = FOG_DAY_FAR;
        targetStarsVisible = false; // No stars during day
    }
    // console.log(`ENV: Targets set - Night:${isNight}, Cloudy:${isCloudy}, Raining:${isRaining}, StarsTarget:${targetStarsVisible}`);
}

// Updates the actual visual environment state via lerping towards targets
// Reads targets directly, no need to read gameState here.
export function updateEnvironmentVisuals(deltaTime) {
    if (!scene || !scene.fog || !ambientLight || !sunLight) return; // Ensure scene objects exist

    const lerpFactor = Math.min(1.0, deltaTime * SMOOTHING_SPEED);

    // Lerp intensities
    currentAmbientIntensity = THREE.MathUtils.lerp(currentAmbientIntensity, targetAmbientIntensity, lerpFactor);
    currentSunIntensity = THREE.MathUtils.lerp(currentSunIntensity, targetSunIntensity, lerpFactor);

    // Lerp colors
    currentSkyColor.lerp(targetSkyColor, lerpFactor);
    currentFogColor.lerp(targetFogColor, lerpFactor);

    // Lerp fog distances
    currentFogNear = THREE.MathUtils.lerp(currentFogNear, targetFogNear, lerpFactor);
    currentFogFar = THREE.MathUtils.lerp(currentFogFar, targetFogFar, lerpFactor);

    // Apply current values
    ambientLight.intensity = currentAmbientIntensity;
    sunLight.intensity = currentSunIntensity;
    scene.background = currentSkyColor;
    scene.fog.color = currentFogColor;
    scene.fog.near = currentFogNear;
    scene.fog.far = currentFogFar;

    // Update star visibility (instant change is fine)
    if (stars && stars.visible !== targetStarsVisible) {
        stars.visible = targetStarsVisible;
        // console.log(`ENV: Stars visibility set to ${targetStarsVisible}`);
    }
}

// Makes rain visible
export function startRain() {
    if (rainParticles && !rainParticles.visible) { // Only change if not already visible
        rainParticles.visible = true;
        console.log("ENV: Starting rain effect.");
    }
}

// Makes rain invisible
export function stopRain() {
     if (rainParticles && rainParticles.visible) { // Only change if visible
        rainParticles.visible = false;
        console.log("ENV: Stopping rain effect.");
    }
}

// Animates the raindrops (Keep as before)
export function updateRain(deltaTime) {
    if (!rainParticles || !rainParticles.visible || !rainPositions || !rainVelocities) return;
    const positions = rainParticles.geometry.attributes.position.array; const halfArea = RAIN_AREA_SIZE / 2;
    for (let i = 0; i < RAIN_COUNT; i++) { const i3 = i * 3; positions[i3 + 1] += rainVelocities[i] * deltaTime; if (positions[i3 + 1] < 0) { positions[i3 + 0] = Math.random() * RAIN_AREA_SIZE - halfArea; positions[i3 + 1] = RAIN_HEIGHT + Math.random() * 5; positions[i3 + 2] = Math.random() * RAIN_AREA_SIZE - halfArea; } }
    rainParticles.geometry.attributes.position.needsUpdate = true;
}

--- FILE: server/config.js ---
// server/config.js
// Game Constants & Configuration
// (Content copied from root config.js)

export const k_TA_LA_RATIO = 0.01; // Trunk cross-section area / Leaf Area ratio
export const INITIAL_LEAF_AREA = 5;
export const INITIAL_TRUNK_HEIGHT = 2;
export const INITIAL_CARBON = 100;
export const INITIAL_HYDRAULICS = 100; // Starting hydraulic safety value

export const MAX_CARBON = 200; // Maximum carbon storage capacity

// Hydraulic Buffer Configuration
export const BASE_HYDRAULIC = 50; // Base hydraulic safety buffer independent of size
export const HYDRAULIC_SCALE_PER_LA = 10; // Additional buffer capacity per unit of currentLA

export const PHOTOSYNTHESIS_RATE_PER_LA = 0.5; // Carbon gain per LA per second at max light & stomata=1
export const RESPIRATION_RATE_PER_LA = 0.02;   // Carbon loss per LA per second
export const RESPIRATION_RATE_PER_TRUNK_VOL = 0.01; // Carbon loss per trunk volume per second
export const TRANSPIRATION_RATE_PER_LA = 0.4; // Water loss rate per LA per sec at stomata=1, normal drought
export const HYDRAULIC_RECOVERY_RATE = 2;   // Base safety gain per second if stomata closed & water available
export const HYDRAULIC_DAMAGE_THRESHOLD = 20; // Below this, start taking damage
export const CROWN_DIEBACK_RATE = 0.05;      // Proportion of canopy LA potentially lost per second below threshold

export const GROWTH_COST_PER_LA = 5;        // Carbon cost to add 1 unit of LA (includes implicit trunk cost)
export const SEED_COST = 1;                 // Carbon cost per seed

// Time Structure Constants
export const PERIOD_DURATION = 7.0;         // Duration of each daytime weather period (seconds)
export const NUM_DAY_PERIODS = 3;           // Number of weather periods per day
export const DAY_TOTAL_DURATION = PERIOD_DURATION * NUM_DAY_PERIODS; // Total duration of all day periods
export const NIGHT_DURATION = 3.0;          // Duration of nighttime (seconds)
export const TOTAL_CYCLE_DURATION = DAY_TOTAL_DURATION + NIGHT_DURATION; // Full day-night cycle length
export const GROWTH_OFFSET_NIGHT = 1.5;     // Time into night when growth allocation occurs (seconds)

// Weather Probabilities & Effects
export const SUNNY_PROB = 2.0 / 3.0;        // Probability of a period being sunny (vs cloudy)
export const RAIN_PROB_IF_CLOUDY = 0.5;     // Probability of rain if a period is cloudy

export const LIGHT_MULT_SUNNY = 1.0;        // Photosynthesis multiplier for sunny weather
export const LIGHT_MULT_CLOUDY = 0.4;       // Photosynthesis multiplier for cloudy weather

export const DROUGHT_MULT_BASE = 1.0;       // Base drought factor (normal conditions)
export const DROUGHT_VARIATION = 0.4;       // Max +/- variation around the base for random drought factor

export const RAIN_RECOVERY_BONUS_MULT = 3.0; // Multiplier for HYDRAULIC_RECOVERY_RATE during rain
export const NIGHT_RAIN_HYDRAULIC_BOOST = 20.0; // Absolute hydraulic units added during rainy night (foliar uptake)

// Canopy Tile Configuration (Client might still need this, but server sim doesn't directly)
// export const CANOPY_TILE_GRID_SIZE = 10;
// export const CANOPY_TILE_THICKNESS = 0.1;

// Island Configuration (Client primarily needs this, server might for spawn validation)
// export const ISLAND_RADIUS = 50;
// export const WATER_LEVEL = 0;
// export const ISLAND_LEVEL = 0.1;

// Default Colors (Client only)
// export const DEFAULT_LEAF_COLOR = '#228B22';
// export const DEFAULT_TRUNK_COLOR = '#8B4513';

// Fog constants (Client only)
// export const FOG_DAY_NEAR = 50;
// export const FOG_DAY_FAR = 150;
// export const FOG_NIGHT_NEAR = 9999;
// export const FOG_NIGHT_FAR = 10000;

--- FILE: client/socket.js ---
// client/socket.js
// This module initializes and exports the shared Socket.IO client instance.

// Import the socket.io client library.
// Assumes socket.io.js is loaded globally via <script> tag in HTML.
// If you were using a bundler like Webpack/Vite, you'd use: import { io } from 'socket.io-client';
// For this setup, we rely on the global 'io'. Make sure the <script src="/socket.io/socket.io.js"></script>
// in your HTML files comes *before* your module scripts.
if (typeof io === 'undefined') {
    console.error("Socket.IO client library (io) not found. Make sure socket.io.js is loaded before this script.");
    // Provide a dummy socket object to prevent further errors, though functionality will be broken.
    // This isn't ideal but prevents crashing other modules trying to import 'socket'.
    const dummySocket = {
        on: () => {},
        emit: () => { console.error("Socket not initialized (dummy)"); },
        disconnect: () => {},
        connected: false,
        id: null
    };
    alert("Critical Error: Socket.IO library missing. Please check the console."); // User notification
    // Export the dummy object
    // export const socket = dummySocket; // Uncomment this line if you want to export a dummy on failure
    throw new Error("Socket.IO client library (io) not found."); // More aggressive: stop script execution
}


console.log("[socket.js] Initializing socket connection...");
const socket = io({
    reconnection: true, // Enable default reconnection
    reconnectionAttempts: 5,
    reconnectionDelay: 1000,
    // You might want to disable autoConnect initially if you need to wait
    // for user actions, but for this app, autoConnect is fine.
    // autoConnect: false,
});

// Add basic logging for core socket events right here for centralized debugging
socket.on('connect', () => {
    console.log(`[socket.js] Socket connected: ${socket.id}`);
});

socket.on('disconnect', (reason) => {
     console.log(`[socket.js] Socket disconnected: ${reason}`);
     // You could potentially emit a custom event here for other modules if needed
     // document.dispatchEvent(new CustomEvent('socketDisconnected', { detail: reason }));
});

 socket.on('connect_error', (error) => {
     console.error('[socket.js] Socket Connection Error:', error);
 });

// Export the single, shared socket instance
export { socket };

--- FILE: client/ui/leaderboard.js ---


--- FILE: client/style.css ---
/* client/style.css */

/* === Global & Base Styles === */
body, html {
    margin: 0;
    padding: 0;
    overflow: hidden; /* Prevent scrollbars on the page */
    font-family: sans-serif;
    background-color: #333; /* Fallback background */
    color: #eee;       /* Default text color */
}

#game-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0; /* Ensure canvas is behind UI panels */
}

#game-canvas {
    display: block;
    width: 100%;
    height: 100%;
}

/* === General UI Panel Styling === */
.ui-panel {
    position: absolute; /* Position panels absolutely relative to body/viewport */
    background-color: rgba(0, 0, 0, 0.65); /* Slightly darker background for panels */
    border: 1px solid #444;
    border-radius: 6px;
    padding: 10px;
    box-sizing: border-box; /* Include padding and border in element's total width and height */
    color: #eee;
    z-index: 10; /* Ensure panels are above the canvas */
    pointer-events: auto; /* Allow interaction with panels */
    font-size: 14px; /* Base font size for panels */
}

.ui-panel h3, .ui-panel h4 { /* General headings for panels */
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 1.0em; /* Relative to panel base font size */
    color: #ddd;
    border-bottom: 1px solid #555;
    padding-bottom: 5px;
}

.ui-panel p, .ui-panel div, .ui-panel label, .ui-panel span, .ui-panel li {
    font-size: 0.9em; /* Consistent font size within panels */
    line-height: 1.4; /* Improve readability */
}

/* === Specific Panel Positioning === */

/* --- Top Left Info Panel --- */
#top-left-info {
    top: 10px;
    left: 10px;
    min-width: 180px; /* Ensure some minimum width */
    /* Add base padding-top to make space for button */
    padding-top: 40px; /* Default space for desktop */
    position: relative;
}
#top-left-info p {
    margin: 4px 0; /* Tighter spacing */
}
#top-left-info span {
    font-weight: bold;
    color: #ffc107; /* Amber highlight for values */
}
.message { /* Message Log styling */
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px dashed #555;
    color: #ffcc00;
    font-weight: bold;
    min-height: 1.2em;
    font-size: 0.85em; /* Smaller message text */
}
.message.info { color: #ffcc00; } /* Default/Info */
.message.success { color: #4CAF50; } /* Green */
.message.warning { color: #ff9800; } /* Orange */
.message.error { color: #f44336; } /* Red */


/* --- Top Right Leaderboard --- */
#top-right-leaderboard {
    top: 10px;
    right: 10px;
    min-width: 200px;
    max-width: 280px; /* Limit width */
    background-color: rgba(0, 0, 0, 0.5); /* More translucent */
}
#top-right-leaderboard h4 {
    font-size: 0.9em;
    text-align: center;
    border: none; /* Remove border for header */
    padding-bottom: 0;
    margin-bottom: 5px;
}
#top-right-leaderboard ul {
    list-style: none;
    padding: 0;
    margin: 0;
    max-height: 200px; /* Limit height and allow scroll if needed */
    overflow-y: auto;
    font-size: 0.85em;
}
#top-right-leaderboard li {
    padding: 3px 5px; /* Add slight horizontal padding */
    border-bottom: 1px dotted #444;
    white-space: nowrap; /* Prevent wrapping */
    overflow: hidden; /* Hide overflow */
    text-overflow: ellipsis; /* Add ellipsis if name is too long */
}
#top-right-leaderboard li:last-child {
    border-bottom: none;
}


/* --- Bottom Left Status Panel --- */
#bottom-left-status {
    bottom: 10px;
    left: 10px;
    width: 220px; /* Fixed width */
}
#bottom-left-status .status-bar-container {
    margin-bottom: 10px;
    position: relative; /* For positioning the value text */
}
#bottom-left-status label {
    display: block;
    margin-bottom: 2px;
    font-size: 0.85em;
    color: #ccc;
}
.bar-outer {
    background-color: #555;
    border-radius: 3px;
    height: 15px;
    width: 100%;
    overflow: hidden;
    border: 1px solid #333; /* Subtle border */
}
.bar-inner {
    height: 100%;
    border-radius: 2px; /* Slightly smaller radius */
    transition: width 0.2s ease-in-out;
}
.carbon { background: linear-gradient(to right, #4CAF50, #8BC34A); } /* Green gradient */
.hydraulic { background: linear-gradient(to right, #2196F3, #03A9F4); } /* Blue gradient */

#bottom-left-status span#carbon-value,
#bottom-left-status span#hydraulic-value {
    position: absolute; /* Position inside the container */
    right: 5px;      /* Align to the right */
    top: 18px;       /* Position below the label */
    font-size: 0.75em;
    line-height: 15px; /* Align vertically with bar */
    color: #ccc;
    text-shadow: 1px 1px 1px #000; /* Improve readability */
}
#bottom-left-status p { /* Seed count display */
    margin: 8px 0 0 0;
    clear: both;
    font-weight: bold;
}
#bottom-left-status p span#seed-counter {
     color: #ffc107;
}


/* --- Bottom Right Control Panel --- */
#control-panel-right {
    bottom: 10px;
    right: 10px;
    width: 220px; /* Slightly wider */
    display: flex;
    flex-direction: column; /* Stack controls vertically */
    gap: 15px; /* Space between control rows */
    padding: 15px 12px; /* Adjust padding */
}

/* Styling for rows within the vertical panel */
.control-row {
    display: grid;
    grid-template-columns: auto 1fr; /* Label | Slider/Value Area */
    grid-template-rows: auto auto; /* Row 1 for Label/Value, Row 2 for Slider */
    gap: 2px 8px;
    align-items: center;
    width: 100%;
}
.control-row label {
    grid-column: 1 / 2; grid-row: 1 / 2;
    white-space: nowrap; color: #ccc; font-size: 0.85em; justify-self: start;
}
.control-row input[type="range"] {
    grid-column: 1 / 3; grid-row: 2 / 3;
    width: 100%; cursor: pointer; margin-top: 2px;
    /* Improved slider appearance */
    -webkit-appearance: none;
    appearance: none;
    height: 8px;
    background: #555;
    outline: none;
    border-radius: 4px;
}
.control-row input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none;
    width: 16px; height: 16px; background: #ccc; cursor: pointer; border-radius: 50%;
}
.control-row input[type="range"]::-moz-range-thumb {
    width: 16px; height: 16px; background: #ccc; cursor: pointer; border-radius: 50%; border: none;
}

.control-row span { /* Percentage displays */
    grid-column: 2 / 3; grid-row: 1 / 2;
    font-size: 0.85em; font-weight: bold; color: #ccc; text-align: right; white-space: nowrap; justify-self: end;
}

/* === Back Button Styling === */
/* Base style for the back button - positioned relative to viewport */
.back-button {
    position: absolute;
    top: 10px; /* Align with top edge of info panel */
    left: 10px; /* Align with left edge of info panel */
    z-index: 20; /* Above other panels */
    box-sizing: border-box; /* Include padding/border in width calculation */
    width: 200px; /* Default width (matches default leaderboard min-width) */
    padding: 6px 12px;
    font-size: 0.9em; /* Match panel text size slightly better */
    background-color: rgba(80, 80, 80, 0.7);
    color: #eee;
    border: 1px solid #666;
    border-radius: 4px;
    cursor: pointer;
    pointer-events: auto;
    transition: background-color 0.2s;
    text-align: center; /* Center text within the button */
    text-decoration: none;
    font-family: sans-serif;
}
.back-button:hover {
    background-color: rgba(110, 110, 110, 0.8);
    border-color: #888;
}


/* === General Interactive Element Styling === */
button {
    pointer-events: auto; /* Ensure clickable */
}
input[type="range"], input[type="color"], input[type="number"] {
     pointer-events: auto; /* Ensure these are always interactive */
}
input[type="color"] {
    min-width: 40px; height: 25px; border: 1px solid #555;
    cursor: pointer; padding: 0; vertical-align: middle;
    background-color: #444; /* Match other inputs */
    border-radius: 3px;
}

/* === Game Over Modal Styling === */
.modal {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background-color: rgba(40, 40, 40, 0.9); padding: 30px; border: 1px solid #666;
    border-radius: 10px; z-index: 100; min-width: 300px; max-width: 90%; /* Responsive */
    text-align: center;
    pointer-events: auto; color: #eee; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
}
.modal.hidden { display: none; }
.modal h2 { margin-top: 0; color: #eee; margin-bottom: 15px; }
.modal p { color: #eee; margin: 10px 0; line-height: 1.4; }
.modal p span { font-weight: bold; color: #ffc107; }
#game-over-reason { font-style: italic; color: #ffdddd; margin-bottom: 20px !important; }
.modal button {
     padding: 10px 20px; margin-top: 20px; cursor: pointer;
     background-color: #556b2f; /* Match landing page buttons */
     border: none; color: #eee; border-radius: 5px; font-size: 1em;
     transition: background-color 0.2s;
}
.modal button:hover { background-color: #6b8e23; }
/* Style admin close button differently if needed */
#admin-close-modal { background-color: #8b4513; }
#admin-close-modal:hover { background-color: #a0522d; }


/* === Responsive Design === */

/* Target screens smaller than 768px (Tablets/Large Phones) */
@media (max-width: 768px) {
    .ui-panel {
        padding: 10px; /* Slightly more padding */
        font-size: 14px; /* INCREASED base font size */
        min-width: 0;
    }

    #top-left-info {
        top: 8px; /* More space from edge */
        left: 8px;
        max-width: 180px; /* Slightly wider */
        padding-top: 40px; /* Space for button */
    }
    #top-right-leaderboard {
        top: 8px;
        right: 8px;
        max-width: 170px; /* INCREASED width */
        max-height: 160px; /* INCREASED height */
    }
    #bottom-left-status {
        bottom: 8px;
        left: 8px;
        width: 190px; /* INCREASED width */
    }
    #control-panel-right {
        bottom: 8px;
        right: 8px;
        width: 190px; /* INCREASED width */
        padding: 12px 10px; /* More padding */
        gap: 10px; /* More gap */
    }
    /* Increase label/value text slightly if base increased */
    .control-row label { font-size: 0.9em; }
    .control-row span { font-size: 0.9em; }
     /* Make sliders slightly easier to grab */
    .control-row input[type="range"] { height: 10px; }
    .control-row input[type="range"]::-webkit-slider-thumb { width: 18px; height: 18px; }
    .control-row input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; }


    /* --- Back Button - Above Top Left, Match Leaderboard Width --- */
    .back-button {
        top: 8px; /* Align top edge */
        left: 8px; /* Align left edge */
        width: 170px; /* MATCH LEADERBOARD WIDTH */
        padding: 6px 10px; /* Slightly larger */
        font-size: 0.9em; /* Match panel font */
    }
    /* --- End Back Button --- */

    /* Adjust text sizes (relative to new base) */
    .ui-panel p, .ui-panel div, .ui-panel label, .ui-panel span, .ui-panel li {
        font-size: 0.9em; /* Maintain relative size */
        line-height: 1.35; /* Slightly more line spacing */
    }
    #top-right-leaderboard ul { font-size: 0.85em; } /* List text */
    #top-right-leaderboard li { padding: 3px 5px; }
    #bottom-left-status label { font-size: 0.9em; }
     .bar-outer { height: 16px; } /* INCREASED bar height */
     #bottom-left-status span#carbon-value,
     #bottom-left-status span#hydraulic-value {
         font-size: 0.8em; /* Slightly larger value text */
         top: 18px; /* Adjust for bar height */
         line-height: 16px; /* Match bar height */
     }

    /* Modal adjustments */
    .modal { padding: 25px; min-width: 300px; }
    .modal h2 { font-size: 1.3em; }
    .modal p { font-size: 1em; }
    .modal button { font-size: 1em; padding: 10px 18px;}
}


/* Target even smaller screens (most phones) */
@media (max-width: 480px) {
    .ui-panel {
        font-size: 13px; /* INCREASED base font */
        border-radius: 5px;
        padding: 8px; /* Keep slightly tighter */
    }

    #top-left-info {
        max-width: 155px; /* INCREASED width */
        padding-top: 38px; /* Adjust space */
    }
    #top-right-leaderboard {
        max-width: 145px; /* INCREASED width */
        max-height: 140px; /* INCREASED height */
    }
    #bottom-left-status {
        width: 165px; /* INCREASED width */
    }
    #control-panel-right {
        width: 165px; /* INCREASED width */
        gap: 8px; /* INCREASED gap */
    }
     .bar-outer { height: 14px; } /* Slightly larger bar */
     #bottom-left-status span#carbon-value,
     #bottom-left-status span#hydraulic-value {
         line-height: 14px;
         top: 17px; /* Adjust pos */
         font-size: 0.75em; /* Larger value text */
     }

    /* --- Back Button - Above Top Left, Match Leaderboard Width --- */
    .back-button {
        top: 8px; /* Align top edge */
        left: 8px; /* Align left edge */
        width: 145px; /* MATCH LEADERBOARD WIDTH */
        padding: 5px 8px; /* Larger padding */
        font-size: 0.9em; /* Larger font */
    }
    /* --- End Back Button --- */

     /* Adjust text sizes (relative to new base) */
    .ui-panel p, .ui-panel div, .ui-panel label, .ui-panel span, .ui-panel li {
        font-size: 0.9em; /* Larger relative text */
        line-height: 1.3;
    }
     #top-right-leaderboard li { padding: 2px 4px; }
     .control-row label { font-size: 0.85em; } /* Larger labels */
     .control-row span { font-size: 0.85em; } /* Larger percentages */
     .control-row input[type="range"] { height: 12px; } /* Thicker slider track */
     .control-row input[type="range"]::-webkit-slider-thumb { width: 20px; height: 20px; } /* Larger thumb */
     .control-row input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; }
}

--- FILE: client/ui/messageHandler.js ---
// client/ui/messageHandler.js
import { uiElements } from './elements.js';
// Import socket reference from the new dedicated module
import { socket } from '../socket.js'; // <<< UPDATED PATH

let listenerAttached = false; // Module-level flag to prevent attaching multiple times

/** Shows a message in the message log area. */
export function showMessage(text, type = 'info') {
     if (uiElements.messageLogUI) {
        uiElements.messageLogUI.textContent = text;
        uiElements.messageLogUI.className = `message ${type}`;
     } else {
         // console.warn(`Msg Log UI not found. (${type}): ${text}`);
     }
}

/** Clears the message log area. */
export function clearMessage() {
    if (uiElements.messageLogUI) {
        uiElements.messageLogUI.textContent = '';
        uiElements.messageLogUI.className = 'message';
    }
}

/**
 * Attaches the listener for the 'serverMessage' event to the shared socket.
 * Should be called once the socket connection is logically established
 * (e.g., after connect event and initial handshake/auth).
 */
export function attachServerMessageListener() {
    // Prevent attaching multiple times and ensure socket exists
    if (listenerAttached) {
        // console.log("Message Handler: Listener already attached."); // Reduce noise
        return;
    }
    // The socket import itself might fail if socket.js has issues,
    // but we assume socket.js handles that. Here we check if the imported socket looks valid.
    if (!socket || typeof socket.on !== 'function') {
        console.warn("Message Handler: attach called but socket is not ready or invalid.");
        return;
    }

    socket.on('serverMessage', (data) => {
        console.log("Received server message:", data);
        showMessage(data.text, data.type || 'info');
    });

    listenerAttached = true;
    console.log("Message Handler: Server message listener attached.");
}

// Call this function externally (from main.js/admin.js) after connection setup
// export function detachServerMessageListener() { // Optional: if needed for cleanup
//    if (listenerAttached && socket) {
//        socket.off('serverMessage'); // Remove specific listener if possible
//        listenerAttached = false;
//        console.log("Message Handler: Server message listener detached.");
//    }
// }

--- FILE: client/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forest Royale - Welcome</title> <!-- Changed title -->
    <link rel="stylesheet" href="/style.css"> <!-- Root relative path -->
    <style>
        /* Basic Landing Page Specific Styles */
        body {
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; background-color: #2b412b; color: #f0f0f0;
            font-family: sans-serif; text-align: center;
        }
        .landing-container {
            background-color: rgba(0, 0, 0, 0.5); padding: 40px;
            border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        h1 { color: #90ee90; margin-bottom: 30px; font-size: 2.5em; }
        .button-group { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; }
        button {
            padding: 12px 25px; font-size: 1.1em; cursor: pointer; border: none; border-radius: 5px;
            background-color: #556b2f; /* Dark Olive Green */
            color: #f0f0f0; transition: background-color 0.3s ease;
        }
        button:hover:not(:disabled) { background-color: #6b8e23; } /* Olive Drab */
        button:disabled { background-color: #4a4a4a; color: #888; cursor: not-allowed; }
        /* Style for admin button */
        #admin-panel-button {
            background-color: #8B4513; /* Saddle Brown - distinct color */
        }
        #admin-panel-button:hover {
            background-color: #A0522D; /* Sienna */
        }
    </style>
</head>
<body>
    <div class="landing-container">
        <h1>Forest Royale</h1>
        <p>Make Good Decisions!</p>

        <div class="button-group">
            <button id="start-single-player">Single Player</button>
            <button id="start-multi-player">Multiplayer</button>
            <button id="spectate-game">Spectate Game</button>
            <button id="open-settings">Settings</button>
            <!-- +++ Add Admin Panel Button +++ -->
            <button id="admin-panel-button">Admin Panel</button>
        </div>
    </div>

    <script src="/index.js"></script> <!-- Root relative path -->
</body>
</html>

--- FILE: client/sceneSetup.js ---
// client/sceneSetup.js
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import * as Config from './config.js';
import { createStars, createRainSystem } from './environment.js';

export let scene;
export let camera;
export let renderer;
export let controls;
export let sunLight;
export let ambientLight;

export function initScene(canvas) {
    // Scene setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // Initial color, environment.js will update

    // Fog setup - Use client config values if available, otherwise provide defaults
    // Note: Config constants FOG_DAY_NEAR/FAR are commented out in client/config.js, so provide defaults here.
    const fogNear = Config.FOG_DAY_NEAR !== undefined ? Config.FOG_DAY_NEAR : 50;
    const fogFar = Config.FOG_DAY_FAR !== undefined ? Config.FOG_DAY_FAR : 150;
    scene.fog = new THREE.Fog(0x87ceeb, fogNear, fogFar); // environment.js will update color and distances

    // Camera setup
    const aspectRatio = window.innerWidth / window.innerHeight;
    camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000); // Far plane at 1000
    camera.position.set(15, 15, 15);

    // Renderer setup
    renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // Lighting setup
    ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Initial intensity
    scene.add(ambientLight);

    sunLight = new THREE.DirectionalLight(0xffffff, 1.5); // Initial intensity
    sunLight.position.set(30, 50, 20);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 150;
    // Use client config for shadow camera size calculation
    const shadowCamSize = (Config.ISLAND_RADIUS || 50) * 1.5; // Use fallback if config missing
    sunLight.shadow.camera.left = -shadowCamSize;
    sunLight.shadow.camera.right = shadowCamSize;
    sunLight.shadow.camera.top = shadowCamSize;
    sunLight.shadow.camera.bottom = -shadowCamSize;
    scene.add(sunLight);
    scene.add(sunLight.target); // Target is needed for directional light shadows

    // Controls setup
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    // Use client config for initial target height
    controls.target.set(0, (Config.INITIAL_TRUNK_HEIGHT || 2) / 2, 0); // Use fallback
    controls.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent looking straight down/up too far
    controls.minDistance = 5;  // Prevent zooming too close
    controls.maxDistance = 100; // Prevent zooming too far out

    // Static Environment Meshes (Island, Water)
    createEnvironment(); // <<< This function creates the island

    // Initialize Dynamic Environment Effects (Stars, Rain)
    createStars();
    createRainSystem();

    // Window Resize Listener
    window.addEventListener('resize', onWindowResize);

    console.log("Scene initialized (including stars and rain system placeholder)");
}

// Creates static meshes like island and water
function createEnvironment() {
    // Use client config values with fallbacks for safety
    const islandRadius = Config.ISLAND_RADIUS || 50;
    const islandLevel = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
    const waterLevel = Config.WATER_LEVEL !== undefined ? Config.WATER_LEVEL : 0;

    // Island
    const islandGeometry = new THREE.CylinderGeometry(islandRadius, islandRadius, islandLevel * 2, 32);
    const islandMaterial = new THREE.MeshStandardMaterial({ color: 0x967969 }); // Brownish color
    const islandMesh = new THREE.Mesh(islandGeometry, islandMaterial);
    islandMesh.position.y = islandLevel / 2; // Center it vertically around islandLevel
    islandMesh.receiveShadow = true;
    // +++ Assign the name property +++
    islandMesh.name = 'island'; // <<< ENSURE THIS LINE IS PRESENT
    // ++++++++++++++++++++++++++++++++
    scene.add(islandMesh);
    console.log(`SCENESETUP: Island mesh created and added with name: ${islandMesh.name}`); // Add log

    // Water
    console.log(`SCENESETUP: Creating water with radius factor based on ISLAND_RADIUS: ${islandRadius}`);
    const waterGeometry = new THREE.PlaneGeometry(islandRadius * 4, islandRadius * 4); // Large plane
    const waterMaterial = new THREE.MeshStandardMaterial({
        color: 0x4682B4, // Steel blue
        transparent: true,
        opacity: 0.8,
        roughness: 0.2,
        metalness: 0.1,
    });
    const waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
    waterMesh.rotation.x = -Math.PI / 2; // Rotate flat
    waterMesh.position.y = waterLevel;   // Position at water level
    console.log(`SCENESETUP: Water mesh Y position: ${waterMesh.position.y}`);
    waterMesh.receiveShadow = true; // Water can receive shadows (e.g., from trees)
    scene.add(waterMesh);
}

// Handles window resize events
function onWindowResize() {
    if (camera && renderer) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
}

--- FILE: client/ui/update.js ---
// client/ui/update.js
import { gameState, getMyPlayerState } from '../gameState.js';
import * as Config from '../config.js';
import { uiElements } from './elements.js';

/** Updates all relevant UI elements based on the current gameState. */
export function updateUI() {
    // Allow update even before initial state for basic loading display
    if (!uiElements.dayCounterUI) { // Check only one essential element that should always exist on game page
        // console.warn("UpdateUI: Waiting for essential UI elements.");
        return;
    }

    const myState = getMyPlayerState();
    const phase = gameState.gamePhase;
    const allConnections = gameState.players || {}; // Use empty object if players doesn't exist yet
    const isSpectator = gameState.isSpectator; // Use the flag from client gameState

    // +++ Consistent Player/Spectator Filtering +++
    const allPlayerArray = Object.values(allConnections);
    // Filter for actual players (non-spectators, non-admins)
    const activePlayers = allPlayerArray.filter(p => p && !p.isSpectator && !p.playerName.startsWith('ADMIN_'));
    // Count total connections (including spectators/admins)
    const totalConnectionsCount = allPlayerArray.length;
    // Count active players
    const activePlayerCount = activePlayers.length;
    // Count alive among active players
    const alivePlayerCount = activePlayers.filter(p => p.isAlive).length;


    // --- Update Status Bars (Bottom Left) ---
    if (uiElements.bottomLeftStatus) { // Check element exists before accessing style
        uiElements.bottomLeftStatus.style.display = isSpectator ? 'none' : 'block';
    }
    if (!isSpectator && gameState.initialStateReceived && myState) { // Ensure myState exists too
        const carbon = myState.carbonStorage ?? 0; const maxCarbon = Config.MAX_CARBON;
        const hydraulics = myState.hydraulicSafety ?? 0; const maxHydraulics = myState.maxHydraulic ?? Config.BASE_HYDRAULIC;
        const seeds = myState.seedCount ?? 0;
        if (uiElements.carbonBar) uiElements.carbonBar.style.width = `${(carbon / maxCarbon) * 100}%`;
        if (uiElements.hydraulicBar) uiElements.hydraulicBar.style.width = maxHydraulics > 0 ? `${(hydraulics / maxHydraulics) * 100}%` : '0%';
        if (uiElements.carbonValueUI) uiElements.carbonValueUI.textContent = Math.floor(carbon);
        if (uiElements.hydraulicValueUI) uiElements.hydraulicValueUI.textContent = Math.floor(hydraulics);
        if (uiElements.seedCounterUI) uiElements.seedCounterUI.textContent = seeds;
    } else if (!isSpectator && uiElements.bottomLeftStatus) { // Only reset if panel exists
         // Show default '--' if not spectator but state not ready
        if (uiElements.carbonValueUI) uiElements.carbonValueUI.textContent = '--';
        if (uiElements.hydraulicValueUI) uiElements.hydraulicValueUI.textContent = '--';
        if (uiElements.seedCounterUI) uiElements.seedCounterUI.textContent = '0';
        if (uiElements.carbonBar) uiElements.carbonBar.style.width = '0%';
        if (uiElements.hydraulicBar) uiElements.hydraulicBar.style.width = '0%';
    }

    // --- Update Info (Top Left) ---
    if (uiElements.dayCounterUI) uiElements.dayCounterUI.textContent = (phase !== 'loading') ? gameState.day : '-';
    if (uiElements.timeOfDayUI) {
        let timeText = '';
        if (phase === 'lobby' || phase === 'loading' || phase === 'ended') timeText = phase.charAt(0).toUpperCase() + phase.slice(1);
        else if (phase === 'countdown') timeText = 'Starting Soon!';
        else if (phase === 'playing') { if (gameState.isNight) timeText = 'Night'; else if (gameState.currentPeriodIndex >= 0) timeText = `Day Period ${gameState.currentPeriodIndex + 1}`; else timeText = 'Starting...'; }
        else timeText = 'Unknown Phase';
        uiElements.timeOfDayUI.textContent = timeText;
     }
    if (uiElements.cycleTimerUI) {
        let timeLeft = 0; if (phase === 'playing') { if (gameState.isNight) { const timeIntoNight = gameState.timeInCycle - Config.DAY_TOTAL_DURATION; timeLeft = Config.NIGHT_DURATION - timeIntoNight; } else if (gameState.currentPeriodIndex >= 0) { const timeIntoPeriod = gameState.timeInCycle - (gameState.currentPeriodIndex * Config.PERIOD_DURATION); timeLeft = Config.PERIOD_DURATION - timeIntoPeriod; } else { timeLeft = Config.PERIOD_DURATION - gameState.timeInCycle; } uiElements.cycleTimerUI.textContent = Math.max(0, Math.floor(timeLeft)); } else { uiElements.cycleTimerUI.textContent = '--'; }
     }
    if (uiElements.weatherStatusUI) {
        let weatherText = ''; if(phase === 'lobby' || phase === 'loading' || phase === 'ended' || phase === 'countdown') weatherText = '--'; else if (phase === 'playing') { if (gameState.isNight) weatherText = 'Night'; else weatherText = (gameState.currentLightMultiplier === Config.LIGHT_MULT_SUNNY) ? 'Sunny' : 'Cloudy'; if (gameState.isRaining) weatherText += ', Raining'; if (gameState.currentDroughtFactor > Config.DROUGHT_MULT_BASE + Config.DROUGHT_VARIATION * 0.6) weatherText += ' (Dry)'; else if (gameState.currentDroughtFactor < Config.DROUGHT_MULT_BASE - Config.DROUGHT_VARIATION * 0.6) weatherText += ' (Wet)'; } else weatherText = 'Initializing...'; uiElements.weatherStatusUI.textContent = weatherText;
     }

    // --- Update Lobby/Countdown UI (Top Left) ---
    if (uiElements.lobbyInfoPanel) {
        // Show lobby panel only if NOT spectator AND in lobby/countdown
        const showLobbyPanel = !isSpectator && (phase === 'lobby' || phase === 'countdown');
        uiElements.lobbyInfoPanel.style.display = showLobbyPanel ? 'block' : 'none';

        if (showLobbyPanel) {
            // +++ Use activePlayerCount for Lobby Player Count (excluding spectators/admins) +++
            if (uiElements.lobbyPlayerCountUI) uiElements.lobbyPlayerCountUI.textContent = activePlayerCount;

            // Control visibility of lobby instruction
            if (uiElements.lobbyInstructionUI) {
                uiElements.lobbyInstructionUI.style.display = (phase === 'lobby') ? 'block' : 'none'; // Show only in lobby
            }

            // Update start countdown button state
            if (uiElements.startCountdownButton) {
                const canStart = gameState.allowPlayerCountdownStart && activePlayerCount > 0; // Check admin setting and if players exist
                uiElements.startCountdownButton.disabled = (phase === 'countdown' || !canStart);
                uiElements.startCountdownButton.textContent = (phase === 'countdown') ? 'Countdown...' : 'Start Countdown';
                // Optionally add a title if disabled due to admin setting
                uiElements.startCountdownButton.title = !gameState.allowPlayerCountdownStart ? "Admin has disabled player start" : "";
             }

            // Countdown Timer Display
            if (uiElements.countdownTimerDisplayUI) {
                if (phase === 'countdown' && gameState.countdownTimer !== null && gameState.countdownTimer >= 0) { // Check >= 0
                    // console.log(`UI Update: Countdown phase, timer value: ${gameState.countdownTimer}`);
                    uiElements.countdownTimerDisplayUI.textContent = `Starting in: ${gameState.countdownTimer}s`;
                    uiElements.countdownTimerDisplayUI.style.display = 'block';
                } else {
                    uiElements.countdownTimerDisplayUI.style.display = 'none';
                }
            }
         }
    }


    // --- Update Controls (Bottom Right) ---
    if (uiElements.controlPanelRight) {
        // Show controls ONLY if playing, alive, and NOT spectator
        const showControls = phase === 'playing' && myState && myState.isAlive && !isSpectator && !gameState.gameOver;
        uiElements.controlPanelRight.style.display = showControls ? 'flex' : 'none';
    }

    // --- Update Leaderboard / Player List (Top Right) ---
    if (uiElements.leaderboardTitleUI) {
         // +++ Use activePlayerCount for game title +++
         if (phase === 'lobby' || phase === 'countdown') uiElements.leaderboardTitleUI.textContent = `Players (${activePlayerCount})`; // Show only active players count
         else uiElements.leaderboardTitleUI.textContent = `Leaderboard (${alivePlayerCount}/${activePlayerCount})`; // Show Alive/Total Active Players
     }
    if (uiElements.leaderboardListUI) {
        let listHTML = '';
        // --- Determine players to display based on phase ---
        let playersToDisplay = [];
        if (phase === 'lobby' || phase === 'countdown') {
            // *** Filter spectators/admins even in lobby/countdown ***
            playersToDisplay = allPlayerArray.filter(p => p && !p.isSpectator && !p.playerName.startsWith('ADMIN_')); // Filter out spectators and admins
            playersToDisplay.sort((a, b) => (a?.playerName || '').localeCompare(b?.playerName || '')); // Sort remaining by name
        } else { // Playing or Ended phase
            playersToDisplay = allPlayerArray.filter(p => p && !p.isSpectator && !p.playerName.startsWith('ADMIN_')); // Filter out spectators and admins
            playersToDisplay.sort((a, b) => (b?.seedCount ?? 0) - (a?.seedCount ?? 0)); // Sort remaining by seeds
        }

        // --- Generate HTML list from the filtered playersToDisplay ---
        playersToDisplay.forEach(player => {
            const isMe = player.id === gameState.myId; // Check if it's the current player
            let status = '';
            if (phase === 'lobby' || phase === 'countdown') {
                status = player.hasChosenSpawn ? ' (Placed)' : '';
            } else { // Playing or Ended
                status = player.isAlive ? '' : ' (Dead)';
            }
            const name = player.playerName || `Player ${player.id.substring(0,4)}`;
            const seeds = (phase === 'playing' || phase === 'ended') ? `: ${player.seedCount} Seeds` : '';
            // Highlight 'Me' only if not spectator (spectator shouldn't see themselves on leaderboard)
            const highlightClass = (isMe && !isSpectator) ? ' style="font-weight: bold;"' : '';
            listHTML += `<li${highlightClass}>${name}${status}${seeds}</li>`;
        });


        // --- Handle empty list conditions (considering only NON-spectators/admins now) ---
        if (listHTML === '') {
             if (totalConnectionsCount > 0 && activePlayerCount === 0) {
                 listHTML = '<li>Only spectators/admins connected...</li>';
             } else if (totalConnectionsCount === 0) {
                 listHTML = '<li>Waiting for players...</li>';
             } else if (phase !== 'loading') {
                 // This case might occur if playersToDisplay was filtered to empty but connections existed
                 listHTML = '<li>No active players found.</li>';
             }
        }

        uiElements.leaderboardListUI.innerHTML = listHTML;
     }
}

--- FILE: server/network/stateBroadcaster.js ---
// server/network/stateBroadcaster.js

function getSimplifiedGameStateSnapshot(players, globalState) {
    const playersSnapshot = {};
    Object.values(players).forEach(p => {
        playersSnapshot[p.id] = {
            id: p.id,
            playerName: p.playerName,
            isAlive: p.isAlive,
            hasChosenSpawn: p.hasChosenSpawn,
            isSpectator: p.isSpectator, // <<< Include spectator status
            // Resources
            carbonStorage: p.carbonStorage, hydraulicSafety: p.hydraulicSafety, maxHydraulic: p.maxHydraulic,
            // Visual state
            currentLA: p.currentLA, trunkHeight: p.trunkHeight, damagedLAPercentage: p.damagedLAPercentage,
            // Score & Position
            seedCount: p.seedCount, spawnPoint: p.spawnPoint
        };
    });

    return {
        // Global environment
        day: globalState.day, timeInCycle: globalState.timeInCycle, currentPeriodIndex: globalState.currentPeriodIndex,
        isNight: globalState.isNight, currentLightMultiplier: globalState.currentLightMultiplier, currentDroughtFactor: globalState.currentDroughtFactor,
        isRaining: globalState.isRaining,
        // Game Phase & Countdown
        gamePhase: globalState.gamePhase, countdownTimer: globalState.countdownTimer,
        // Player states
        players: playersSnapshot,
        serverTime: Date.now()
    };
}

export function getFullGameStateSnapshot(players, globalState) {
    return getSimplifiedGameStateSnapshot(players, globalState);
}

export function broadcastGameState(io, players, globalState) {
    const snapshot = getSimplifiedGameStateSnapshot(players, globalState);
    io.emit('gameStateUpdate', snapshot);
}

--- FILE: server/server.js ---
// server/server.js (Main Entry Point)

import express from 'express';
import http from 'http';
import { Server as SocketIOServer } from 'socket.io';
import path from 'path';
import { fileURLToPath } from 'url';

// Import Server Modules
import { handleConnection } from './network/connection.js';
// import { updateSimulationTick } from './game/simulation.js'; // Simulation logic now within GameInstance
// import { broadcastGameState, getFullGameStateSnapshot } from './network/stateBroadcaster.js'; // Broadcasting handled by GameInstance
// import { getGlobalState, getAllPlayers, setGamePhase, getPlayerState } from './game/GameState.js'; // State now managed by instances
// import { resetGame, cancelLobbyCountdown } from './game/gameLogic.js'; // Game logic now within GameInstance
import { GameInstanceManager } from './game/GameInstanceManager.js'; // <<< Import the Manager
import * as Config from './config.js';

// --- Configuration & Setup ---
const PORT = process.env.PORT || 3000;
const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || "defaultAdminPass123";
// const TICK_RATE = 20; // Tick rate is now a Config property used by GameInstance
// const TICK_INTERVAL_MS = 1000 / TICK_RATE; // Calculated within GameInstance

// ES Module path setup
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const clientPath = path.join(__dirname, '..', 'client');

// Express and HTTP Server
const app = express();
const httpServer = http.createServer(app);

// Socket.IO Server
const io = new SocketIOServer(httpServer);

// --- Simulation Loop State ---
// let simulationInterval = null; // <<< REMOVED - Handled by GameInstance(s)
// let lastTickTime = Date.now(); // <<< REMOVED - Handled by GameInstance(s)

// --- Instantiate Game Instance Manager ---
const gameInstanceManager = new GameInstanceManager(io); // <<< Create the manager instance

// --- Admin Tracking ---
// This might still be useful globally or move into the manager? Keep global for now.
export const adminSockets = new Set();

// --- Express Routes & Static Files ---
console.log(`Serving static files from: ${clientPath}`);
app.use(express.static(clientPath));

app.get('/', (req, res) => { res.sendFile(path.join(clientPath, 'index.html')); });
app.get('/game', (req, res) => { res.sendFile(path.join(clientPath, 'game.html')); });
app.get('/settings', (req, res) => { res.sendFile(path.join(clientPath, 'settings.html')); });

app.get('/admin', (req, res) => {
    const providedPassword = req.query.pw;
    if (providedPassword && providedPassword === ADMIN_PASSWORD) {
        console.log("Admin access granted via HTTP route.");
        res.sendFile(path.join(clientPath, 'admin.html'));
    } else {
        console.log("Admin access denied. Incorrect or missing password.");
        res.status(403).send('Forbidden: Incorrect Admin Password');
    }
});

// --- Socket.IO Setup ---
io.on('connection', (socket) => {
    // Pass the instance manager to the connection handler
    handleConnection(socket, io, gameInstanceManager); // <<< Pass manager instance
});

// --- Main Simulation Loop Function ---
// function runGameTick() { ... } // <<< REMOVED - Logic moved to GameInstance.runTick()

// --- Simulation Control Functions ---
// These might become helper functions or move entirely into GameInstance/Manager
// For now, remove the export as they are not called globally anymore.
// export function startGame() { ... } // <<< REMOVED (or commented out)
// export function stopSimulation() { ... } // <<< REMOVED (or commented out)


// --- Start HTTP Server ---
httpServer.listen(PORT, () => {
    console.log(`Server listening on port ${PORT}`);
    console.log(`Admin access requires query param: ?pw=${ADMIN_PASSWORD}`);
    // No global reset needed here, manager handles instance creation/state
    // resetGame(); // <<< REMOVED
});

--- FILE: client/ui/setupListeners.js ---
// client/ui/setupListeners.js
import { uiElements } from './elements.js';
import { handleStomataChange, handleAllocationSliderChange } from './controlsHandlers.js';
// Import ONLY the socket instance from the shared module
import { socket } from '../socket.js'; // <<< ENSURE THIS IS THE ONLY SOCKET IMPORT

// Remove any other imports that might have included 'socket' from '../main.js'

/**
 * Attaches event listeners to the interactive UI elements.
 */
export function setupUIListeners() {
    console.log("UI: Setting up listeners...");

    // Attempt to cache elements if not already done (safer)
    if (Object.keys(uiElements).length === 0) {
        console.warn("UI Listeners: Caching DOM elements as they weren't cached before setupUIListeners call.");
        cacheDOMElements();
    }

    // --- Game Page Specific Listeners ---
    if (uiElements.stomataSlider) {
        uiElements.stomataSlider.addEventListener('input', handleStomataChange);
    }
    if (uiElements.savingsSlider) {
        uiElements.savingsSlider.addEventListener('input', handleAllocationSliderChange);
    }
    if (uiElements.growthRatioSlider) {
        uiElements.growthRatioSlider.addEventListener('input', handleAllocationSliderChange);
    }

    // The restart button listener is attached in gameOver.js, no need here.

    if (uiElements.startCountdownButton) {
        uiElements.startCountdownButton.addEventListener('click', () => {
            console.log("UI: Start Countdown button clicked.");
            if (socket && socket.connected) {
                 console.log(`UI: Emitting 'requestStartCountdown' via socket ${socket.id}. Connected: ${socket.connected}`);
                 socket.emit('requestStartCountdown'); // Send event to server
            } else {
                console.error("UI: Cannot start countdown, socket invalid or not connected.", { socket_exists: !!socket, connected: socket?.connected });
                alert("Error: Not connected to server. Cannot start countdown.");
            }
        });
    }

    console.log("UI: Listener setup function finished.");
}

--- FILE: client/gameState.js ---
// client/gameState.js
import * as Config from './config.js';

export const gameState = {
    // --- Server Synced State ---
    day: 1, timeInCycle: 0.0, currentPeriodIndex: -1, isNight: false,
    currentLightMultiplier: 1.0, currentDroughtFactor: Config.DROUGHT_MULT_BASE,
    isRaining: false, gamePhase: 'loading', players: {}, serverTime: Date.now(),
    countdownTimer: null,

    // --- Client-Specific State ---
    myId: null,
    isSpectator: false, // <<< Ensure this exists, defaults to false
    gameOver: false, gameOverReason: '', winnerId: null,
    playerTrees: new Map(),
    initialStateReceived: false,
};

export function loadClientSettings() {
    console.log("Client settings loaded (placeholder).");
}
loadClientSettings();

export function getMyPlayerState() {
    if (!gameState.myId || !gameState.players[gameState.myId]) return null;
    return gameState.players[gameState.myId];
}

--- FILE: client/admin.js ---
import * as THREE from 'three';
import { socket } from './socket.js'; // <<< Import from new module
import { gameState } from './gameState.js'; // Use gameState for caching server state
import * as Config from './config.js';
import { initScene, renderer, camera, controls, scene } from './sceneSetup.js'; // Reuse scene setup
import { createOrUpdateTree, removeTree, disposeAllTrees } from './tree.js'; // Reuse tree rendering
import { uiElements, cacheDOMElements } from './ui/elements.js'; // Cache admin page UI elements & uiElements ref
import { updateUI as updateAdminUI } from './ui/updateAdmin.js'; // Use a SEPARATE admin UI update function
import { showMessage, clearMessage, attachServerMessageListener } from './ui/messageHandler.js'; // Use message handler
import { hideGameOverModal, showGameOverUI } from './ui/gameOver.js'; // Import hide/show functions
import { updateEnvironmentVisuals, updateRain, setWeatherTargets, startRain, stopRain } from './environment.js';

// --- Global Variables ---
let clock = new THREE.Clock();
let animationFrameId = null;
// let socket = null; // <<< REMOVE
let isAdminAuthenticated = false; // Track websocket auth status
let targetInstanceId = null; // <<< Store the ID of the instance admin should observe
let messageListenerAttached = false; // Module-level flag for message listener


// --- Initialization Function ---
function initializeAdminApp() {
    console.log("Initializing Admin Panel Client...");
    // --- Get Admin Password from URL ---
    // No change needed here, password still needed for initial auth
    const urlParams = new URLSearchParams(window.location.search);
    const initialAdminPassword = urlParams.get('pw'); // Store locally for initial connect
    if (!initialAdminPassword) {
        console.error("Admin Password missing from URL (?pw=...).");
        document.body.innerHTML = '<h1>Access Denied: Admin password missing from URL (?pw=...)</h1>';
        return; // Stop execution if no password
    }
    // Don't clear URL history immediately, might need it on reconnect logic in 'connect' handler
    // try { history.replaceState(null, '', window.location.pathname); } catch (e) { console.warn("Could not clear URL history."); }

    // --- Basic Setup ---
    gameState.isSpectator = true; // Admin is always a spectator type
    cacheDOMElements(); // Cache elements defined in admin.html, including back button
    const canvas = uiElements.canvas; // Use cached canvas
    if (!canvas) { console.error("Admin Canvas element #game-canvas not found!"); return; }

    initScene(canvas); // Setup Three.js scene

     // +++ Add Back Button Listener +++
    if (uiElements.backButton) {
        uiElements.backButton.addEventListener('click', () => {
            console.log("Admin: Back to Menu button clicked.");
            if (socket && socket.connected) {
                socket.disconnect(); // Disconnect before navigating
            }
            window.location.href = '/'; // Navigate to main menu
        });
         console.log("Admin: Back button listener added.");
    } else {
         console.warn("Admin: Back button UI element not found during init.");
    }

    // Socket is already connecting via socket.js
    console.log("Admin: Socket connection managed by socket.js. Setting up listeners.");
    setupAdminSocketListeners(initialAdminPassword); // Pass initial password to listener setup
    setupAdminButtonListeners(); // Setup listeners for admin buttons
    updateAdminUI(); // Initial UI render
    clearMessage();
    console.log("Admin Client Initialization complete.");
}

// --- Socket Event Listener Setup ---
function setupAdminSocketListeners(initialPassword) { // Accept initial password
     // Listen for 'connect' event from the shared socket
     socket.on('connect', () => {
         // Check if we already authenticated for this connection instance
         // (socket.id should be populated by the time 'connect' fires)
         if (socket.id && socket.id !== gameState.myId) { // Only authenticate if ID changed or is new
             gameState.myId = socket.id; // Update local ID
             console.log(`Admin: Socket connected with ID: ${gameState.myId}. Authenticating...`);
             showMessage(`Admin connected. Authenticating...`, 'info');

             // Use the password passed during setup or try to get from URL again (for reconnects)
             let passwordToSend = initialPassword;
             if (!passwordToSend) {
                 const urlParams = new URLSearchParams(window.location.search);
                 passwordToSend = urlParams.get('pw');
                 console.log("Admin: Re-fetching password from URL for authentication.");
             }

             if (passwordToSend) {
                 console.log("Admin: Sending authentication request...");
                 socket.emit('adminAuthenticate', { password: passwordToSend });
                 // Clear URL history *after* successful authentication might be better
             } else {
                 console.error("Admin: Password missing from URL/initial setup on (re)connect.");
                 showMessage(`Authentication Error! No password found.`, 'error');
                 socket.disconnect(); // Can't authenticate, disconnect
             }
             // Do not clear password variable here

             // Attach message listener *once* per logical connection attempt
             if (!messageListenerAttached) {
                 console.log("Admin: Attaching server message listener.");
                 attachServerMessageListener();
                 messageListenerAttached = true; // Set flag
             }
         } else if (!socket.id) {
             console.warn("Admin: 'connect' event fired but socket.id is still null?");
         } else {
             console.log(`Admin: Socket already connected with ID ${socket.id}. Waiting for auth result if pending.`);
             // Potentially re-send auth if not authenticated yet?
             if (!isAdminAuthenticated && initialPassword) {
                  console.log("Admin: Re-sending authentication request on existing connection (was not authenticated)...");
                  socket.emit('adminAuthenticate', { password: initialPassword });
             }
         }
     });

    socket.on('adminAuthResult', (result) => {
        if (result.success) {
            isAdminAuthenticated = true;
            console.log("Admin: WebSocket Authentication successful.");
            showMessage(`Admin Authenticated`, 'success');
            if (uiElements.adminControls) {
                uiElements.adminControls.style.display = 'flex';
            }
            // Maybe clear URL history now?
            try { history.replaceState(null, '', window.location.pathname); } catch (e) { console.warn("Could not clear URL history after auth."); }
        } else {
            isAdminAuthenticated = false;
            console.error("Admin: WebSocket Authentication Failed!", result.reason);
            showMessage(`Admin Auth Failed: ${result.reason || 'Invalid Password'}`, 'error');
            if (uiElements.adminControls) {
                uiElements.adminControls.style.display = 'none';
            }
            // Consider disconnecting if auth fails persistently
            // if(socket) socket.disconnect();
        }
    });

    socket.on('disconnect', (reason) => {
        console.log(`Admin: Disconnected: ${reason}`);
        showMessage("Disconnected!", "error");
        isAdminAuthenticated = false; // Reset auth status
        gameState.myId = null; // Clear ID
        messageListenerAttached = false; // Allow re-attaching on next connect
        gameState.initialStateReceived = false;
        targetInstanceId = null; /* Clear target instance */
        if (animationFrameId !== null) cancelAnimationFrame(animationFrameId); animationFrameId = null;
        if (uiElements.adminControls) { uiElements.adminControls.style.display = 'none'; }
        disposeAllTrees();
        // Don't clear players here, rely on next gameStateUpdate
    });

    // connect_error listener is now in socket.js
    // socket.on('connect_error', (error) => { ... });

    // --- Game State Update Handler (Spectator View) ---
    socket.on('gameStateUpdate', (serverState) => {
        // --- Ensure admin is authenticated before processing game state ---
        // Although server *shouldn't* send updates if auth failed, this is safer client-side
        if (!isAdminAuthenticated) {
             // console.log("Admin GS Update: Skipping update, not authenticated.");
             return;
        }

        if (!gameState.myId) { console.log("Admin GS Update: Skipping update, myId not set yet."); return; } // Need own ID first

        // +++ Check if this update is from the correct instance +++
         if (!targetInstanceId) {
             if (serverState.instanceId) {
                 if(serverState.players && serverState.players[gameState.myId]){
                      console.log(`Admin GS Update: Received first valid state from Instance ${serverState.instanceId}. Setting as target.`);
                      targetInstanceId = serverState.instanceId;
                 } else {
                      console.warn(`Admin GS Update: Received initial state from Instance ${serverState.instanceId}, but it doesn't contain my ID (${gameState.myId}). Waiting for correct instance state.`);
                      return;
                 }
             } else {
                  console.warn("Admin GS Update: Received state without instanceId. Cannot determine target. Ignoring update.");
                  return;
             }
         } else if (serverState.instanceId !== targetInstanceId) {
             // console.warn(`Admin GS Update: Ignoring state from wrong instance ${serverState.instanceId} (Target: ${targetInstanceId}).`);
             return; // Ignore updates from other instances
         }
         // +++ If we reach here, the update is for the correct instance +++

         const previousPhase = gameState.gamePhase;
         const playersFromServer = serverState.players || {};
         const myServerData = playersFromServer[gameState.myId];

         // +++ Log Received Admin State +++
         if (myServerData) {
              // console.log(`Admin GS Update (${targetInstanceId}): Received state for self (${gameState.myId}): isSpectator=${myServerData.isSpectator}, isAlive=${myServerData.isAlive}, Name=${myServerData.playerName}`); // Reduce noise
         } else {
              console.warn(`Admin GS Update (${targetInstanceId}): Did not receive state for self (${gameState.myId}) in this update.`);
         }
         // ++++++++++++++++++++++++++++++++

         // Update core state properties
         Object.assign(gameState, {
             day: serverState.day, timeInCycle: serverState.timeInCycle, currentPeriodIndex: serverState.currentPeriodIndex, isNight: serverState.isNight, currentLightMultiplier: serverState.currentLightMultiplier, currentDroughtFactor: serverState.currentDroughtFactor, isRaining: serverState.isRaining, gamePhase: serverState.gamePhase, countdownTimer: serverState.countdownTimer, serverTime: serverState.serverTime, players: playersFromServer, allowPlayerCountdownStart: serverState.allowPlayerCountdownStart,
         });
         // *** Force isSpectator based on received data for self, fallback to true if self not found ***
         gameState.isSpectator = myServerData ? myServerData.isSpectator : true;

         if (!gameState.initialStateReceived && myServerData) {
             console.log(`Admin: First valid state for target instance ${targetInstanceId} processed.`);
             if(controls && camera) { // Ensure camera also exists
                 controls.target.set(0, 5, 0);
                 camera.position.set(15, 20, 15); // Overview position
                 controls.update();
                 console.log("Admin camera position set:", camera.position);
                 console.log("Admin controls target set:", controls.target);
             }
             setWeatherTargets(gameState.isNight, gameState.currentLightMultiplier < Config.LIGHT_MULT_SUNNY - 0.1, gameState.isRaining);
             updateEnvironmentVisuals(1000); if(gameState.isRaining) startRain(); else stopRain();
             gameState.initialStateReceived = true; startGameLoop();
             setTimeout(() => showMessage(`Game state: ${gameState.gamePhase}`, 'info'), 100);
         } else if (gameState.gamePhase !== previousPhase) {
             console.log(`Admin phase updated to: ${gameState.gamePhase}`); showMessage(`Game state: ${gameState.gamePhase}`, 'info');
             if(gameState.gamePhase !== 'ended' && uiElements.gameOverModal && !uiElements.gameOverModal.classList.contains('hidden')) { hideGameOverModal(); }
         }

         /* Update Environment */ const wasRaining = scene?.getObjectByName("rain")?.visible ?? false; setWeatherTargets(gameState.isNight, gameState.currentLightMultiplier < Config.LIGHT_MULT_SUNNY - 0.1, gameState.isRaining); if (gameState.isRaining && !wasRaining) startRain(); else if (!gameState.isRaining && wasRaining) stopRain();

         /* Update Trees */
         // console.log(`--- Admin Tree Update Loop START (Instance: ${targetInstanceId}) ---`);
         const receivedPlayerIds = new Set(Object.keys(playersFromServer));
         for (const playerId in playersFromServer) {
             const playerData = playersFromServer[playerId];
             const isPlayerSpectatorInThisUpdate = playerData.isSpectator || playerData.playerName.startsWith('ADMIN_');
             // console.log(`Admin Tree Update: Processing P:[${playerId.substring(0,5)}] Is Spectator Flag (this update): ${isPlayerSpectatorInThisUpdate}`);

             if (isPlayerSpectatorInThisUpdate) {
                 // console.log(`Admin Tree Update: Calling removeTree for spectator/admin ${playerId}`);
                 removeTree(playerId);
             } else {
                 // console.log(`Admin Tree Update: Calling createOrUpdateTree for non-spectator ${playerId}`);
                 createOrUpdateTree(playerId, playerData);
             }
         }
         gameState.playerTrees.forEach((_, playerId) => { if (!receivedPlayerIds.has(playerId)) { removeTree(playerId); } });
         // console.log("--- Admin Tree Update Loop END ---");

         /* Update Camera Target */ if (controls) controls.target.lerp(new THREE.Vector3(0, 5, 0), 0.05);

         updateAdminUI(); // Update non-tree UI

     }); // End gameStateUpdate

    socket.on('playerDisconnected', (playerId) => { console.log(`Admin View: Player ${playerId} disconnected.`); removeTree(playerId); /* UI updates on next gameStateUpdate */ });
    socket.on('gameOver', (data) => {
         console.log("Admin View: Game Over event received:", data);
         gameState.gameOver = true; gameState.gameOverReason = data.reason || "Game Ended"; gameState.winnerId = data.winnerId;
         showGameOverUI();
    });
    // serverMessage listener attached via attachServerMessageListener
    // socket.on('serverMessage', (data) => { ... });

} // End of setupAdminSocketListeners


// --- Setup Listeners for Admin Buttons ---
function setupAdminButtonListeners() {
    console.log("Admin: Setting up button listeners...");
    const forceStartBtn = document.getElementById('admin-force-start');
    const forceEndBtn = document.getElementById('admin-force-end');
    const resetCountdownBtn = document.getElementById('admin-reset-countdown');
    // const closeModalBtn = uiElements.adminCloseModalButton; // Listener attached in showGameOverUI

    if (uiElements.adminControls) uiElements.adminControls.style.display = 'none'; // Start hidden

    function emitAdminCommand(command) {
        // Use the imported socket directly
        if (socket && socket.connected && isAdminAuthenticated) {
            console.log(`Admin: Emitting command: ${command}`);
            socket.emit(command);
        } else { console.error(`Admin: Cannot send command '${command}', socket not connected or not authenticated.`); showMessage("Cannot send command: Not authenticated.", "error"); }
    }

    if (forceStartBtn) forceStartBtn.addEventListener('click', () => emitAdminCommand('adminForceStart')); else console.warn("Admin button 'admin-force-start' not found.");
    if (forceEndBtn) forceEndBtn.addEventListener('click', () => emitAdminCommand('adminForceEnd')); else console.warn("Admin button 'admin-force-end' not found.");
    if (resetCountdownBtn) resetCountdownBtn.addEventListener('click', () => emitAdminCommand('adminResetCountdown')); else console.warn("Admin button 'admin-reset-countdown' not found.");

}

// --- Admin Rendering Loop ---
function gameLoop() {
    animationFrameId = requestAnimationFrame(gameLoop);
    const deltaTime = clock.getDelta();
    // +++ Add Log +++
    // console.log(`Admin gameLoop tick: ${deltaTime.toFixed(4)}`); // Can be noisy, use temporarily
    updateEnvironmentVisuals(deltaTime);
    updateRain(deltaTime);
    updateAdminUI(); // Use the dedicated admin UI updater
    if (controls) controls.update();
    if (renderer && scene && camera) {
         renderer.render(scene, camera); // Render AFTER updates
    } else {
         console.error("Admin Render components missing!");
         stopGameLoop();
    }
}
function startGameLoop() {
    if (animationFrameId !== null) return;
    console.log("Admin: Starting render loop.");
    clock = new THREE.Clock(); // Reset clock
    gameLoop();
}
function stopGameLoop() {
    if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        console.log("Admin: Stopped render loop.");
    }
}

// --- Start Admin Application ---
// Conditional check remains the same
const adminScriptUrl = new URL('/admin.js', window.location.origin).href;
if (import.meta.url === adminScriptUrl) {
     console.log("admin.js detected as entry point script. Adding DOMContentLoaded listener.");
     document.addEventListener('DOMContentLoaded', initializeAdminApp);
} else {
     console.log(`admin.js imported as dependency (URL: ${import.meta.url}), skipping initializeAdminApp listener.`);
}

--- FILE: client/ui/gameOver.js ---
// client/ui/gameOver.js
import { gameState, getMyPlayerState } from '../gameState.js';
import { uiElements } from './elements.js';
// Import the socket instance from the new dedicated module
import { socket } from '../socket.js'; // <<< ADD socket import

// --- Define handleRestart locally ---
function handleRestart() {
    console.log("UI: Restart button clicked, navigating to /");
    if (socket && socket.connected) {
       console.log("UI: Disconnecting socket before restart...");
       socket.disconnect();
    }
    // Use a small delay to allow socket disconnect message to potentially send/process
    setTimeout(() => {
        window.location.href = '/';
    }, 100); // 100ms delay
}

/** Displays the Game Over modal. */
export function showGameOverUI() {
    console.log("UI: showGameOverUI called.");
    if (!uiElements.gameOverModal) { console.error("UI ERROR: gameOverModal element not found!"); return; }
    // Check optional elements safely
    if (!uiElements.gameOverReasonUI) { console.warn("UI element gameOverReasonUI missing."); }
    if (!uiElements.finalDayUI) { console.warn("UI element finalDayUI missing."); }
    if (!uiElements.finalSeedsUI) { console.warn("UI element finalSeedsUI missing."); }

    const myFinalState = getMyPlayerState();
    const finalDay = gameState.day;
    // Show N/A seeds if spectator or state missing
    const finalSeeds = (myFinalState && !gameState.isSpectator) ? myFinalState.seedCount : 'N/A';
    // Determine if this client is admin (by checking if admin controls exist on page)
    const isAdminView = !!document.getElementById('admin-controls'); // Check if admin controls are present

    // --- Populate Modal Content ---
    let reasonText = gameState.gameOverReason || "The game has ended!"; // Default reason
    if (gameState.winnerId) {
        const winnerState = gameState.players[gameState.winnerId];
        const winnerName = winnerState?.playerName || `Player ${gameState.winnerId.substring(0,4)}`;
        // Check if WE are the winner (and not a spectator)
        if (gameState.winnerId === gameState.myId && !gameState.isSpectator) { reasonText += `<br><strong>Congratulations, you had the most seeds!</strong>`; }
        else { reasonText += `<br>Winner: ${winnerName} with ${winnerState?.seedCount ?? '?'} seeds.`; }
    } else if (reasonText.indexOf("admin") === -1 && reasonText.indexOf("ended") > -1) { // Avoid adding "no winner" if admin ended it or just ended naturally
         reasonText += "<br>No winner declared.";
    }

    if(uiElements.gameOverReasonUI) uiElements.gameOverReasonUI.innerHTML = reasonText;

    // Show/Hide player-specific stats based on view type and spectator status
    const showPlayerStats = !isAdminView && !gameState.isSpectator; // Show stats only if regular player view AND not spectator

    if(uiElements.finalDayUI && uiElements.finalDayUI.parentElement) { // Check parent exists
        uiElements.finalDayUI.textContent = finalDay;
        uiElements.finalDayUI.parentElement.style.display = showPlayerStats ? 'block' : 'none'; // Show/hide the whole <p> tag
    }
    if(uiElements.finalSeedsUI && uiElements.finalSeedsUI.parentElement) { // Check parent exists
        uiElements.finalSeedsUI.textContent = finalSeeds;
         uiElements.finalSeedsUI.parentElement.style.display = showPlayerStats ? 'block' : 'none'; // Show/hide the whole <p> tag
    }

    // --- Show/Hide and Setup Buttons ---
    const adminCloseButton = document.getElementById('admin-close-modal'); // Reference admin specific button if it exists

    // Regular Player View: Show 'Play Again' (which reloads to '/')
    if (uiElements.restartButton) {
        uiElements.restartButton.style.display = showPlayerStats ? 'inline-block' : 'none';
        if (showPlayerStats) {
            // Attach listener (remove first to prevent duplicates if modal shown multiple times)
            uiElements.restartButton.removeEventListener('click', handleRestart); // Use the local handleRestart
            uiElements.restartButton.addEventListener('click', handleRestart); // Use the local handleRestart
        }
    }
    // Admin View: Show 'Close'
    if (adminCloseButton) {
        adminCloseButton.style.display = isAdminView ? 'inline-block' : 'none';
         if (isAdminView) {
             // Attach listener (remove first to prevent duplicates)
             adminCloseButton.removeEventListener('click', hideGameOverModal);
             adminCloseButton.addEventListener('click', hideGameOverModal);
         }
    } else if (isAdminView) {
         // Warn if admin view but expected button is missing
         console.warn("Admin view detected, but 'admin-close-modal' button not found in HTML.");
    }


    // Show the Modal itself
    uiElements.gameOverModal.classList.remove('hidden');
    console.log("UI: Game over modal made visible.");
}

/** Hides the Game Over modal. */
export function hideGameOverModal() {
    if (uiElements.gameOverModal) {
        uiElements.gameOverModal.classList.add('hidden');
        console.log("UI: Game over modal hidden.");
    } else { console.warn("UI: Tried to hide game over modal, element not found."); }
}

--- FILE: .gitignore ---
dirgrab.txt
server/node_modules
package-lock.json

--- FILE: client/game.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Island Canopy Sim</title>
    <link rel="stylesheet" href="/style.css"> <!-- Use root-relative path -->
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
    </div>

    <!-- ================================== -->
    <!-- +++ Back to Menu Button +++ -->
    <!-- ================================== -->
    <button id="back-to-menu-button" class="back-button">Back to Menu</button>


    <!-- ================================== -->
    <!-- UI Structure -->
    <!-- ================================== -->

    <!-- Top Left Info Area -->
    <div id="top-left-info" class="ui-panel">
         <p>Day: <span id="day-counter">1</span></p>
         <p>Time: <span id="time-of-day">Loading...</span></p> <!-- Start with Loading -->
         <p>Weather: <span id="weather-status">--</span></p>
         <p>Cycle Left: <span id="cycle-timer">--</span>s</p>
         <div id="message-log" class="message"></div>

         <!-- Lobby/Countdown Specific UI (Initially Hidden) -->
         <div id="lobby-info" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #555;">
             <h4>Lobby</h4>
             <p>Players (<span id="lobby-player-count">0</span>)</p>
             <!-- +++ Add instruction text here +++ -->
             <p id="lobby-instruction" style="font-style: italic; color: #cccccc; margin-bottom: 8px;">Click on the island to choose your starting location!</p>
             <p id="countdown-timer-display" style="font-weight: bold; color: #ffc107;"></p> <!-- Timer display -->
             <button id="start-countdown-button" style="margin-top: 5px;">Start Countdown</button> <!-- Text updated by JS -->
         </div>

    </div>

     <!-- Top Right Leaderboard Area -->
    <div id="top-right-leaderboard" class="ui-panel leaderboard">
         <!-- Title changes based on phase -->
         <h4 id="leaderboard-title">Leaderboard (-/-)</h4> <!-- Updated placeholder -->
         <ul id="leaderboard-list">
             <li>Waiting for state...</li>
         </ul>
    </div>

     <!-- Bottom Left Status Area -->
     <div id="bottom-left-status" class="ui-panel"> <!-- <<< Ensure this ID is present -->
          <div class="status-bar-container">
                <label>Carbon:</label>
                <div class="bar-outer"><div id="carbon-bar" class="bar-inner carbon" style="width: 0%;"></div></div> <!-- Start at 0% -->
                <span id="carbon-value">--</span>
            </div>
            <div class="status-bar-container">
                <label>Hydraulics:</label>
                <div class="bar-outer"><div id="hydraulic-bar" class="bar-inner hydraulic" style="width: 0%;"></div></div> <!-- Start at 0% -->
                 <span id="hydraulic-value">--</span>
            </div>
             <p>Seeds: <span id="seed-counter">0</span></p>
     </div>

     <!-- Control Panel Area (Bottom Right) -->
     <div id="control-panel-right" class="ui-panel" style="display: none;"> <!-- Start hidden -->
          <div class="control-row stomata">
             <label for="stomata-slider">Stomatal Openness:</label>
             <input type="range" id="stomata-slider" min="0" max="1" step="0.05" value="0.5">
             <span id="stomata-value">50%</span>
          </div>
          <div class="control-row allocation">
             <label for="savings-slider">Carbon Savings %:</label>
             <input type="range" id="savings-slider" min="0" max="100" step="1" value="50">
             <span class="slider-percentage" id="savings-percentage">50%</span>
          </div>
           <div class="control-row allocation">
             <label for="growth-ratio-slider"> Invest % Grow/Seeds:</label>
             <input type="range" id="growth-ratio-slider" min="0" max="100" step="1" value="50">
             <span class="slider-percentage" id="growth-ratio-percentage">50%/50%</span>
          </div>
     </div>
     <!-- End Control Panel Area -->

    <!-- Game Over Modal (Still separate) -->
    <div id="game-over-modal" class="modal hidden">
         <h2>Game Over!</h2>
        <p id="game-over-reason"></p>
        <p>You survived <span id="final-day">0</span> days and produced <span id="final-seeds">0</span> seeds.</p>
        <button id="restart-button">Play Again</button>
    </div>

    <!-- Imports -->
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } } </script>
    <script src="/socket.io/socket.io.js"></script>
    <script type="module" src="/main.js"></script> <!-- Use root-relative path -->
</body>
</html>

--- FILE: server/game/GameInstanceManager.js ---
// server/game/GameInstanceManager.js
import { GameInstance } from './GameInstance.js';
import * as Config from '../config.js'; // Import Config here

class GameInstanceManager {
    constructor(io) {
        this.io = io; // Socket.IO server instance
        this.instances = new Map(); // Map<instanceId, GameInstance>
        this.multiplayerInstanceId = null; // Track the ID of the single multiplayer game instance
        this.playerInstanceMap = new Map(); // Map<socketId, instanceId> - To quickly find which instance a player belongs to
        console.log("GameInstanceManager initialized.");
    }

    // --- Instance Creation ---

    createSinglePlayerInstance(socket) {
        console.log(`InstanceMgr: Creating new single-player instance for ${socket.id}`);
        const instance = new GameInstance('single', this.io);
        this.instances.set(instance.state.instanceId, instance);
        console.log(`InstanceMgr: Added instance ${instance.state.instanceId} to manager. Total instances: ${this.instances.size}`);
        return instance;
    }

    getOrCreateMultiplayerInstance() {
        if (this.multiplayerInstanceId && this.instances.has(this.multiplayerInstanceId)) {
            return this.instances.get(this.multiplayerInstanceId);
        } else {
            console.log("InstanceMgr: Creating new (and only) multiplayer instance.");
            const instance = new GameInstance('multi', this.io);
            this.instances.set(instance.state.instanceId, instance);
            this.multiplayerInstanceId = instance.state.instanceId; // Store its ID
            console.log(`InstanceMgr: Added multiplayer instance ${instance.state.instanceId}. Total instances: ${this.instances.size}`);
            return instance;
        }
    }

    // --- Instance Management ---

    getInstance(instanceId) {
        return this.instances.get(instanceId) || null;
    }

    removeInstance(instanceId) {
        const instance = this.instances.get(instanceId);
        if (instance) {
            console.log(`InstanceMgr: Removing instance ${instanceId} (Mode: ${instance.state.mode}).`);
            instance.stopSimulationLoop();
            instance.stopCountdown();
            instance.getAllPlayers().forEach((playerData, socketId) => {
                 this.playerInstanceMap.delete(socketId);
                 const socket = instance.findSocket(socketId);
                 if (socket) { socket.leave(instance.state.roomId); }
            });
            this.instances.delete(instanceId);
            if (this.multiplayerInstanceId === instanceId) {
                console.log(`InstanceMgr: Removed multiplayer instance. It needs to be recreated.`);
                this.multiplayerInstanceId = null;
            }
            console.log(`InstanceMgr: Instance ${instanceId} removed. Remaining instances: ${this.instances.size}`);
            return true;
        }
         console.warn(`InstanceMgr: Tried to remove non-existent instance ${instanceId}`);
        return false;
    }

    // --- Player Routing & Management ---
    // <<<--- ACCEPT SETTINGS ARGUMENT (make it optional for admin/spectate) ---<<<
    routePlayer(socket, intent, isAdmin, settings = null) {
        console.log(`InstanceMgr: Routing player ${socket.id} with intent: ${intent}, isAdmin: ${isAdmin}`);
        let targetInstance = null;

        if (isAdmin || intent === 'spectate') {
            // Admins/Spectators don't typically need custom settings applied this way
            console.log(`InstanceMgr: Routing admin/spectator ${socket.id} to multiplayer instance.`);
            targetInstance = this.getOrCreateMultiplayerInstance();
            const playerState = targetInstance.addPlayer(socket);
            if (playerState) {
                playerState.isSpectator = true;
                playerState.isAlive = false;
                if (isAdmin) playerState.playerName = `ADMIN_${socket.id.substring(0, 4)}`;
                // Don't apply user settings to admin/spectator unless desired

                console.log(`InstanceMgr: Player state for ${socket.id} SET: isSpectator=${playerState.isSpectator}, isAlive=${playerState.isAlive}, Name=${playerState.playerName}`);
                this.playerInstanceMap.set(socket.id, targetInstance.state.instanceId);
                const snapshotData = targetInstance.getSnapshot();
                const adminDataInSnapshot = snapshotData.players[socket.id];
                console.log(`InstanceMgr: Sending initial snapshot. Admin (${socket.id}) data in snapshot: isSpectator=${adminDataInSnapshot?.isSpectator}, isAlive=${adminDataInSnapshot?.isAlive}`);
                socket.emit('gameStateUpdate', snapshotData);
                targetInstance.broadcastState();
            } else {
                 console.error(`InstanceMgr: Failed to add admin/spectator ${socket.id} to multiplayer instance.`);
                 socket.disconnect(true);
                 return null;
            }

        } else if (intent === 'single') {
            targetInstance = this.createSinglePlayerInstance(socket);
            const playerState = targetInstance.addPlayer(socket);
             if (playerState) {
                 playerState.isSpectator = false;
                 playerState.isAlive = true;
                 const baseHeight = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
                 playerState.spawnPoint = { x: 0, y: baseHeight, z: 0 };
                 playerState.hasChosenSpawn = true;

                 // --->>> APPLY SETTINGS FOR SINGLE PLAYER <<<---
                 if (settings) {
                     playerState.playerName = settings.playerName;
                     playerState.leafColor = settings.leafColor;
                     playerState.trunkColor = settings.trunkColor;
                     console.log(`InstanceMgr: Applied settings to single player ${socket.id}:`, { name: playerState.playerName, leaf: playerState.leafColor, trunk: playerState.trunkColor });
                 } else {
                      console.warn(`InstanceMgr: No settings provided for single player ${socket.id}. Using defaults.`);
                 }
                 // ---<<< END APPLY SETTINGS >>>---

                 targetInstance.setGamePhase('playing');
                 targetInstance.startSimulationLoop();
                 this.playerInstanceMap.set(socket.id, targetInstance.state.instanceId);
                 console.log(`InstanceMgr: Sending initial state snapshot to single player ${socket.id}`);
                 socket.emit('gameStateUpdate', targetInstance.getSnapshot());
             } else {
                  console.error(`InstanceMgr: Failed to add player ${socket.id} to new single-player instance.`);
                  if (targetInstance) this.removeInstance(targetInstance.state.instanceId);
                  socket.disconnect(true);
                  return null;
             }

        } else if (intent === 'multi') {
            targetInstance = this.getOrCreateMultiplayerInstance();
            const currentPhase = targetInstance.state.gamePhase;
            const playerState = targetInstance.addPlayer(socket);

            if(!playerState){
                 console.error(`InstanceMgr: Failed to add multiplayer player ${socket.id}.`);
                 socket.disconnect(true);
                 return null;
            }

             playerState.isSpectator = false; // Default for multi intent
             playerState.isAlive = false;

            // --->>> APPLY SETTINGS FOR MULTIPLAYER <<<---
            if (settings) {
                playerState.playerName = settings.playerName;
                playerState.leafColor = settings.leafColor;
                playerState.trunkColor = settings.trunkColor;
                console.log(`InstanceMgr: Applied settings to multiplayer player ${socket.id}:`, { name: playerState.playerName, leaf: playerState.leafColor, trunk: playerState.trunkColor });
            } else {
                 console.warn(`InstanceMgr: No settings provided for multiplayer player ${socket.id}. Using defaults.`);
            }
            // ---<<< END APPLY SETTINGS >>>---

            // Determine spectator status based on phase *after* applying settings
            if (currentPhase === 'playing' || currentPhase === 'countdown') {
                console.warn(`InstanceMgr: Player ${socket.id} (${playerState.playerName}) joining active multiplayer game (Phase: ${currentPhase}). Forcing Spectator.`);
                playerState.isSpectator = true; // Force spectator
                socket.emit('serverMessage', { text: 'Game in progress, joining as spectator.', type: 'warning'});
            } else {
                 console.log(`InstanceMgr: Player ${socket.id} (${playerState.playerName}) joining multiplayer lobby (Phase: ${currentPhase}).`);
                 // isSpectator = false, isAlive = false (already set)
            }

            this.playerInstanceMap.set(socket.id, targetInstance.state.instanceId); // Map player to instance
            console.log(`InstanceMgr: Sending initial state snapshot to multiplayer player ${socket.id}`);
            socket.emit('gameStateUpdate', targetInstance.getSnapshot());
            targetInstance.broadcastState(); // Inform others
        }
        else {
            console.error(`InstanceMgr: Unknown intent '${intent}' for player ${socket.id}. Disconnecting.`);
            socket.disconnect(true);
            return null; // Explicitly return null on failure
        }

        // Return the instance the player was routed to (or null if failed)
        return targetInstance;
    }


    getInstanceIdForPlayer(socketId) {
        return this.playerInstanceMap.get(socketId) || null;
    }

    removePlayerFromInstance(socketId) {
        const instanceId = this.getInstanceIdForPlayer(socketId);
        if (instanceId) {
            const instance = this.getInstance(instanceId);
            if (instance) {
                 const wasRemoved = instance.removePlayer(socketId);
                 if (wasRemoved) {
                      this.playerInstanceMap.delete(socketId);
                      console.log(`InstanceMgr: Removed player ${socketId} from instance map.`);
                      if (instance.state.mode === 'single' && instance.getAllPlayers().size === 0) {
                           console.log(`InstanceMgr: Last player left single-player instance ${instanceId}. Removing instance.`);
                           this.removeInstance(instanceId);
                      }
                      else if (instance.getAllPlayers().size > 0) {
                          instance.broadcastState();
                      }
                      return true;
                 }
            } else {
                 console.error(`InstanceMgr: Instance ${instanceId} not found for player ${socketId} during removal.`);
                 this.playerInstanceMap.delete(socketId);
            }
        } else {
             console.warn(`InstanceMgr: Cannot remove player ${socketId}, instance ID not found in map.`);
        }
        return false;
    }
}

export { GameInstanceManager };

--- FILE: server/network/connection.js ---
import { adminSockets } from '../server.js';
import * as Config from '../config.js';
// Game state, logic, and simulation are now handled by GameInstance and GameInstanceManager

const MIN_SPAWN_DISTANCE_SQ = 4 * 4;
const CONNECTION_TIMEOUT_MS = 5000; // 5 seconds to send intent or authenticate

/** Sets up event listeners for a newly connected socket. */
// Accept gameInstanceManager as argument
export function handleConnection(socket, io, gameInstanceManager) {
    console.log(`Connection: Player connected: ${socket.id}. Waiting for intent or admin auth...`);

    let connectionTimeout = setTimeout(() => {
        console.warn(`Connection: Timeout waiting for intent/auth from ${socket.id}. Disconnecting.`);
        socket.disconnect(true);
    }, CONNECTION_TIMEOUT_MS);

    let hasRouted = false; // Flag to prevent double routing

    // --- Listener for Admin Authentication ---
    socket.once('adminAuthenticate', (data) => {
        if (hasRouted) return; // Already handled by playerJoinRequest? Unlikely but safe.
        clearTimeout(connectionTimeout); // Clear the timeout

        const serverAdminPassword = process.env.ADMIN_PASSWORD || "defaultAdminPass123";
        if (data?.password && data.password === serverAdminPassword) {
            console.log(`Connection: Admin auth OK for ${socket.id}`);
            adminSockets.add(socket.id); // Mark as admin globally
            socket.emit('adminAuthResult', { success: true });

            hasRouted = true; // Mark as routed
            // Admin doesn't send settings, routePlayer handles default admin name
            const targetInstance = gameInstanceManager.routePlayer(socket, 'spectate', true); // Route as admin spectator
            if (targetInstance) {
                setupInputAndActionListeners(socket, io, gameInstanceManager); // Setup listeners AFTER routing
            } else { console.error(`Connection: Failed to route authenticated admin ${socket.id}.`); }

        } else {
            console.warn(`Connection: Admin auth FAILED for ${socket.id}`);
            socket.emit('adminAuthResult', { success: false, reason: 'Invalid Password' });
            // Keep socket open briefly to send result, then disconnect
            setTimeout(() => socket.disconnect(true), 500);
        }
    });

    // --- Listener for Regular Player Join ---
    socket.once('playerJoinRequest', (data) => { // 'data' contains the payload from the client
        if (hasRouted) return; // Already handled by adminAuthenticate?
        clearTimeout(connectionTimeout); // Clear the timeout

        // Basic validation of join data
        if (!data || !data.intent || !['single', 'multi', 'spectate'].includes(data.intent)) {
             console.warn(`Connection: Received invalid playerJoinRequest from ${socket.id}. Data:`, data);
             socket.disconnect(true);
             return;
        }
        // Prevent regular players from claiming admin status via join request
        if (adminSockets.has(socket.id)) {
            console.warn(`Connection: Denying playerJoinRequest from already identified admin ${socket.id}`);
            return; // Ignore request
        }

        // <<<--- LOG RECEIVED DATA ---<<<
        console.log(`Connection: Received playerJoinRequest from ${socket.id}. Intent: ${data.intent}. Payload:`, data);

        // Extract settings (provide defaults if missing, though client should send them)
        const settings = {
            playerName: data.playerName || `Player_${socket.id.substring(0, 4)}`,
            leafColor: data.leafColor || '#228B22', // Default Green from server/config.js could be used here too
            trunkColor: data.trunkColor || '#8B4513' // Default Brown from server/config.js
        };
        // ---<<< LOG EXTRACTED SETTINGS --->>>
        console.log(`Connection: Extracted settings for ${socket.id}:`, settings);


        hasRouted = true; // Mark as routed
        // ---<<< PASS SETTINGS TO ROUTEPLAYER ---<<<
        const targetInstance = gameInstanceManager.routePlayer(socket, data.intent, false, settings); // Pass settings object

        if (targetInstance) {
            // Settings should be applied within routePlayer or immediately after
            setupInputAndActionListeners(socket, io, gameInstanceManager); // Setup listeners AFTER routing
        } else {
            console.error(`Connection: Failed to route player ${socket.id} with intent ${data.intent}.`);
        }
    });

    // --- Disconnect Handling ---
    socket.on('disconnect', (reason) => {
        // Clear timeout just in case disconnect happens before routing
        clearTimeout(connectionTimeout);
        console.log(`Connection: Disconnect event for ${socket.id}. Reason: ${reason}`);
        if (adminSockets.has(socket.id)) {
            adminSockets.delete(socket.id);
            console.log(`Connection: Removed ${socket.id} from global admin set.`);
        }
        // If the player was successfully routed, delegate removal to the manager
        if(hasRouted) {
            gameInstanceManager.removePlayerFromInstance(socket.id);
        } else {
             console.log(`Connection: Player ${socket.id} disconnected before routing.`);
        }
    });
} // End of handleConnection


/** Sets up listeners for controls AND actions coming from the client */
// Accept gameInstanceManager as argument
function setupInputAndActionListeners(socket, io, gameInstanceManager) {
    console.log(`Connection: Setting up input/action listeners for ${socket.id}`); // Add log

    // Helper function to get the instance for the current socket
    function getInstanceForSocket() {
        const instanceId = gameInstanceManager.getInstanceIdForPlayer(socket.id);
        if (!instanceId) { console.error(`InputHandler: Cannot find instance ID for socket ${socket.id}`); return null; }
        const instance = gameInstanceManager.getInstance(instanceId);
        if (!instance) { console.error(`InputHandler: Instance ${instanceId} not found for socket ${socket.id}`); return null; }
        return instance;
    }

    // --- Player Input Events ---
    socket.on('updateStomata', (data) => {
        const instance = getInstanceForSocket(); if (!instance) return;
        const ps = instance.getPlayerState(socket.id);
        if (ps && ps.isAlive && !ps.isSpectator && instance.state.gamePhase === 'playing' && typeof data?.value === 'number') {
             ps.stomatalConductance = Math.max(0, Math.min(1, data.value));
        }
    });
    socket.on('updateAllocation', (data) => {
        const instance = getInstanceForSocket(); if (!instance) return;
        const ps = instance.getPlayerState(socket.id);
        if (ps && ps.isAlive && !ps.isSpectator && instance.state.gamePhase === 'playing' && typeof data?.savings === 'number' && typeof data?.growthRatio === 'number') {
            ps.lastSavingsPercent = Math.max(0, Math.min(100, data.savings));
            ps.lastGrowthRatioPercent = Math.max(0, Math.min(100, data.growthRatio));
        }
    });
     socket.on('requestStartCountdown', () => {
         const instance = getInstanceForSocket(); if (!instance) return;
         console.log(`Conn: Received 'requestStartCountdown' from ${socket.id} for instance ${instance.state.instanceId}`);
         const ps = instance.getPlayerState(socket.id);
         if (instance.state.mode === 'multi' && ps && !ps.isSpectator && instance.state.gamePhase === 'lobby' && instance.state.allowPlayerCountdownStart ) { // Check admin toggle
             instance.startCountdown();
         } else { console.log(`Conn: Ignoring start countdown. Mode:${instance.state.mode}, Phase:${instance.state.gamePhase}, Player:${!!ps}, Spectator:${ps?.isSpectator}, AllowStart: ${instance.state.allowPlayerCountdownStart}`); }
     });
     socket.on('selectSpawnPoint', (coords) => {
         const instance = getInstanceForSocket(); if (!instance) return;
         const ps = instance.getPlayerState(socket.id);
         console.log(`Conn: Received 'selectSpawnPoint' from ${socket.id} for instance ${instance.state.instanceId}:`, coords);
         if (!ps || ps.isSpectator || !coords || typeof coords.x !== 'number' || typeof coords.z !== 'number') { socket.emit('spawnPointInvalid', { reason: 'Invalid data/spectator.' }); return; }
         if (instance.state.gamePhase !== 'lobby') { socket.emit('spawnPointInvalid', { reason: 'Can only select in lobby.' }); return; }
         if (ps.hasChosenSpawn) { socket.emit('spawnPointInvalid', { reason: 'Already chosen.' }); return; }
         const islandRadius = Config.ISLAND_RADIUS || 50; const distSqFromCenter = coords.x**2 + coords.z**2;
         if (distSqFromCenter > islandRadius*islandRadius) { socket.emit('spawnPointInvalid', { reason: 'Outside island.' }); return; }
         let tooClose = false;
         instance.getAllPlayers().forEach((op) => { if (op.id === socket.id) return; if (op.hasChosenSpawn && !op.isSpectator) { const dx = coords.x - op.spawnPoint.x; const dz = coords.z - op.spawnPoint.z; const distSq = dx*dx + dz*dz; if (distSq < MIN_SPAWN_DISTANCE_SQ) { tooClose = true; } } });
         if (tooClose) { socket.emit('spawnPointInvalid', { reason: 'Too close.' }); return; }
         console.log(`Conn: Spawn point for ${socket.id} confirmed.`);
         const baseHeight = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
         ps.spawnPoint = { x: coords.x, y: baseHeight, z: coords.z }; ps.hasChosenSpawn = true;
         socket.emit('spawnPointConfirmed', ps.spawnPoint);
         instance.broadcastState();
     });

     // --- Admin Commands (Target Multiplayer Instance) ---
     function handleAdminCommand(commandName, actionFn) {
         if (!adminSockets.has(socket.id)) { console.warn(`Unauthorized admin command '${commandName}' from ${socket.id}`); return; }
         const multiplayerInstance = gameInstanceManager.multiplayerInstanceId ? gameInstanceManager.getInstance(gameInstanceManager.multiplayerInstanceId) : null;
         if (!multiplayerInstance) { console.log(`ADMIN COMMAND ${commandName}: No active multiplayer instance found.`); socket.emit('serverMessage', { text: 'No active multiplayer game.', type: 'error'}); return; }
         console.log(`ADMIN COMMAND: ${commandName} from ${socket.id} targeting instance ${multiplayerInstance.state.instanceId}`);
         actionFn(multiplayerInstance); // Execute action, passing the target instance
     }

     socket.on('adminForceStart', () => handleAdminCommand('Force Start', (instance) => {
         const phase = instance.state.gamePhase;
         if (phase === 'lobby' || phase === 'countdown') {
             instance._prepareAndStartGame();
             instance.io.to(instance.state.roomId).emit('serverMessage', { text: 'Admin forced game start!', type: 'warning'});
             socket.emit('serverMessage', { text: 'Game force-started.', type: 'success'});
         } else { console.log("ADMIN: Cannot Force Start, invalid phase."); socket.emit('serverMessage', { text: 'Cannot force start now.', type: 'error'}); }
     }));
     socket.on('adminForceEnd', () => handleAdminCommand('Force End', (instance) => {
          const phase = instance.state.gamePhase;
         if (phase === 'playing' || phase === 'countdown') {
             instance.endGame("Game ended by admin.");
             instance.io.to(instance.state.roomId).emit('serverMessage', { text: 'Admin ended the game.', type: 'warning'});
             socket.emit('serverMessage', { text: 'Game force-ended.', type: 'success'});
         } else { console.log("ADMIN: Cannot Force End, invalid phase."); socket.emit('serverMessage', { text: 'Cannot force end now.', type: 'error'}); }
     }));
     socket.on('adminResetCountdown', () => handleAdminCommand('Reset Countdown', (instance) => {
         const phase = instance.state.gamePhase;
         let message = ''; let feedback = '';
         if (phase === 'countdown') { instance.stopCountdown(); instance.startCountdown(); message = 'Admin reset the countdown.'; feedback = 'Countdown reset.'; }
         else if (phase === 'lobby') { instance.startCountdown(); message = 'Admin started the countdown.'; feedback = 'Countdown started.'; }
         else { console.log("ADMIN: Cannot Reset/Start Countdown, invalid phase."); socket.emit('serverMessage', { text: 'Cannot reset/start countdown now.', type: 'error'}); return; }
         if (message) instance.io.to(instance.state.roomId).emit('serverMessage', { text: message, type: 'info'});
         if (feedback) socket.emit('serverMessage', { text: feedback, type: 'success'});
     }));

} // End of setupInputAndActionListeners

--- FILE: client/tree.js ---
// client/tree.js
import * as THREE from 'three';
import * as Config from './config.js';
import { scene } from './sceneSetup.js';
import { gameState } from './gameState.js';

// Shared Materials
let sharedTrunkMaterial = null;
let sharedCanopyMaterial = null;
function ensureSharedMaterials() {
    const leafColor = Config.DEFAULT_LEAF_COLOR;
    const trunkColor = Config.DEFAULT_TRUNK_COLOR;
    if (!sharedTrunkMaterial) sharedTrunkMaterial = new THREE.MeshStandardMaterial({ color: trunkColor, name: 'sharedTrunkMaterial' });
    if (!sharedCanopyMaterial) sharedCanopyMaterial = new THREE.MeshStandardMaterial({ color: leafColor, name: 'sharedCanopyMaterial' });
}

// Helper Functions
function shuffleArray(array) { for (let i=array.length-1; i>0; i--) { const j=Math.floor(Math.random()*(i+1)); [array[i],array[j]]=[array[j],array[i]]; } }
function calculateDimensions(playerData) {
    const currentLA = (playerData.currentLA > 0) ? playerData.currentLA : 0.0001;
    const trunkHeight = (playerData.trunkHeight > 0) ? playerData.trunkHeight : Config.INITIAL_TRUNK_HEIGHT;
    const canopyWidth = Math.sqrt(currentLA);
    const trunkArea = currentLA * (Config.k_TA_LA_RATIO !== undefined ? Config.k_TA_LA_RATIO : 0.01); // Use default if needed
    const trunkWidth = Math.sqrt(trunkArea);
    return { canopyWidth: canopyWidth, canopyDepth: canopyWidth, trunkWidth: Math.max(0.1, trunkWidth), trunkDepth: Math.max(0.1, trunkWidth), trunkHeight: trunkHeight };
}

// --- Tree Creation/Update ---
export function createOrUpdateTree(playerId, playerData) {

    // +++ CRITICAL CHECK: Do not create/update trees for spectators +++
    if (!playerData || playerData.isSpectator) { // Check if playerData exists and if spectator
        if (gameState.playerTrees.has(playerId)) {
             console.log(`TREE: Player ${playerId} is spectator or data invalid, removing existing tree.`);
             removeTree(playerId);
        }
        return; // Stop processing
    }

    // Player is NOT a spectator, proceed
    ensureSharedMaterials();

    let treeMeshGroup = gameState.playerTrees.get(playerId);
    const dimensions = calculateDimensions(playerData);
    const baseHeight = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
    const targetPosition = new THREE.Vector3(playerData.spawnPoint?.x ?? 0, baseHeight, playerData.spawnPoint?.z ?? 0);

    if (!treeMeshGroup) {
        // Create New Tree
        treeMeshGroup = new THREE.Group(); treeMeshGroup.name = `playerTree_${playerId}`;
        const trunkGeometry = new THREE.BoxGeometry(dimensions.trunkWidth, dimensions.trunkHeight, dimensions.trunkDepth);
        const trunkMat = sharedTrunkMaterial.clone(); // Clone for customization
        trunkMat.color.set(playerData.trunkColor || Config.DEFAULT_TRUNK_COLOR); // Set initial color
        const trunkMesh = new THREE.Mesh(trunkGeometry, trunkMat);
        trunkMesh.name = "trunk"; trunkMesh.position.y = (dimensions.trunkHeight / 2); trunkMesh.castShadow = true; trunkMesh.receiveShadow = true; treeMeshGroup.add(trunkMesh);

        const canopyGroup = new THREE.Group(); canopyGroup.name = "canopyGroup"; const tiles = [];
        const gridSize = Config.CANOPY_TILE_GRID_SIZE !== undefined ? Config.CANOPY_TILE_GRID_SIZE : 10; // Use default if needed
        const tileWidth = dimensions.canopyWidth / gridSize; const tileDepth = dimensions.canopyDepth / gridSize; const tileThickness = Config.CANOPY_TILE_THICKNESS !== undefined ? Config.CANOPY_TILE_THICKNESS : 0.1; // Use default if needed
        const tileGeometry = new THREE.BoxGeometry(tileWidth, tileThickness, tileDepth);
        const leafMatBase = sharedCanopyMaterial.clone(); // Clone base material
        leafMatBase.color.set(playerData.leafColor || Config.DEFAULT_LEAF_COLOR); // Set initial color

        for (let i = 0; i < gridSize; i++) { for (let j = 0; j < gridSize; j++) {
            // Assign the same cloned & colored material instance to all tiles initially
            const tileMesh = new THREE.Mesh(tileGeometry, leafMatBase);
            const xPos = (i-(gridSize-1)/2)*tileWidth; const zPos = (j-(gridSize-1)/2)*tileDepth;
            tileMesh.position.set(xPos, 0, zPos); tileMesh.castShadow=true; tileMesh.receiveShadow=true; tileMesh.name = `canopyTile_${i}_${j}`; canopyGroup.add(tileMesh); tiles.push(tileMesh); } }
        shuffleArray(tiles); canopyGroup.userData.tiles = tiles; canopyGroup.userData.creationWidth = dimensions.canopyWidth;
        treeMeshGroup.add(canopyGroup);
        treeMeshGroup.position.copy(targetPosition);
        if (scene) scene.add(treeMeshGroup); else console.error("Scene not found for tree");
        gameState.playerTrees.set(playerId, treeMeshGroup);
    }

    // Update Existing Tree (geometry, scale, visibility, colors)
    if (!treeMeshGroup.position.equals(targetPosition)) { treeMeshGroup.position.copy(targetPosition); }
    updateTreeGeometry(treeMeshGroup, playerData, dimensions);
    updateCanopyTiles(treeMeshGroup, playerData); // Handles damage and color updates
    treeMeshGroup.visible = playerData.isAlive; // Visibility based on alive status only (spectator check above)
}

// --- Update Helpers ---
function updateTreeGeometry(treeMeshGroup, playerData, dimensions) { if (!treeMeshGroup) return; const trunkMesh = treeMeshGroup.getObjectByName("trunk"); const canopyGroup = treeMeshGroup.getObjectByName("canopyGroup"); if (trunkMesh && trunkMesh.geometry) { const params = trunkMesh.geometry.parameters; if (Math.abs(params.width - dimensions.trunkWidth) > 0.01 || Math.abs(params.height - dimensions.trunkHeight) > 0.01 || Math.abs(params.depth - dimensions.trunkDepth) > 0.01) { trunkMesh.geometry.dispose(); trunkMesh.geometry = new THREE.BoxGeometry(dimensions.trunkWidth, dimensions.trunkHeight, dimensions.trunkDepth); } trunkMesh.position.y = dimensions.trunkHeight / 2; } if (canopyGroup) { const tileThickness = Config.CANOPY_TILE_THICKNESS !== undefined ? Config.CANOPY_TILE_THICKNESS : 0.1; canopyGroup.position.y = dimensions.trunkHeight + (tileThickness / 2); const creationWidth = canopyGroup.userData.creationWidth || dimensions.canopyWidth; const currentWidth = dimensions.canopyWidth; const scaleFactor = (creationWidth > 0.01) ? (currentWidth / creationWidth) : 0.01; if (Math.abs(canopyGroup.scale.x - scaleFactor) > 0.001) { canopyGroup.scale.set(scaleFactor, 1, scaleFactor); } } }

function updateCanopyTiles(treeMeshGroup, playerData) {
    if (!treeMeshGroup) return;
    const canopyGroup = treeMeshGroup.getObjectByName("canopyGroup");
    if (!canopyGroup || !canopyGroup.userData.tiles) return;
    const tiles = canopyGroup.userData.tiles; const totalTiles = tiles.length; if (totalTiles === 0) return;

    // Update Tile Visibility (Damage)
    const damagePercent = playerData.damagedLAPercentage || 0;
    const hiddenTilesCount = Math.floor(totalTiles * damagePercent);
    for (let i = 0; i < totalTiles; i++) { tiles[i].visible = (i >= hiddenTilesCount); }

    // Update Tile Color (Uses the material instance shared by tiles in this group)
    const leafColor = playerData.leafColor || Config.DEFAULT_LEAF_COLOR;
    if (tiles[0] && tiles[0].material && tiles[0].material.color) { // Check material of first tile
        if (!tiles[0].material.color.equals(new THREE.Color(leafColor))) {
            tiles[0].material.color.set(leafColor); // Update color on the shared material instance
        }
    }

    // Update Trunk Color
    const trunkMesh = treeMeshGroup.getObjectByName("trunk");
    const trunkColor = playerData.trunkColor || Config.DEFAULT_TRUNK_COLOR;
    if (trunkMesh && trunkMesh.material && trunkMesh.material.color) {
         if (!trunkMesh.material.color.equals(new THREE.Color(trunkColor))) {
            trunkMesh.material.color.set(trunkColor);
         }
    }
}


// --- Removal & Disposal ---
export function removeTree(playerId) { const treeMeshGroup = gameState.playerTrees.get(playerId); if (treeMeshGroup) { disposeTreeGroup(treeMeshGroup); if (scene && treeMeshGroup.parent) scene.remove(treeMeshGroup); gameState.playerTrees.delete(playerId); } }
function disposeTreeGroup(group) { if (!group) return; group.traverse((obj) => { if (obj.isMesh) { if (obj.geometry) obj.geometry.dispose(); if (obj.material) { if (Array.isArray(obj.material)) { obj.material.forEach(material => material.dispose()); } else { obj.material.dispose(); } } } }); }
export function disposeAllTrees() { gameState.playerTrees.forEach(treeGroup => { disposeTreeGroup(treeGroup); if(scene && treeGroup.parent) scene.remove(treeGroup); }); gameState.playerTrees.clear(); disposeSharedTreeMaterials(); console.log("Disposed all player trees and shared materials."); }
export function disposeSharedTreeMaterials() { if (sharedTrunkMaterial) { sharedTrunkMaterial.dispose(); sharedTrunkMaterial = null; } if (sharedCanopyMaterial) { sharedCanopyMaterial.dispose(); sharedCanopyMaterial = null; } }

--- FILE: server/game/GameInstance.js ---
// server/game/GameInstance.js
import { v4 as uuidv4 } from 'uuid';
import * as Config from '../config.js'; // Import the config

// *** Use local constants with defaults if Config properties are missing ***
const TICK_RATE = Config.TICK_RATE !== undefined ? Config.TICK_RATE : 20;
const COUNTDOWN_DURATION = Config.COUNTDOWN_DURATION !== undefined ? Config.COUNTDOWN_DURATION : 5;
const ISLAND_LEVEL = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
const INITIAL_LEAF_AREA = Config.INITIAL_LEAF_AREA !== undefined ? Config.INITIAL_LEAF_AREA : 5;
const BASE_HYDRAULIC = Config.BASE_HYDRAULIC !== undefined ? Config.BASE_HYDRAULIC : 50;
const HYDRAULIC_SCALE_PER_LA = Config.HYDRAULIC_SCALE_PER_LA !== undefined ? Config.HYDRAULIC_SCALE_PER_LA : 10;
const INITIAL_CARBON = Config.INITIAL_CARBON !== undefined ? Config.INITIAL_CARBON : 100;
const INITIAL_HYDRAULICS = Config.INITIAL_HYDRAULICS !== undefined ? Config.INITIAL_HYDRAULICS : 100;
const INITIAL_TRUNK_HEIGHT = Config.INITIAL_TRUNK_HEIGHT !== undefined ? Config.INITIAL_TRUNK_HEIGHT : 2;
const k_TA_LA_RATIO = Config.k_TA_LA_RATIO !== undefined ? Config.k_TA_LA_RATIO : 0.01;
const MAX_CARBON = Config.MAX_CARBON !== undefined ? Config.MAX_CARBON : 200;
const PHOTOSYNTHESIS_RATE_PER_LA = Config.PHOTOSYNTHESIS_RATE_PER_LA !== undefined ? Config.PHOTOSYNTHESIS_RATE_PER_LA : 0.5;
const RESPIRATION_RATE_PER_LA = Config.RESPIRATION_RATE_PER_LA !== undefined ? Config.RESPIRATION_RATE_PER_LA : 0.02;
const RESPIRATION_RATE_PER_TRUNK_VOL = Config.RESPIRATION_RATE_PER_TRUNK_VOL !== undefined ? Config.RESPIRATION_RATE_PER_TRUNK_VOL : 0.01;
const TRANSPIRATION_RATE_PER_LA = Config.TRANSPIRATION_RATE_PER_LA !== undefined ? Config.TRANSPIRATION_RATE_PER_LA : 0.4;
const HYDRAULIC_RECOVERY_RATE = Config.HYDRAULIC_RECOVERY_RATE !== undefined ? Config.HYDRAULIC_RECOVERY_RATE : 2;
const RAIN_RECOVERY_BONUS_MULT = Config.RAIN_RECOVERY_BONUS_MULT !== undefined ? Config.RAIN_RECOVERY_BONUS_MULT : 3.0;
const HYDRAULIC_DAMAGE_THRESHOLD = Config.HYDRAULIC_DAMAGE_THRESHOLD !== undefined ? Config.HYDRAULIC_DAMAGE_THRESHOLD : 20;
const CROWN_DIEBACK_RATE = Config.CROWN_DIEBACK_RATE !== undefined ? Config.CROWN_DIEBACK_RATE : 0.05;
const NIGHT_RAIN_HYDRAULIC_BOOST = Config.NIGHT_RAIN_HYDRAULIC_BOOST !== undefined ? Config.NIGHT_RAIN_HYDRAULIC_BOOST : 20.0;
const GROWTH_OFFSET_NIGHT = Config.GROWTH_OFFSET_NIGHT !== undefined ? Config.GROWTH_OFFSET_NIGHT : 1.5;
const SEED_COST = Config.SEED_COST !== undefined ? Config.SEED_COST : 1;
const GROWTH_COST_PER_LA = Config.GROWTH_COST_PER_LA !== undefined ? Config.GROWTH_COST_PER_LA : 5;
const TOTAL_CYCLE_DURATION = Config.TOTAL_CYCLE_DURATION !== undefined ? Config.TOTAL_CYCLE_DURATION : 24.0; // Example default
const DAY_TOTAL_DURATION = Config.DAY_TOTAL_DURATION !== undefined ? Config.DAY_TOTAL_DURATION : 21.0; // Example default
const PERIOD_DURATION = Config.PERIOD_DURATION !== undefined ? Config.PERIOD_DURATION : 7.0; // Example default
const SUNNY_PROB = Config.SUNNY_PROB !== undefined ? Config.SUNNY_PROB : 2.0/3.0;
const RAIN_PROB_IF_CLOUDY = Config.RAIN_PROB_IF_CLOUDY !== undefined ? Config.RAIN_PROB_IF_CLOUDY : 0.5;
const LIGHT_MULT_SUNNY = Config.LIGHT_MULT_SUNNY !== undefined ? Config.LIGHT_MULT_SUNNY : 1.0;
const LIGHT_MULT_CLOUDY = Config.LIGHT_MULT_CLOUDY !== undefined ? Config.LIGHT_MULT_CLOUDY : 0.4;
const DROUGHT_MULT_BASE = Config.DROUGHT_MULT_BASE !== undefined ? Config.DROUGHT_MULT_BASE : 1.0;
const DROUGHT_VARIATION = Config.DROUGHT_VARIATION !== undefined ? Config.DROUGHT_VARIATION : 0.4;


// Function to create initial state for a player within an instance
function createInitialPlayerState(socketId) {
    const initialLA = INITIAL_LEAF_AREA; const baseHeight = ISLAND_LEVEL; const maxHydraulic = BASE_HYDRAULIC + HYDRAULIC_SCALE_PER_LA * initialLA;
    // Initialize with default colors, they will be overwritten by settings if provided
    return {
        id: socketId,
        playerName: `Player_${socketId.substring(0, 4)}`,
        leafColor: '#228B22', // Default Green
        trunkColor: '#8B4513', // Default Brown
        spawnPoint: { x: 0, y: baseHeight, z: 0 },
        isAlive: false, hasChosenSpawn: false, isSpectator: false, isAI: false,
        carbonStorage: INITIAL_CARBON,
        hydraulicSafety: Math.min(INITIAL_HYDRAULICS, maxHydraulic),
        maxHydraulic: maxHydraulic,
        currentLA: initialLA, effectiveLA: initialLA,
        trunkHeight: INITIAL_TRUNK_HEIGHT,
        trunkWidth: Math.sqrt(initialLA * k_TA_LA_RATIO), trunkDepth: Math.sqrt(initialLA * k_TA_LA_RATIO),
        seedCount: 0, damagedLAPercentage: 0,
        stomatalConductance: 0.5, lastSavingsPercent: 50, lastGrowthRatioPercent: 50,
        foliarUptakeAppliedThisNight: false, growthAppliedThisCycle: false,
    };
}

// Initial state structure for the instance
function createInitialInstanceState() {
   return {
       instanceId: uuidv4(), roomId: null, mode: 'none',
       simulationIntervalId: null, countdownIntervalId: null, lastTickTime: Date.now(),
       day: 1, timeInCycle: 0.0, currentPeriodIndex: -1, isNight: false,
       currentLightMultiplier: LIGHT_MULT_SUNNY, currentDroughtFactor: DROUGHT_MULT_BASE,
       isRaining: false, gamePhase: 'lobby', countdownTimer: null,
       allowPlayerCountdownStart: true, players: new Map(),
       _previousPeriodIndexForWeather: -2,
    };
}


export class GameInstance {
   constructor(mode = 'multi', io) {
       this.state = createInitialInstanceState();
       this.state.mode = mode;
       this.state.roomId = this.state.instanceId;
       this.io = io;
       console.log(`GameInstance created: ID=${this.state.instanceId}, Mode=${this.state.mode}, Room=${this.state.roomId}`);
   }

   // --- Player Management ---
   addPlayer(socket) { if (!socket || this.state.players.has(socket.id)) { return null; } const playerState = createInitialPlayerState(socket.id); this.state.players.set(socket.id, playerState); socket.join(this.state.roomId); return playerState; }
   removePlayer(socketId) { if (this.state.players.has(socketId)) { this.state.players.delete(socketId); return true; } return false; }
   getPlayerState(socketId) { return this.state.players.get(socketId) || null; }
   getAllPlayers() { return this.state.players; }
   getNonSpectatorPlayers() { return Array.from(this.state.players.values()).filter(p => !p.isSpectator && !p.playerName.startsWith('ADMIN_')); }

   // --- State Access/Modification ---
   getSnapshot() {
       const playersSnapshot = {};
       this.state.players.forEach((playerData, playerId) => {
           // --->>> INCLUDE NAME AND COLORS <<<---
           playersSnapshot[playerId] = {
               id: playerData.id,
               playerName: playerData.playerName,   // Include Name
               isAlive: playerData.isAlive,
               hasChosenSpawn: playerData.hasChosenSpawn,
               isSpectator: playerData.isSpectator,
               carbonStorage: playerData.carbonStorage,
               hydraulicSafety: playerData.hydraulicSafety,
               maxHydraulic: playerData.maxHydraulic,
               currentLA: playerData.currentLA,
               trunkHeight: playerData.trunkHeight,
               damagedLAPercentage: playerData.damagedLAPercentage,
               seedCount: playerData.seedCount,
               spawnPoint: playerData.spawnPoint,
               leafColor: playerData.leafColor,     // Include Leaf Color
               trunkColor: playerData.trunkColor    // Include Trunk Color
            };
       });
       return {
           instanceId: this.state.instanceId,
           mode: this.state.mode,
           day: this.state.day,
           timeInCycle: this.state.timeInCycle,
           currentPeriodIndex: this.state.currentPeriodIndex,
           isNight: this.state.isNight,
           currentLightMultiplier: this.state.currentLightMultiplier,
           currentDroughtFactor: this.state.currentDroughtFactor,
           isRaining: this.state.isRaining,
           gamePhase: this.state.gamePhase,
           countdownTimer: this.state.countdownTimer,
           allowPlayerCountdownStart: this.state.allowPlayerCountdownStart,
           players: playersSnapshot, // Send the snapshot with colors/name
           serverTime: Date.now()
        };
   }
   setGamePhase(phase) { if (['lobby', 'countdown', 'playing', 'ended'].includes(phase)) { if (this.state.gamePhase !== phase) { console.log(`GameInstance ${this.state.instanceId}: Changing phase from ${this.state.gamePhase} to ${phase}`); this.state.gamePhase = phase; if (phase !== 'countdown') this.state.countdownTimer = null; if (phase !== 'countdown' && this.state.countdownIntervalId) { this.stopCountdown(); } } } else { console.error(`GameInstance ${this.state.instanceId}: Invalid phase: ${phase}`); } }
   updateStateProperty(key, value) { if (key in this.state) { this.state[key] = value; } else { console.warn(`GameInstance ${this.state.instanceId}: Tried to update unknown property ${key}`); } }

   // --- Simulation Loop Control ---
   startSimulationLoop() { if (this.state.simulationIntervalId) { return; } console.log(`GameInstance ${this.state.instanceId}: Starting simulation loop.`); this.state.lastTickTime = Date.now(); this.state.simulationIntervalId = setInterval(() => this.runTick(), 1000 / TICK_RATE); }
   stopSimulationLoop() { if (this.state.simulationIntervalId) { console.log(`GameInstance ${this.state.instanceId}: Stopping simulation loop.`); clearInterval(this.state.simulationIntervalId); this.state.simulationIntervalId = null; } }

   // --- Core Game Logic ---
   runTick() {
       const now = Date.now();
       const deltaTime = Math.min((now - this.state.lastTickTime) / 1000.0, 1.0 / TICK_RATE * 5);
       this.state.lastTickTime = now;

       if (this.state.gamePhase !== 'playing') { return; }

       this.updateTimeAndWeather();

       let playersAliveThisTick = 0;
       this.state.players.forEach(playerState => {
           if (!playerState.isAlive || playerState.isSpectator || playerState.playerName.startsWith('ADMIN_')) return;
           this._updatePlayerPhysiology(playerState, deltaTime);
           if ((playerState.carbonStorage <= 0 || playerState.hydraulicSafety <= 0)) {
                playerState.isAlive = false;
           } else {
               playersAliveThisTick++;
           }
       });

       const activePlayersCount = this.getNonSpectatorPlayers().length;
       if (playersAliveThisTick === 0 && activePlayersCount > 0 && this.state.gamePhase === 'playing') {
            console.log(`Instance ${this.state.instanceId} Tick: All active players dead condition met. Ending game.`);
            this.endGame("All trees have perished!");
            return;
       }

       this.broadcastState();
   }

   updateTimeAndWeather() {
       let enteringNewDay = false;
       if (this.state.timeInCycle >= TOTAL_CYCLE_DURATION) {
           enteringNewDay = true;
           this.state.day++;
           this.state.timeInCycle -= TOTAL_CYCLE_DURATION;
           this.state.currentPeriodIndex = 0;
           this.state.isNight = false;
           this.state.players.forEach(p => { p.growthAppliedThisCycle = false; });
            this.state._previousPeriodIndexForWeather = -1;
            // console.log(`--- Instance ${this.state.instanceId}: NEW DAY ${this.state.day} Started ---`);
       }

       let calculatedPeriodIndex;
       if (this.state.timeInCycle < DAY_TOTAL_DURATION) {
           calculatedPeriodIndex = Math.floor(this.state.timeInCycle / PERIOD_DURATION);
           this.state.isNight = false;
       } else {
           calculatedPeriodIndex = -1; // Night
           this.state.isNight = true;
       }

       const periodChanged = calculatedPeriodIndex !== this.state._previousPeriodIndexForWeather;

       if (periodChanged) {
           const oldPeriodIndex = this.state._previousPeriodIndexForWeather;
           this.state._previousPeriodIndexForWeather = calculatedPeriodIndex;

           if (!this.state.isNight) {
               const isCloudy = this._generatePeriodWeather();
                this.state.isRaining = isCloudy && (Math.random() < RAIN_PROB_IF_CLOUDY);
                // console.log(`Instance ${this.state.instanceId}: Day ${this.state.day}, Period ${calculatedPeriodIndex+1} Weather - Cloudy: ${isCloudy}, Raining: ${this.state.isRaining}, Light: ${this.state.currentLightMultiplier.toFixed(2)}, Drought: ${this.state.currentDroughtFactor.toFixed(2)}`);
           } else {
                if (oldPeriodIndex !== -1) {
                   this._generateNightWeather();
                   this.state.players.forEach(p => { p.foliarUptakeAppliedThisNight = false; });
                   // console.log(`Instance ${this.state.instanceId}: Entering Night Weather - Raining: ${this.state.isRaining}`);
                }
           }
           this.state.currentPeriodIndex = calculatedPeriodIndex;
       }
   }

   // --- Physiology, Weather Gen, Allocation (Internal Helpers) ---
   _updatePlayerPhysiology(playerState, deltaTime) {
       const stomata = playerState.stomatalConductance; const effLA = Math.max(0, playerState.effectiveLA); const currentLA = Math.max(0, playerState.currentLA); const trunkVolume = Math.max(0, playerState.trunkWidth * playerState.trunkDepth * playerState.trunkHeight); let potentialCarbonGain = 0; if (!this.state.isNight) { potentialCarbonGain = PHOTOSYNTHESIS_RATE_PER_LA * effLA * stomata * this.state.currentLightMultiplier; } const respirationLoss = (RESPIRATION_RATE_PER_LA * currentLA + RESPIRATION_RATE_PER_TRUNK_VOL * trunkVolume); const waterLoss = TRANSPIRATION_RATE_PER_LA * effLA * stomata * this.state.currentDroughtFactor; let currentRecoveryRate = HYDRAULIC_RECOVERY_RATE; if (this.state.isRaining) { currentRecoveryRate *= RAIN_RECOVERY_BONUS_MULT; } const hydraulicChange = (currentRecoveryRate * (1 - stomata)) - waterLoss; playerState.hydraulicSafety += hydraulicChange * deltaTime; const potentialGainThisStep = potentialCarbonGain * deltaTime; const respirationLossThisStep = respirationLoss * deltaTime; const currentStorage = playerState.carbonStorage; const maxPossibleGain = Math.max(0, MAX_CARBON - currentStorage); const actualGain = Math.min(potentialGainThisStep, maxPossibleGain); playerState.carbonStorage = currentStorage + actualGain - respirationLossThisStep; playerState.carbonStorage = Math.max(0, playerState.carbonStorage); playerState.hydraulicSafety = Math.max(0, Math.min(playerState.maxHydraulic, playerState.hydraulicSafety)); if (playerState.hydraulicSafety < HYDRAULIC_DAMAGE_THRESHOLD) { const damageIncrease = CROWN_DIEBACK_RATE * deltaTime; playerState.damagedLAPercentage = Math.min(1, playerState.damagedLAPercentage + damageIncrease); playerState.effectiveLA = playerState.currentLA * (1 - playerState.damagedLAPercentage); } if (this.state.isNight) { if (this.state.isRaining && !playerState.foliarUptakeAppliedThisNight) { const boostAmount = NIGHT_RAIN_HYDRAULIC_BOOST; playerState.hydraulicSafety = Math.min(playerState.hydraulicSafety + boostAmount, playerState.maxHydraulic); playerState.foliarUptakeAppliedThisNight = true; } const timeIntoNight = this.state.timeInCycle - DAY_TOTAL_DURATION; if (timeIntoNight >= GROWTH_OFFSET_NIGHT && !playerState.growthAppliedThisCycle) { this._applyAllocation(playerState); playerState.growthAppliedThisCycle = true; } }
    }
   _generatePeriodWeather() { const isSunny = Math.random() < SUNNY_PROB; const isCloudy = !isSunny; this.state.currentLightMultiplier = isCloudy ? LIGHT_MULT_CLOUDY : LIGHT_MULT_SUNNY; const droughtVariation = (Math.random() * 2 - 1) * DROUGHT_VARIATION; this.state.currentDroughtFactor = Math.max(0.1, DROUGHT_MULT_BASE + droughtVariation); return isCloudy; }
   _generateNightWeather() { const isConceptuallyCloudy = Math.random() >= SUNNY_PROB; this.state.isRaining = isConceptuallyCloudy && (Math.random() < RAIN_PROB_IF_CLOUDY); this.state.currentLightMultiplier = 0; this.state.currentDroughtFactor = DROUGHT_MULT_BASE; }
   _applyAllocation(playerState) {
       const available = Math.floor(playerState.carbonStorage); if (available <= 0) return; const savingsPercent = Math.max(0, Math.min(100, playerState.lastSavingsPercent)); const growthRatioPercent = Math.max(0, Math.min(100, playerState.lastGrowthRatioPercent)); const carbonToSpend = Math.floor(available * (1 - savingsPercent / 100)); if (carbonToSpend <= 0) return; const actualCarbonForGrowth = Math.floor(carbonToSpend * (growthRatioPercent / 100)); const carbonForSeeds = carbonToSpend - actualCarbonForGrowth; const seedsToMake = Math.floor(carbonForSeeds / SEED_COST); const actualCarbonForSeeds = seedsToMake * Config.SEED_COST; const totalSpent = actualCarbonForGrowth + actualCarbonForSeeds; if (totalSpent > available + 0.01 || totalSpent < 0) { return; } playerState.carbonStorage -= totalSpent; playerState.seedCount += seedsToMake; if (actualCarbonForGrowth > 0) { const currentTrunkVolume = (playerState.trunkWidth || 0.1) * (playerState.trunkDepth || 0.1) * (playerState.trunkHeight || 0.1); const currentBiomassEstimate = Math.max(1, playerState.currentLA + currentTrunkVolume); const biomassToAdd = actualCarbonForGrowth / GROWTH_COST_PER_LA; const growthFactor = 1 + (biomassToAdd / currentBiomassEstimate); playerState.currentLA *= growthFactor; playerState.trunkHeight *= growthFactor; playerState.trunkWidth = Math.sqrt(playerState.currentLA * k_TA_LA_RATIO); playerState.trunkDepth = playerState.trunkWidth; playerState.maxHydraulic = BASE_HYDRAULIC + HYDRAULIC_SCALE_PER_LA * playerState.currentLA; playerState.effectiveLA = playerState.currentLA * (1 - playerState.damagedLAPercentage); }
    }

   // --- Countdown Logic ---
   startCountdown() { if (this.state.gamePhase !== 'lobby' || this.state.countdownIntervalId) { return; } if (this.state.mode !== 'multi') { return; } const activePlayerCount = this.getNonSpectatorPlayers().length; if (activePlayerCount === 0) { return; } console.log(`GameInstance ${this.state.instanceId}: Starting ${COUNTDOWN_DURATION}s countdown...`); this.setGamePhase('countdown'); this.state.countdownTimer = COUNTDOWN_DURATION; this.broadcastState(); this.state.countdownIntervalId = setInterval(() => { if (this.state.gamePhase !== 'countdown' || this.state.countdownTimer === null) { this.stopCountdown(); return; } const currentActivePlayers = this.getNonSpectatorPlayers().length; if (currentActivePlayers === 0) { this.stopCountdown(); this.setGamePhase('lobby'); this.broadcastState(); return; } const newTime = this.state.countdownTimer - 1; this.state.countdownTimer = newTime; this.broadcastState(); if (newTime <= 0) { this.stopCountdown(); this._prepareAndStartGame(); } }, 1000); }
   stopCountdown() { if (this.state.countdownIntervalId) { clearInterval(this.state.countdownIntervalId); this.state.countdownIntervalId = null; } }

   // --- Start Game Helper ---
   _prepareAndStartGame() {
       this.stopCountdown();
       if (this.state.gamePhase === 'playing') { return; }
       console.log(`GameInstance ${this.state.instanceId}: Preparing players and starting game...`);
       this.setGamePhase('playing');
       let playersMarkedAliveCount = 0;
       this.state.players.forEach(playerState => {
           // console.log(`_prepareAndStartGame: Checking player ${playerState.id}, isSpectator=${playerState.isSpectator}, isAI=${playerState.isAI}, Name=${playerState.playerName}`);
           if (playerState.isSpectator || playerState.isAI || playerState.playerName.startsWith('ADMIN_')) {
               playerState.isAlive = false;
               // console.log(`_prepareAndStartGame: Skipping spectator/AI/Admin ${playerState.id}, ensuring isAlive=false.`);
               return;
           }
           if (!playerState.hasChosenSpawn) {
                console.log(`_prepareAndStartGame: Assigning default spawn for ${playerState.id}`);
                this._assignDefaultSpawn(playerState);
           } else if (!playerState.spawnPoint || typeof playerState.spawnPoint.x !== 'number') {
                console.log(`_prepareAndStartGame: Player ${playerState.id} had chosen spawn but point invalid, assigning default.`);
                this._assignDefaultSpawn(playerState);
           }
           if (!playerState.isAlive) {
                playerState.isAlive = true;
                // console.log(`_prepareAndStartGame: Setting player ${playerState.id} to isAlive=true.`);
                playersMarkedAliveCount++;
           } else {
                playersMarkedAliveCount++;
                // console.log(`_prepareAndStartGame: Player ${playerState.id} was already alive.`);
           }
           playerState.growthAppliedThisCycle = false;
           playerState.foliarUptakeAppliedThisNight = false;
       });
       if (playersMarkedAliveCount === 0 && this.state.players.size > 0) {
           console.log(`_prepareAndStartGame: No active players found after checks, resetting to lobby.`);
           this.resetGame();
           this.broadcastState();
           return;
       }
       console.log(`GameInstance ${this.state.instanceId}: Marked ${playersMarkedAliveCount} players alive.`);
       this.broadcastState();
       this.startSimulationLoop();
   }
   _assignDefaultSpawn(playerState) { const nonSpectatorPlayers = this.getNonSpectatorPlayers(); const index = nonSpectatorPlayers.findIndex(ap => ap.id === playerState.id); const activePlayerCount = nonSpectatorPlayers.length || 1; const angle = (index / activePlayerCount) * Math.PI * 2 + Math.random()*0.1; const radius = 5 + Math.random() * 5; const baseHeight = ISLAND_LEVEL; playerState.spawnPoint = { x: radius * Math.cos(angle), y: baseHeight, z: radius * Math.sin(angle) }; playerState.hasChosenSpawn = true; }

   // --- Reset & End Game ---
   resetGame() { console.log(`GameInstance ${this.state.instanceId}: Resetting game...`); this.stopSimulationLoop(); this.stopCountdown(); Object.assign(this.state, { day: 1, timeInCycle: 0.0, currentPeriodIndex: -1, isNight: false, currentLightMultiplier: LIGHT_MULT_SUNNY, currentDroughtFactor: DROUGHT_MULT_BASE, isRaining: false, gamePhase: 'lobby', countdownTimer: null, allowPlayerCountdownStart: true }); this.state.players.forEach(p => { const initialLA = INITIAL_LEAF_AREA; const maxHydraulic = BASE_HYDRAULIC + HYDRAULIC_SCALE_PER_LA * initialLA; p.isAlive = false; p.hasChosenSpawn = false; p.spawnPoint = { x: 0, y: ISLAND_LEVEL, z: 0 }; p.carbonStorage = INITIAL_CARBON; p.hydraulicSafety = Math.min(INITIAL_HYDRAULICS, maxHydraulic); p.maxHydraulic = maxHydraulic; p.currentLA = initialLA; p.effectiveLA = initialLA; p.trunkHeight = INITIAL_TRUNK_HEIGHT; p.trunkWidth = Math.sqrt(initialLA * k_TA_LA_RATIO); p.trunkDepth = p.trunkWidth; p.seedCount = 0; p.damagedLAPercentage = 0; p.stomatalConductance = 0.5; p.lastSavingsPercent = 50; p.lastGrowthRatioPercent = 50; p.foliarUptakeAppliedThisNight = false; p.growthAppliedThisCycle = false; }); console.log(`GameInstance ${this.state.instanceId}: Reset complete. Phase: ${this.state.gamePhase}`); }
   endGame(reason = "Game ended.") { console.log(`GameInstance ${this.state.instanceId}: endGame called. Reason: ${reason}`); this.stopSimulationLoop(); this.stopCountdown(); this.setGamePhase('ended'); let winnerId = null; let maxSeeds = -1; this.state.players.forEach(p => { if (!p.isSpectator && !p.playerName.startsWith('ADMIN_') && p.seedCount > maxSeeds) { maxSeeds = p.seedCount; winnerId = p.id; } }); console.log(`GameInstance ${this.state.instanceId}: Winner: ${winnerId || 'None'} with ${maxSeeds} seeds.`); this.io.to(this.state.roomId).emit('gameOver', { reason: reason, winnerId: winnerId }); this.broadcastState(); setTimeout(() => { this.resetGame(); this.broadcastState(); }, 2000); }

   // --- Broadcasting ---
   broadcastState() { const snapshot = this.getSnapshot(); this.io.to(this.state.roomId).emit('gameStateUpdate', snapshot); }

   // --- Utility ---
   findSocket(socketId) { const socket = this.io.sockets.sockets.get(socketId); return socket; }
}


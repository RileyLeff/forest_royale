---
DIRECTORY STRUCTURE
---
- .gitignore
- README.md
- client/
  - admin.html
  - admin.js
  - config.js
  - environment.js
  - game.html
  - gameState.js
  - index.html
  - index.js
  - main.js
  - sceneSetup.js
  - settings.html
  - settings.js
  - style.css
  - tree.js
  - ui/
    - controlsHandlers.js
    - elements.js
    - gameOver.js
    - leaderboard.js
    - messageHandler.js
    - setupListeners.js
    - update.js
    - updateAdmin.js
- server/
  - config.js
  - game/
    - GameState.js
    - gameLogic.js
    - simulation.js
  - network/
    - connection.js
    - stateBroadcaster.js
  - package.json
  - server.js

---
FILE CONTENTS
---

--- FILE: client/ui/setupListeners.js ---
// client/ui/setupListeners.js
import { uiElements } from './elements.js';
import { handleStomataChange, handleAllocationSliderChange } from './controlsHandlers.js';
import { handleRestart, socket } from '../main.js'; // Import socket

/**
 * Attaches event listeners to the interactive UI elements.
 */
export function setupUIListeners() {
    console.log("UI: Setting up listeners...");

    // Check required elements using optional chaining for safety
    // Ensure all elements used below are checked here
    if (!uiElements.stomataSlider ||
        !uiElements.savingsSlider ||
        !uiElements.growthRatioSlider ||
        !uiElements.restartButton ||
        !uiElements.startCountdownButton) // Added check
    {
        console.error("Cannot set up UI listeners - one or more essential controls missing!");
        if (!uiElements.stomataSlider) console.error("- Stomata slider missing");
        if (!uiElements.savingsSlider) console.error("- Savings slider missing");
        if (!uiElements.growthRatioSlider) console.error("- Growth ratio slider missing");
        if (!uiElements.restartButton) console.error("- Restart button missing");
        if (!uiElements.startCountdownButton) console.error("- Start Countdown button missing");
        return;
    }


    // Control Sliders
    uiElements.stomataSlider.addEventListener('input', handleStomataChange);
    uiElements.savingsSlider.addEventListener('input', handleAllocationSliderChange);
    uiElements.growthRatioSlider.addEventListener('input', handleAllocationSliderChange);

    // Restart Button
    uiElements.restartButton.addEventListener('click', handleRestart);

    // Start Countdown Button
    uiElements.startCountdownButton.addEventListener('click', () => {
        console.log("UI: Start Countdown button clicked."); // <<< Log 1
        if (socket && socket.connected) {
             // +++ Add more detailed log before emitting +++
             console.log(`UI: Emitting 'requestStartCountdown' via socket ${socket.id}. Connected: ${socket.connected}`); // <<< Log 2
             socket.emit('requestStartCountdown'); // Send event to server
        } else {
            // +++ Log the socket object for inspection +++
            console.error("UI: Cannot start countdown, socket invalid or not connected.", { socket_exists: !!socket, connected: socket?.connected }); // <<< Log 3 (with more info)
            // Maybe show an error message to the user
            alert("Error: Not connected to server. Cannot start countdown.");
        }
    });

    console.log("UI: Listeners set up.");
}

--- FILE: client/gameState.js ---
// client/gameState.js
import * as Config from './config.js';

export const gameState = {
    // --- Server Synced State ---
    day: 1, timeInCycle: 0.0, currentPeriodIndex: -1, isNight: false,
    currentLightMultiplier: 1.0, currentDroughtFactor: Config.DROUGHT_MULT_BASE,
    isRaining: false, gamePhase: 'loading', players: {}, serverTime: Date.now(),
    countdownTimer: null,

    // --- Client-Specific State ---
    myId: null,
    isSpectator: false, // <<< Ensure this exists, defaults to false
    gameOver: false, gameOverReason: '', winnerId: null,
    playerTrees: new Map(),
    initialStateReceived: false,
};

export function loadClientSettings() {
    console.log("Client settings loaded (placeholder).");
}
loadClientSettings();

export function getMyPlayerState() {
    if (!gameState.myId || !gameState.players[gameState.myId]) return null;
    return gameState.players[gameState.myId];
}

--- FILE: client/ui/elements.js ---
// client/ui/elements.js
export let uiElements = {};
export function cacheDOMElements() {
    console.log("UI: Caching DOM elements...");
    uiElements = {
        gameContainer: document.getElementById('game-container'),
        canvas: document.getElementById('game-canvas'),

        // Top Left Elements
        dayCounterUI: document.getElementById('day-counter'),
        timeOfDayUI: document.getElementById('time-of-day'),
        weatherStatusUI: document.getElementById('weather-status'),
        cycleTimerUI: document.getElementById('cycle-timer'),
        messageLogUI: document.getElementById('message-log'),
        // Lobby Elements
        lobbyInfoPanel: document.getElementById('lobby-info'), // Container
        lobbyPlayerCountUI: document.getElementById('lobby-player-count'),
        countdownTimerDisplayUI: document.getElementById('countdown-timer-display'),
        startCountdownButton: document.getElementById('start-countdown-button'),


        // Top Right Elements
        leaderboardTitleUI: document.getElementById('leaderboard-title'), // Title element
        leaderboardListUI: document.getElementById('leaderboard-list'),
        // treeCountUI: document.getElementById('tree-count'), // Removed, integrated into title

        // Bottom Left Elements
        bottomLeftStatus: document.getElementById('bottom-left-status'), // <<< ID for the whole panel
        carbonBar: document.getElementById('carbon-bar'),
        hydraulicBar: document.getElementById('hydraulic-bar'),
        carbonValueUI: document.getElementById('carbon-value'),
        hydraulicValueUI: document.getElementById('hydraulic-value'),
        seedCounterUI: document.getElementById('seed-counter'),

        // Bottom Right Controls
        controlPanelRight: document.getElementById('control-panel-right'), // Container
        stomataSlider: document.getElementById('stomata-slider'),
        stomataValueUI: document.getElementById('stomata-value'),
        savingsSlider: document.getElementById('savings-slider'),
        savingsPercentageUI: document.getElementById('savings-percentage'),
        growthRatioSlider: document.getElementById('growth-ratio-slider'),
        growthRatioPercentageUI: document.getElementById('growth-ratio-percentage'),

        // Game Over Elements
        gameOverModal: document.getElementById('game-over-modal'),
        gameOverReasonUI: document.getElementById('game-over-reason'),
        finalDayUI: document.getElementById('final-day'),
        finalSeedsUI: document.getElementById('final-seeds'),
        restartButton: document.getElementById('restart-button'),
    };

     // Verification log
     let foundCount = 0; let missing = []; for (const key in uiElements) { if (uiElements[key]) { foundCount++; } else { if (document.getElementById('game-canvas')) { console.warn(`UI element not found: ${key}`); missing.push(key); } } } if (document.getElementById('game-canvas')) { console.log(`UI: Cached ${foundCount} game DOM elements. Missing: ${missing.length > 0 ? missing.join(', ') : 'None'}`); } else { console.log(`UI: Cached ${foundCount} DOM elements (non-game page).`); }
}

--- FILE: client/ui/leaderboard.js ---


--- FILE: README.md ---
# FOREST ROYALE: A Plant Ecophysiology Game

## 1. Overview

**Forest Royale** (formerly Island Canopy Sim) is an interactive web-based simulation game designed to teach fundamental concepts of plant ecophysiology, specifically focusing on tree "decision-making" under environmental constraints. Developed as part of PhD research in plant ecophysiology, this project uses trees as a model system for studying resource allocation and survival strategies in sessile organisms facing dynamic environmental conditions.

The primary goal is to create an engaging, accessible (playable on web/mobile), and scientifically grounded experience. The game aims to translate complex physiological processes and trade-offs into intuitive game mechanics.

We approach trees not just as passive responders, but as agents making strategic "decisions" (e.g., stomatal aperture, carbon allocation) to maximize lifetime fitness (represented by reproductive output) within the bounds of physical and chemical laws governing water transport and photosynthesis, under a changing environment. The game now includes a client-server architecture to support multiplayer gameplay.

## 2. Core Concept

Players control an individual tree on a simulated island, competing against others (in multiplayer) or playing solo. The objective is to survive environmental challenges (dynamic light, drought, rain) and maximize lifetime seed production. This requires balancing competing demands:

*   **Growth:** Investing carbon into increasing height and leaf area can improve light capture but increases water demand and respiration costs.
*   **Reproduction:** Allocating carbon to seeds directly contributes to the player's score but detracts from growth and reserves.
*   **Survival (Savings & Safety):** Maintaining sufficient carbon reserves and hydraulic safety is essential to survive periods of stress (e.g., drought, low light, cloudy periods) and nightly respiration costs.

Players make real-time decisions (stomatal aperture) and periodic strategic decisions (carbon allocation) to navigate these trade-offs in response to fluctuating weather conditions, broadcast uniformly from a central server.

## 3. Scientific Principles Demonstrated

This simulation aims to illustrate key concepts in plant ecophysiology:

*   **Resource Allocation Trade-offs:** The fundamental conflict between allocating limited resources (carbon) towards growth, reproduction, storage (savings), and defense (implicit via survival).
*   **Photosynthesis-Transpiration Compromise:** The need to open stomata for CO2 uptake (photosynthesis) inevitably leads to water loss (transpiration), requiring players to manage stomatal aperture based on water availability (hydraulic safety) and carbon demand, influenced by current weather.
*   **Hydraulic Limits & Dynamics:** Demonstrating that exceeding the water transport capacity (represented by low `hydraulicSafety`) leads to physiological damage (canopy dieback) and potentially death. Hydraulic safety is dynamic, influenced by transpiration (affected by drought factor) and recovery (boosted by rain, potential night uptake). The maximum hydraulic buffer scales with tree size.
*   **Carbon Balance:** The dynamic interplay between carbon gain (photosynthesis, affected by light levels) and carbon loss (respiration, growth, reproduction), requiring players to manage reserves (capped at `MAX_CARBON`) to avoid starvation.
*   **Environmental Response:** How changing conditions (light intensity, drought factor, rain) broadcast by the server affect physiological processes and strategic decisions for all players simultaneously.
*   **Within-Generation Plasticity:** How a tree's "strategy" (control inputs) can change over its lifetime based on its state and environment.
*   **(Future) Competition:** How interactions with neighbors (e.g., shading) influence resource capture and survival.

## 4. Current Features & Architecture (As of this README update)

*   **Client-Server Architecture:**
    *   **Node.js Backend:** Uses Express for basic routing and Socket.IO for real-time WebSocket communication.
    *   **Authoritative Server:** The server manages the core game state (all players' resources, positions, time, weather), runs the simulation loop, and broadcasts state updates to all clients.
    *   **Client-Side Rendering:** The client receives state updates and renders the 3D scene (Three.js), updates UI, and sends user input back to the server.
*   **Game Modes & Flow:**
    *   **Single Player:** Accessed via dedicated button. Server detects single connection, bypasses lobby/countdown, and starts the game immediately.
    *   **Multiplayer (Lobby):** Accessed via dedicated button. Players join a shared lobby.
        *   **Spawn Selection:** Players click on the 3D island model during the lobby phase to select a starting location. Visual markers indicate chosen spots. Server validates positions (bounds, proximity to others). Players who don't choose are assigned a random offset position near the center at game start.
        *   **Countdown:** Any player in the lobby can initiate a short (e.g., 5s) countdown.
        *   **Game Start:** Game begins for all connected players after the countdown.
*   **Shared Environment:** All players experience the same synchronized day/night cycle and dynamic weather conditions (Sunny/Cloudy, Drought Factor, Rain) generated and broadcast by the server.
*   **Visuals & Effects:**
    *   3D island environment (Three.js).
    *   Synchronized sky color, fog, and lighting transitions.
    *   Rain particle effect during rainy periods.
    *   Starfield effect on clear nights.
*   **Core Tree Model:**
    *   Represents multiple player trees visually.
    *   Handles growth (trunk/canopy scaling) based on server state.
    *   Tiled canopy visually degrades based on `damagedLAPercentage` from server.
    *   Trees positioned according to chosen or assigned spawn points.
*   **Player Controls & State:**
    *   Real-time stomatal aperture slider input sent to server.
    *   Nightly allocation strategy (Savings %, Growth/Seed Ratio %) sliders' input sent to server.
    *   Server uses player inputs for its simulation calculations.
    *   Client UI displays player-specific resource bars (Carbon, Hydraulics) and seed count based on server data.
*   **Real-time Leaderboard:** UI panel displays all connected players, sorted by seed count (during game/end) or name (in lobby), indicating alive/dead status.
*   **Game Over:**
    *   Server detects when all players are dead (`isAlive=false`).
    *   Server determines winner (player with highest seed count).
    *   Server broadcasts `gameOver` event with reason and winner ID.
    *   Client displays a modal with results. "Play Again" button reloads client, returning to landing page. Server resets game state upon last player disconnect.
*   **Refactored Code Structure:**
    *   Client-side code moved into a `client/` directory.
    *   Server-side code moved into a `server/` directory, further modularized into `game/` (state, simulation, logic) and `network/` (connection, broadcast) sub-directories.
    *   Client and Server maintain separate `config.js` files for their respective needs.

## 5. Technology Stack

*   **Backend:** Node.js, Express, Socket.IO
*   **Frontend:** HTML5, CSS3, JavaScript (ES6 Modules)
*   **3D Rendering:** Three.js
*   **Camera Controls:** `OrbitControls`

## 6. Project Structure (Current)

```
.
├── .gitignore
├── README.md
├── client/
│   ├── config.js             # Client-specific configuration
│   ├── environment.js
│   ├── game.html
│   ├── gameState.js          # Client-side state cache
│   ├── index.html            # Landing page
│   ├── index.js              # Landing page script
│   ├── main.js               # Client entry point, game loop
│   ├── sceneSetup.js
│   ├── settings.html
│   ├── settings.js
│   ├── style.css
│   ├── tree.js               # Handles tree visuals
│   └── ui/                   # UI modules
│       ├── controlsHandlers.js
│       ├── elements.js
│       ├── gameOver.js
│       ├── leaderboard.js    # (Empty)
│       ├── messageHandler.js
│       ├── setupListeners.js
│       └── update.js
└── server/
    ├── config.js             # Server-specific configuration
    ├── game/
    │   ├── GameState.js      # Manages server game state
    │   ├── gameLogic.js      # High-level logic (start/end game, countdown)
    │   └── simulation.js     # Core physiological simulation tick
    ├── network/
    │   ├── connection.js     # Handles socket connections, disconnections, events
    │   └── stateBroadcaster.js # Creates and sends state snapshots
    ├── node_modules/
    ├── package-lock.json
    ├── package.json
    └── server.js             # Server entry point, Express/SocketIO setup, main loop interval
```

## 7. Getting Started / Running the Project

1.  **Clone Repository:** Get the project files.
2.  **Install Server Dependencies:** Navigate to the `server/` directory and run `npm install`.
3.  **Run the Server:** From the `server/` directory, run `node server.js`.
4.  **Open in Browser:** Navigate to `http://localhost:3000`.
5.  **Play:** Choose "Single Player" or "Multiplayer" (open multiple tabs/browsers for multiplayer testing).

## 8. Gameplay Mechanics (Multiplayer Focus)

*   **Objective:** Be the player with the most seeds when the game ends (currently when all players die).
*   **Lobby:** When joining multiplayer, you enter a lobby. Click on the island to choose your start location (green marker confirms your spot, orange markers show others'). Anyone can click "Start Game Countdown".
*   **Gameplay:** Once started, control your tree's stomata and allocation strategy. Monitor resources. All players experience the same weather. See other players' trees grow/die in real-time.
*   **Leaderboard:** Tracks seed counts and player status live.
*   **Game End:** Game ends when all trees are dead. A modal shows the winner.

## 9. Key Learnings & Decisions During Multiplayer Implementation

*   **Client-Server Split:** Clearly separated simulation logic (server) from rendering/input handling (client).
*   **Authoritative Server:** Server dictates all game state; client is a "dumb" renderer of that state.
*   **State Synchronization:** Using Socket.IO to broadcast regular state snapshots (`gameStateUpdate`). Key challenge is balancing data volume with update frequency.
*   **Input Handling:** Client immediately sends input (slider changes, button clicks) to server; server validates and updates its state, which is then reflected back in the next broadcast.
*   **Game Flow Management:** Server manages transitions between phases (lobby, countdown, playing, ended). Connection/disconnection logic needs careful handling to maintain correct state and trigger resets.
*   **Refactoring:** Moved server logic into modules (`game/`, `network/`) and client code into `client/` directory for better organization as complexity increased.
*   **Configuration:** Separated client (`client/config.js`) and server (`server/config.js`) configurations.
*   **Spawn Selection:** Implemented via raycasting on the client, validation and state update on the server, feedback via markers and state broadcasts. Default server-side assignment handles non-choosers.

## 10. Immediate Next Steps (Current Focus)

1.  **Spectator Mode:**
    *   Add "Spectate" button/intent.
    *   Server identifies spectators, excludes from gameplay logic.
    *   Client UI adjusts for spectators (hides controls/status).
2.  **Admin Panel:**
    *   Password-protected `/admin` route.
    *   Admin client page (`admin.html`, `admin.js`) with game view + control buttons.
    *   Server authentication for admin sockets.
    *   Server listeners for admin commands (Force Start/End, Reset Countdown) executing `gameLogic` functions.
3.  **Refine Spawn Markers:** Improve visual appearance/feedback for spawn markers.
4.  **Deployment:** Deploy the application to a suitable host (targeting PaaS like Render/Fly.io initially).

## 11. Future Directions / Longer Term Roadmap

*   **Environment Polish:** Improve visuals (rain, clouds, wind effects), add sound.
*   **Gameplay Balancing:** Tune rates, costs, weather probabilities based on playtesting.
*   **Player Interaction:** Implement shading effects between player trees.
*   **Climate Catastrophes:** Add rare server-triggered events.
*   **Persistence:** Leaderboards across multiple game rounds, potentially player accounts.
*   **Robustness:** Improve server stability, error handling, reconnection logic.
*   **Enhanced Scientific Accuracy:** More complex physiology models (water potential, nutrients).
*   **Educational Context:** In-game tooltips, links to concepts.
*   **(Maybe) Different Game Modes:** E.g., timed rounds, specific objectives.

## 12. Contributing

[Optional: Add guidelines if you plan for others to contribute]

## 13. License

[Optional: Add a license]

## 14. Contact

Developed by [Your Name/Alias], PhD Student in Plant Ecophysiology.
[Optional: Add contact email or link]

--- FILE: client/admin.js ---
// client/admin.js - Logic for the Admin Panel

import * as THREE from 'three';
// Import necessary modules (paths relative to client/)
import { gameState, getMyPlayerState } from './gameState.js'; // Use gameState for caching server state
import * as Config from './config.js';
import { initScene, renderer, camera, controls, scene } from './sceneSetup.js'; // Reuse scene setup
import { createOrUpdateTree, removeTree, disposeAllTrees } from './tree.js'; // Reuse tree rendering
import { cacheDOMElements, uiElements } from './ui/elements.js'; // Cache admin page UI elements
// Import the SPECIFIC Admin UI update function
import { updateUI as updateAdminUI } from './ui/updateAdmin.js'; // Use a SEPARATE admin UI update function
import { showMessage, clearMessage, attachServerMessageListener } from './ui/messageHandler.js'; // Use message handler
// Don't reuse gameOver UI directly, use admin modal buttons
import { hideGameOverModal } from './ui/gameOver.js';
import { updateEnvironmentVisuals, updateRain, setWeatherTargets, startRain, stopRain } from './environment.js';

// --- Global Variables ---
let clock = new THREE.Clock();
let animationFrameId = null;
let socket = null;
let adminPassword = null; // Store password retrieved from URL
let isAdminAuthenticated = false; // Track websocket auth status

// --- Initialization Function ---
function initializeAdminApp() {
    console.log("Initializing Admin Panel Client...");

    // --- Get Admin Password from URL ---
    const urlParams = new URLSearchParams(window.location.search);
    adminPassword = urlParams.get('pw');
    if (!adminPassword) {
        console.error("Admin Password missing from URL (?pw=...).");
        document.body.innerHTML = '<h1>Access Denied: Admin password missing from URL (?pw=...)</h1>';
        return; // Stop execution if no password
    }
    // Attempt to remove password from URL bar history for basic security
    try { history.replaceState(null, '', window.location.pathname); } catch (e) { console.warn("Could not clear URL history."); }


    // --- Basic Setup ---
    gameState.isSpectator = true; // Admin is always a spectator type
    cacheDOMElements(); // Cache elements defined in admin.html
    const canvas = document.getElementById('game-canvas');
    if (!canvas) { console.error("Admin Canvas element #game-canvas not found!"); return; }

    initScene(canvas); // Setup Three.js scene
    // No need for island mesh ref or spawn click listener for admin

    console.log("Admin: Attempting to connect to server...");
    socket = io(); // Define socket
    setupAdminSocketListeners(); // Setup listeners AFTER socket defined
    setupAdminButtonListeners(); // Setup listeners for admin buttons
    updateAdminUI(); // Initial UI render
    clearMessage();
    console.log("Admin Client Initialization complete. Waiting for server connection...");
}

// --- Socket Event Listener Setup ---
function setupAdminSocketListeners() {
    socket.on('connect', () => {
        gameState.myId = socket.id; // Store socket ID
        console.log(`Admin: Connected to server with ID: ${gameState.myId}`);
        showMessage(`Admin connected. Authenticating...`, 'info');

        // --- Send authentication event ---
        if (adminPassword) {
             console.log("Admin: Sending authentication request...");
             socket.emit('adminAuthenticate', { password: adminPassword });
        } else {
             console.error("Admin: Password was lost before authentication could be sent.");
              showMessage(`Authentication Error! Refresh.`, 'error');
              socket.disconnect();
        }
        // Clear password variable immediately after sending
        adminPassword = null;
    });

    // Listen for authentication confirmation/rejection
    socket.on('adminAuthResult', (result) => {
        if (result.success) {
            isAdminAuthenticated = true;
            console.log("Admin: WebSocket Authentication successful.");
            showMessage(`Admin Authenticated`, 'success');
            // Request full state upon successful auth? Server should send it anyway.
             if (uiElements.adminControls) { // Show controls on successful auth
                 uiElements.adminControls.style.display = 'flex';
             }
             // Attach server message listener now that socket is ready
             attachServerMessageListener();

        } else {
            isAdminAuthenticated = false;
            console.error("Admin: WebSocket Authentication Failed!", result.reason);
            showMessage(`Admin Auth Failed: ${result.reason || 'Invalid Password'}`, 'error');
             if (uiElements.adminControls) { // Hide controls on failed auth
                 uiElements.adminControls.style.display = 'none';
             }
            // Disconnect on failed auth
            if(socket) socket.disconnect();
        }
    });

    socket.on('disconnect', (reason) => { /* ... disconnect logic ... */
         console.log(`Admin: Disconnected: ${reason}`); showMessage("Disconnected!", "error");
         isAdminAuthenticated = false; gameState.myId = null; gameState.initialStateReceived = false;
         if (animationFrameId !== null) cancelAnimationFrame(animationFrameId); animationFrameId = null;
         if (uiElements.adminControls) uiElements.adminControls.style.display = 'none'; // Hide controls
         disposeAllTrees();
    });
    socket.on('connect_error', (error) => { /* ... */ console.error('Admin Conn Error:', error); showMessage("Connection failed!", "error"); });

    // --- Game State Update Handler (Spectator View) ---
    socket.on('gameStateUpdate', (serverState) => {
         const previousPhase = gameState.gamePhase;
         Object.assign(gameState, { /* ... assign properties ... */ day: serverState.day, timeInCycle: serverState.timeInCycle, currentPeriodIndex: serverState.currentPeriodIndex, isNight: serverState.isNight, currentLightMultiplier: serverState.currentLightMultiplier, currentDroughtFactor: serverState.currentDroughtFactor, isRaining: serverState.isRaining, gamePhase: serverState.gamePhase, countdownTimer: serverState.countdownTimer, serverTime: serverState.serverTime, players: serverState.players, });
         gameState.isSpectator = true; // Ensure always spectator

         if (!gameState.initialStateReceived) { /* ... First time setup ... */
             console.log("Admin: First gameStateUpdate received.");
             if(controls) controls.target.set(0, 5, 0); controls.update(); // General island view
             setWeatherTargets(gameState.isNight, gameState.currentLightMultiplier < Config.LIGHT_MULT_SUNNY - 0.1, gameState.isRaining); updateEnvironmentVisuals(1000); if(gameState.isRaining) startRain(); else stopRain();
             gameState.initialStateReceived = true; startGameLoop();
             setTimeout(() => showMessage(`Game state: ${gameState.gamePhase}`, 'info'), 100);
         } else if (gameState.gamePhase !== previousPhase) { /* ... Phase change update ... */ console.log(`Admin phase updated to: ${gameState.gamePhase}`); showMessage(`Game state: ${gameState.gamePhase}`, 'info'); }

         /* Update Environment */ const wasRaining = scene?.getObjectByName("rain")?.visible ?? false; setWeatherTargets(gameState.isNight, gameState.currentLightMultiplier < Config.LIGHT_MULT_SUNNY - 0.1, gameState.isRaining); if (gameState.isRaining && !wasRaining) startRain(); else if (!gameState.isRaining && wasRaining) stopRain();
         /* Update Trees */ const receivedPlayerIds = new Set(Object.keys(serverState.players)); for (const playerId in serverState.players) { const playerData = serverState.players[playerId]; if (playerData.isSpectator) { removeTree(playerId); continue; } createOrUpdateTree(playerId, playerData); } gameState.playerTrees.forEach((_, playerId) => { if (!receivedPlayerIds.has(playerId)) removeTree(playerId); });
         /* Update Camera Target */ if (controls) controls.target.lerp(new THREE.Vector3(0, 5, 0), 0.05); // Keep overview

     }); // End gameStateUpdate

    socket.on('playerDisconnected', (playerId) => { console.log(`Admin View: Player ${playerId} disconnected.`); removeTree(playerId); });
    // Use simplified game over display for admin
    socket.on('gameOver', (data) => {
         console.log("Admin View: Game Over event received:", data);
         gameState.gameOver = true; gameState.gameOverReason = data.reason || "Game Ended"; gameState.winnerId = data.winnerId;
         // Show modal, but maybe don't stop loop?
         if (uiElements.gameOverModal) {
            if(uiElements.gameOverReasonUI) uiElements.gameOverReasonUI.textContent = `Game Ended: ${gameState.gameOverReason}`;
            // Hide player-specific day/seed count on admin modal
            if(uiElements.finalDayUI) uiElements.finalDayUI.parentElement.style.display = 'none';
            if(uiElements.finalSeedsUI) uiElements.finalSeedsUI.parentElement.style.display = 'none';
            // Hide regular restart button if it exists, show only admin close
            if(uiElements.restartButton) uiElements.restartButton.style.display = 'none';
            if(document.getElementById('admin-close-modal')) document.getElementById('admin-close-modal').style.display = 'inline-block';

            uiElements.gameOverModal.classList.remove('hidden');
         }
    });

     // Listen for server messages (e.g., admin command confirmations)
     socket.on('serverMessage', (data) => {
         console.log("Admin received server message:", data);
         showMessage(data.text, data.type || 'info');
     });

} // End of setupSocketListeners


// --- Setup Listeners for Admin Buttons ---
function setupAdminButtonListeners() {
    console.log("Admin: Setting up button listeners...");
    const forceStartBtn = document.getElementById('admin-force-start');
    const forceEndBtn = document.getElementById('admin-force-end');
    const resetCountdownBtn = document.getElementById('admin-reset-countdown');
    const closeModalBtn = document.getElementById('admin-close-modal');

    // Ensure controls panel starts hidden until authenticated
     if (uiElements.adminControls) uiElements.adminControls.style.display = 'none';

    function emitAdminCommand(command) {
        // Only allow commands if WS connection is authenticated
        if (socket && socket.connected && isAdminAuthenticated) {
            console.log(`Admin: Emitting command: ${command}`);
            socket.emit(command); // Send command to server
        } else {
            console.error(`Admin: Cannot send command '${command}', socket not connected or not authenticated.`);
            showMessage("Cannot send command: Not authenticated.", "error");
        }
    }

    if (forceStartBtn) forceStartBtn.addEventListener('click', () => emitAdminCommand('adminForceStart'));
    else console.warn("Admin button 'admin-force-start' not found.");

    if (forceEndBtn) forceEndBtn.addEventListener('click', () => emitAdminCommand('adminForceEnd'));
    else console.warn("Admin button 'admin-force-end' not found.");

    if (resetCountdownBtn) resetCountdownBtn.addEventListener('click', () => emitAdminCommand('adminResetCountdown'));
    else console.warn("Admin button 'admin-reset-countdown' not found.");

    if (closeModalBtn) {
         closeModalBtn.addEventListener('click', hideGameOverModal);
         // Ensure it starts hidden in case game over modal is reused but button is admin-specific
         closeModalBtn.style.display = 'inline-block';
    } else {
         console.warn("Admin close modal button 'admin-close-modal' not found.");
    }
}

// --- Admin Rendering Loop ---
function gameLoop() {
    animationFrameId = requestAnimationFrame(gameLoop); const deltaTime = clock.getDelta();
    updateEnvironmentVisuals(deltaTime); updateRain(deltaTime); updateAdminUI();
    if (controls) controls.update(); if (renderer && scene && camera) renderer.render(scene, camera);
    else { console.error("Admin Render components missing!"); stopGameLoop(); }
}
function startGameLoop() { if (animationFrameId !== null) return; console.log("Admin: Starting render loop."); clock = new THREE.Clock(); gameLoop(); }
function stopGameLoop() { if (animationFrameId !== null) { cancelAnimationFrame(animationFrameId); animationFrameId = null; console.log("Admin: Stopped render loop."); } }

// --- Start Admin Application ---
document.addEventListener('DOMContentLoaded', initializeAdminApp);

// No exports needed for admin bundle

--- FILE: server/game/gameLogic.js ---
// server/game/gameLogic.js
import { getGlobalState, getAllPlayers, setGamePhase, resetGlobalStateValues, updateGlobalState, getPlayerState } from './GameState.js';
// Import simulation control functions and main server start function
import { stopSimulation, startGame as triggerServerStartGame } from '../server.js';
// Import broadcaster
import { broadcastGameState } from '../network/stateBroadcaster.js';

const COUNTDOWN_DURATION = 5; // Seconds for the lobby countdown
let countdownInterval = null; // Interval ID for the countdown timer

/** Starts the lobby countdown timer. */
export function startLobbyCountdown(io) { /* ... start countdown logic (no changes needed here) ... */
    const globalState = getGlobalState(); if (globalState.gamePhase !== 'lobby' || countdownInterval) { console.log("GameLogic: Cannot start countdown."); return; } if (Object.keys(getAllPlayers()).filter(id => !getPlayerState(id)?.isSpectator).length === 0) { console.log("GameLogic: Cannot start countdown, no active players."); return; }
    console.log(`GameLogic: Starting ${COUNTDOWN_DURATION}s countdown...`); setGamePhase('countdown'); updateGlobalState({ countdownTimer: COUNTDOWN_DURATION }); broadcastGameState(io, getAllPlayers(), getGlobalState());
    countdownInterval = setInterval(() => { const state = getGlobalState(); if (state.gamePhase !== 'countdown' || state.countdownTimer === null) { console.warn("GameLogic: Countdown interval invalid state. Cancelling."); cancelLobbyCountdown(); return; } if (Object.keys(getAllPlayers()).filter(id => !getPlayerState(id)?.isSpectator).length === 0) { console.log("GameLogic: No active players left during countdown. Cancelling."); cancelLobbyCountdown(); setGamePhase('lobby'); broadcastGameState(io, getAllPlayers(), getGlobalState()); return; } const newTime = state.countdownTimer - 1; updateGlobalState({ countdownTimer: newTime }); if (newTime <= 0) { console.log("GameLogic: Countdown finished. Triggering game start."); cancelLobbyCountdown(); triggerServerStartGame(); } }, 1000);
}

/** Cancels the lobby countdown if it's running. */
export function cancelLobbyCountdown() { /* ... cancel countdown logic (no changes needed here) ... */
    if (countdownInterval) { console.log("GameLogic: Cancelling lobby countdown interval."); clearInterval(countdownInterval); countdownInterval = null; updateGlobalState({ countdownTimer: null }); }
}

/** Ends the current game round. Accepts optional reason. Calls resetGame afterwards. */
export function endGame(io, players, globalState, reason = "All trees have perished!") {
    // Check if game is actually in a state that can be ended
    if (globalState.gamePhase !== 'playing' && globalState.gamePhase !== 'countdown') {
        console.log(`GameLogic: endGame called but game not playing/countdown. Phase: ${globalState.gamePhase}. Ensuring reset.`);
        // Ensure simulation/countdown are stopped and state is reset properly even if called in wrong phase
        resetGame(); // Call reset to clean up and go to lobby
        return;
    }

    console.log("GameLogic: Determining winner and ending game.");
    stopSimulation(); cancelLobbyCountdown(); // Stop loops first
    setGamePhase('ended'); // Set phase to ended

    let winnerId = null; let maxSeeds = -1;
    Object.values(players).forEach(p => { if (!p.isSpectator && p.seedCount > maxSeeds) { maxSeeds = p.seedCount; winnerId = p.id; } });

    console.log(`GameLogic: Game Ended. Winner: ${winnerId || 'None'} with ${maxSeeds} seeds. Reason: ${reason}`);

    // Broadcast game over event FIRST, while state is still 'ended'
    io.emit('gameOver', { reason: reason, winnerId: winnerId });
    // Broadcast the final 'ended' state snapshot
    broadcastGameState(io, players, globalState);

    // --- Call resetGame AFTER broadcasting the final 'ended' state ---
    // This ensures clients see the game over message/state before server resets to lobby
    // Add a small delay so clients definitely process the 'gameOver'/'ended' state first
    setTimeout(() => {
        resetGame(); // Reset server to lobby state for the next round
        // Players object will clear as clients disconnect/reconnect after seeing game over
    }, 1000); // 1 second delay before reset (adjust if needed)

}

/** Resets the game state fully, preparing for a new round. */
export function resetGame() {
    // This function should ONLY reset state and stop loops, not handle broadcasts
    console.log("GameLogic: Resetting game state...");
    cancelLobbyCountdown();
    stopSimulation();
    resetGlobalStateValues(); // Resets time, weather, sets phase to 'lobby'
    // Note: Players are not cleared here; disconnect/reconnect handles that.
    console.log("GameLogic: Game reset complete. Ready for lobby.");
}

--- FILE: client/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Island Canopy Sim - Welcome</title>
    <link rel="stylesheet" href="/style.css"> <!-- Root relative path -->
    <style>
        /* Basic Landing Page Specific Styles */
        body {
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; background-color: #2b412b; color: #f0f0f0;
            font-family: sans-serif; text-align: center;
        }
        .landing-container {
            background-color: rgba(0, 0, 0, 0.5); padding: 40px;
            border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        h1 { color: #90ee90; margin-bottom: 30px; font-size: 2.5em; }
        .button-group { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; }
        button {
            padding: 12px 25px; font-size: 1.1em; cursor: pointer; border: none; border-radius: 5px;
            background-color: #556b2f; color: #f0f0f0; transition: background-color 0.3s ease;
        }
        button:hover:not(:disabled) { background-color: #6b8e23; }
        button:disabled { background-color: #4a4a4a; color: #888; cursor: not-allowed; }
    </style>
</head>
<body>
    <div class="landing-container">
        <h1>Forest Royale</h1>
        <p>Make Good Decisions!</p>

        <div class="button-group">
            <button id="start-single-player">Single Player</button>
            <button id="start-multi-player">Multiplayer</button>
            <!-- Add Spectate Button -->
            <button id="spectate-game">Spectate Game</button>
            <button id="open-settings">Settings</button>
        </div>
    </div>

    <script src="/index.js"></script> <!-- Root relative path -->
</body>
</html>

--- FILE: client/game.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Island Canopy Sim</title>
    <link rel="stylesheet" href="/style.css"> <!-- Use root-relative path -->
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
    </div>

    <!-- ================================== -->
    <!-- UI Structure -->
    <!-- ================================== -->

    <!-- Top Left Info Area -->
    <div id="top-left-info" class="ui-panel">
         <p>Day: <span id="day-counter">1</span></p>
         <p>Time: <span id="time-of-day">Loading...</span></p> <!-- Start with Loading -->
         <p>Weather: <span id="weather-status">--</span></p>
         <p>Cycle Left: <span id="cycle-timer">--</span>s</p>
         <div id="message-log" class="message"></div>

         <!-- Lobby/Countdown Specific UI (Initially Hidden) -->
         <div id="lobby-info" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #555;">
             <h4>Lobby</h4>
             <p>Players (<span id="lobby-player-count">0</span>)</p>
             <p id="countdown-timer-display" style="font-weight: bold; color: #ffc107;"></p> <!-- Timer display -->
             <button id="start-countdown-button" style="margin-top: 5px;">Start Countdown</button> <!-- Text updated by JS -->
         </div>

    </div>

     <!-- Top Right Leaderboard Area -->
    <div id="top-right-leaderboard" class="ui-panel leaderboard">
         <!-- Title changes based on phase -->
         <h4 id="leaderboard-title">Leaderboard (-/-)</h4> <!-- Updated placeholder -->
         <ul id="leaderboard-list">
             <li>Waiting for state...</li>
         </ul>
    </div>

     <!-- Bottom Left Status Area -->
     <div id="bottom-left-status" class="ui-panel"> <!-- <<< Ensure this ID is present -->
          <div class="status-bar-container">
                <label>Carbon:</label>
                <div class="bar-outer"><div id="carbon-bar" class="bar-inner carbon" style="width: 0%;"></div></div> <!-- Start at 0% -->
                <span id="carbon-value">--</span>
            </div>
            <div class="status-bar-container">
                <label>Hydraulics:</label>
                <div class="bar-outer"><div id="hydraulic-bar" class="bar-inner hydraulic" style="width: 0%;"></div></div> <!-- Start at 0% -->
                 <span id="hydraulic-value">--</span>
            </div>
             <p>Seeds: <span id="seed-counter">0</span></p>
     </div>

     <!-- Control Panel Area (Bottom Right) -->
     <div id="control-panel-right" class="ui-panel" style="display: none;"> <!-- Start hidden -->
          <div class="control-row stomata">
             <label for="stomata-slider">Stomatal Openness:</label>
             <input type="range" id="stomata-slider" min="0" max="1" step="0.05" value="0.5">
             <span id="stomata-value">50%</span>
          </div>
          <div class="control-row allocation">
             <label for="savings-slider">Carbon Savings %:</label>
             <input type="range" id="savings-slider" min="0" max="100" step="1" value="50">
             <span class="slider-percentage" id="savings-percentage">50%</span>
          </div>
           <div class="control-row allocation">
             <label for="growth-ratio-slider"> Invest % Grow/Seeds:</label>
             <input type="range" id="growth-ratio-slider" min="0" max="100" step="1" value="50">
             <span class="slider-percentage" id="growth-ratio-percentage">50%/50%</span>
          </div>
     </div>
     <!-- End Control Panel Area -->

    <!-- Game Over Modal (Still separate) -->
    <div id="game-over-modal" class="modal hidden">
         <h2>Game Over!</h2>
        <p id="game-over-reason"></p>
        <p>You survived <span id="final-day">0</span> days and produced <span id="final-seeds">0</span> seeds.</p>
        <button id="restart-button">Play Again</button>
    </div>

    <!-- Imports -->
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } } </script>
    <script src="/socket.io/socket.io.js"></script>
    <script type="module" src="/main.js"></script> <!-- Use root-relative path -->
</body>
</html>

--- FILE: client/main.js ---
// client/main.js

import * as THREE from 'three';
import { gameState, loadClientSettings, getMyPlayerState } from './gameState.js';
import * as Config from './config.js';
import { initScene, renderer, camera, controls, scene } from './sceneSetup.js';
import { createOrUpdateTree, removeTree, disposeAllTrees } from './tree.js';
import { cacheDOMElements } from './ui/elements.js';
import { setupUIListeners } from './ui/setupListeners.js';
import { updateUI } from './ui/update.js';
// Import specific functions from messageHandler
import { showMessage, clearMessage, attachServerMessageListener } from './ui/messageHandler.js'; // Import attach function
import { hideGameOverModal, showGameOverUI } from './ui/gameOver.js';
import { updateEnvironmentVisuals, updateRain, setWeatherTargets, startRain, stopRain } from './environment.js';

// --- Global Variables ---
let clock = new THREE.Clock(); let animationFrameId = null; let socket = null;
let raycaster = new THREE.Raycaster(); let mouse = new THREE.Vector2();
let islandMesh = null; let spawnMarkers = new Map(); let tempSpawnMarker = null;

// --- Initialization Function ---
function initializeApp() {
    console.log("Initializing Island Canopy Sim Client...");
    const intent = sessionStorage.getItem('gameModeIntent') || 'single';
    gameState.isSpectator = (intent === 'spectate');
    console.log(`Client: Detected intent: ${intent}, Is Spectator: ${gameState.isSpectator}`);
    loadClientSettings(); cacheDOMElements();
    const canvas = document.getElementById('game-canvas'); if (!canvas) { return; } initScene(canvas);
    islandMesh = scene.getObjectByName('island'); if (!islandMesh) console.error("Spawn Error: Island mesh 'island' not found!");
    canvas.addEventListener('pointerup', handleSpawnClick, false);
    console.log("Attempting to connect to server...");
    socket = io(); // Define socket here
    setupSocketListeners(intent); // Setup listeners AFTER socket defined
    setupUIListeners(); updateUI(); clearMessage();
    console.log("Client Initialization complete. Waiting for server connection...");
}

// --- Spawn Selection Click Handler ---
// (handleSpawnClick remains the same as previous complete version)
function handleSpawnClick(event) { const myState = getMyPlayerState(); if (gameState.gamePhase !== 'lobby' || gameState.isSpectator || !myState || myState.hasChosenSpawn || !islandMesh) { return; } if (document.pointerLockElement === renderer.domElement) return; mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = - (event.clientY / window.innerHeight) * 2 + 1; raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObject(islandMesh); if (intersects.length > 0) { const intersectionPoint = intersects[0].point; const islandRadius = Config.ISLAND_RADIUS || 50; if (intersectionPoint.x**2 + intersectionPoint.z**2 > islandRadius*islandRadius) { showMessage("Cannot spawn outside island!", "warning"); return; } showTemporaryMarker(intersectionPoint); if (socket && socket.connected) { console.log(`Client: Emitting selectSpawnPoint: { x: ${intersectionPoint.x.toFixed(2)}, z: ${intersectionPoint.z.toFixed(2)} }`); socket.emit('selectSpawnPoint', { x: intersectionPoint.x, z: intersectionPoint.z }); } else { showMessage("Not connected!", "error"); removeTemporaryMarker(); } } }

// --- Spawn Marker Visuals ---
// (marker functions remain the same as previous complete version)
const markerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 16); const tempMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.7 }); const confirmedMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); const otherPlayerMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500 });
function showTemporaryMarker(position) { removeTemporaryMarker(); if (!tempSpawnMarker) { tempSpawnMarker = new THREE.Mesh(markerGeometry, tempMarkerMaterial); tempSpawnMarker.name = "tempSpawnMarker"; } tempSpawnMarker.position.set(position.x, (Config.ISLAND_LEVEL || 0.1) + 0.1, position.z); if (!tempSpawnMarker.parent) scene.add(tempSpawnMarker); }
function removeTemporaryMarker() { if (tempSpawnMarker) { if(tempSpawnMarker.parent) scene.remove(tempSpawnMarker); } }
function addOrUpdateSpawnMarker(playerId, spawnPoint, isConfirmed) { let marker = spawnMarkers.get(playerId); if (!marker && isConfirmed) { const material = (playerId === gameState.myId && !gameState.isSpectator) ? confirmedMarkerMaterial : otherPlayerMarkerMaterial; marker = new THREE.Mesh(markerGeometry.clone(), material); marker.name = `spawnMarker_${playerId}`; scene.add(marker); spawnMarkers.set(playerId, marker); } if (marker) { marker.position.set(spawnPoint.x, (Config.ISLAND_LEVEL || 0.1) + 0.1, spawnPoint.z); marker.visible = isConfirmed; } }
function removeSpawnMarker(playerId) { const marker = spawnMarkers.get(playerId); if (marker) { if(marker.parent) scene.remove(marker); marker.geometry.dispose(); spawnMarkers.delete(playerId); } }
function removeAllSpawnMarkers() { spawnMarkers.forEach((marker) => { if(marker.parent) scene.remove(marker); marker.geometry.dispose(); }); spawnMarkers.clear(); removeTemporaryMarker(); }

// --- Socket Event Listener Setup ---
function setupSocketListeners(intent) {
    socket.on('connect', () => {
        gameState.myId = socket.id;
        console.log(`Connected to server with ID: ${gameState.myId}`);
        showMessage(`Connected! Joining as ${intent}...`, 'info');
        socket.emit('playerJoinRequest', { intent: intent });
        sessionStorage.removeItem('gameModeIntent');

        // +++ Attach server message listener AFTER connection +++
        attachServerMessageListener();

    });

    socket.on('disconnect', (reason) => { /* ... disconnect logic ... */ console.log(`Disconnected: ${reason}`); showMessage("Disconnected!", "error"); gameState.myId = null; gameState.initialStateReceived = false; gameState.isSpectator = false; if (animationFrameId !== null) cancelAnimationFrame(animationFrameId); animationFrameId = null; disposeAllTrees(); removeAllSpawnMarkers(); });
    socket.on('connect_error', (error) => { /* ... */ console.error('Conn Error:', error); showMessage("Connection failed!", "error"); });

    // --- Game State Update Handler ---
    socket.on('gameStateUpdate', (serverState) => { /* ... gameState update logic ... */
         const previousPhase = gameState.gamePhase; Object.assign(gameState, { day: serverState.day, timeInCycle: serverState.timeInCycle, currentPeriodIndex: serverState.currentPeriodIndex, isNight: serverState.isNight, currentLightMultiplier: serverState.currentLightMultiplier, currentDroughtFactor: serverState.currentDroughtFactor, isRaining: serverState.isRaining, gamePhase: serverState.gamePhase, countdownTimer: serverState.countdownTimer, serverTime: serverState.serverTime, players: serverState.players, }); const myServerState = serverState.players[gameState.myId]; gameState.isSpectator = myServerState?.isSpectator ?? gameState.isSpectator;
         if (!gameState.initialStateReceived) { /* ... First time setup ... */ console.log("First gameStateUpdate received."); const myInitialState = getMyPlayerState(); if (myInitialState && controls) { const initialHeight = myInitialState.trunkHeight || Config.INITIAL_TRUNK_HEIGHT; const targetX = myInitialState.spawnPoint?.x ?? 0; const targetZ = myInitialState.spawnPoint?.z ?? 0; const baseLevel = Config.ISLAND_LEVEL || 0; if(gameState.isSpectator) { controls.target.set(0, 5, 0); } else { controls.target.set(targetX, initialHeight / 2 + baseLevel, targetZ); } controls.update(); } setWeatherTargets(gameState.isNight, gameState.currentLightMultiplier < Config.LIGHT_MULT_SUNNY - 0.1, gameState.isRaining); updateEnvironmentVisuals(1000); if(gameState.isRaining) startRain(); else stopRain(); gameState.initialStateReceived = true; startGameLoop(); setTimeout(() => showMessage(`Game state: ${gameState.gamePhase}`, 'info'), 100);
         } else if (gameState.gamePhase !== previousPhase) { /* ... Phase change update ... */ console.log(`Client phase updated from ${previousPhase} to: ${gameState.gamePhase}`); showMessage(`Game state: ${gameState.gamePhase}`, 'info'); if ((previousPhase === 'lobby' || previousPhase === 'countdown') && (gameState.gamePhase !== 'lobby' && gameState.gamePhase !== 'countdown')) { removeAllSpawnMarkers();} }
         /* Update Environment */ const wasRaining = scene?.getObjectByName("rain")?.visible ?? false; setWeatherTargets(gameState.isNight, gameState.currentLightMultiplier < Config.LIGHT_MULT_SUNNY - 0.1, gameState.isRaining); if (gameState.isRaining && !wasRaining) startRain(); else if (!gameState.isRaining && wasRaining) stopRain();
         /* Update Trees & Markers */ const receivedPlayerIds = new Set(Object.keys(serverState.players)); for (const playerId in serverState.players) { const playerData = serverState.players[playerId]; if (playerId === gameState.myId && gameState.isSpectator) { removeTree(playerId); continue; } if (gameState.gamePhase === 'playing' || gameState.gamePhase === 'ended' || gameState.isSpectator) { createOrUpdateTree(playerId, playerData); } else { removeTree(playerId); } if (gameState.gamePhase === 'lobby' || gameState.gamePhase === 'countdown') { addOrUpdateSpawnMarker(playerId, playerData.spawnPoint, playerData.hasChosenSpawn); } } gameState.playerTrees.forEach((_, playerId) => { if (!receivedPlayerIds.has(playerId)) removeTree(playerId); }); spawnMarkers.forEach((_, playerId) => { if (!receivedPlayerIds.has(playerId)) removeSpawnMarker(playerId); }); if (gameState.gamePhase !== 'lobby' && gameState.gamePhase !== 'countdown' && spawnMarkers.size > 0) { removeAllSpawnMarkers(); }
         /* Update Camera Target */ const myState = getMyPlayerState(); if (myState && myState.isAlive && !gameState.isSpectator && controls && gameState.playerTrees.has(gameState.myId)) { const myTreeGroup = gameState.playerTrees.get(gameState.myId); const baseLevel = Config.ISLAND_LEVEL || 0; const targetPos = new THREE.Vector3(myTreeGroup.position.x, myState.trunkHeight / 2 + baseLevel, myTreeGroup.position.z); if (!controls.target.equals(targetPos)){ controls.target.lerp(targetPos, 0.1); } } else if (controls && gameState.gamePhase !== 'lobby') { controls.target.lerp(new THREE.Vector3(0, 5, 0), 0.05); }
     }); // End gameStateUpdate

    // --- Spawn Handlers ---
    socket.on('spawnPointConfirmed', (confirmedPoint) => { if(gameState.isSpectator) return; console.log("Client: Spawn Confirmed", confirmedPoint); removeTemporaryMarker(); const myId = gameState.myId; if (myId) { addOrUpdateSpawnMarker(myId, confirmedPoint, true); const myState = getMyPlayerState(); if(myState) myState.hasChosenSpawn = true; showMessage("Spawn confirmed!", "info"); updateUI(); } });
    socket.on('spawnPointInvalid', (data) => { if(gameState.isSpectator) return; console.log("Client: Spawn Invalid", data); removeTemporaryMarker(); showMessage(`Spawn invalid: ${data?.reason || 'Try again.'}`, "warning"); });
    // --- Other handlers ---
    socket.on('playerDisconnected', (playerId) => { console.log(`Player ${playerId} disconnected.`); removeTree(playerId); removeSpawnMarker(playerId); });
    socket.on('gameOver', (data) => { console.log("Game Over received:", data); gameState.gameOver = true; gameState.gameOverReason = data.reason || "Game Ended!"; gameState.winnerId = data.winnerId; removeAllSpawnMarkers(); showGameOverUI(); });

} // End of setupSocketListeners

// --- Main Game Loop & Helpers ---
function gameLoop() { animationFrameId=requestAnimationFrame(gameLoop); const dt=clock.getDelta(); updateEnvironmentVisuals(dt); updateRain(dt); updateUI(); if(controls)controls.update(); if(renderer&&scene&&camera)renderer.render(scene,camera); else{console.error("Render components missing!");stopGameLoop();} }
function startGameLoop() { if(animationFrameId!==null)return; console.log("MAIN: Starting client render loop."); clock=new THREE.Clock(); gameLoop(); }
function stopGameLoop() { if(animationFrameId!==null){cancelAnimationFrame(animationFrameId); animationFrameId=null; console.log("MAIN: Stopped client render loop.");} }
export function handleRestart() { window.location.href = '/'; }

// --- Start Application ---
document.addEventListener('DOMContentLoaded', initializeApp);
// --- Export socket ---
export { socket }; // Export for other modules like messageHandler, controlsHandlers

--- FILE: client/admin.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Forest Royale - Admin Panel</title>
    <!-- Link to shared stylesheet -->
    <link rel="stylesheet" href="/style.css">
    <style>
        /* Admin specific styles */
        #admin-controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(150, 0, 0, 0.7);
            border: 1px solid #ff0000;
            padding: 15px;
            border-radius: 8px;
            z-index: 20; /* Above other UI panels */
            display: flex;
            gap: 10px;
        }
        #admin-controls button {
            background-color: #a00;
            color: white;
            border: 1px solid #f00;
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 4px;
        }
         #admin-controls button:hover {
             background-color: #d00;
         }
         /* Ensure game container takes full space */
         #game-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
         #game-canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <!-- Game View Container -->
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
    </div>

    <!-- Informational UI Panels (Similar to game.html, but no player status/controls) -->
    <div id="top-left-info" class="ui-panel">
         <p>Day: <span id="day-counter">1</span></p>
         <p>Time: <span id="time-of-day">Loading...</span></p>
         <p>Weather: <span id="weather-status">--</span></p>
         <p>Cycle Left: <span id="cycle-timer">--</span>s</p>
         <div id="message-log" class="message">ADMIN VIEW</div> <!-- Indicate admin view -->
         <!-- Lobby/Countdown Info -->
         <div id="lobby-info" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #555;">
             <h4>Lobby</h4>
             <p>Players (<span id="lobby-player-count">0</span>)</p>
             <p id="countdown-timer-display" style="font-weight: bold; color: #ffc107;"></p>
             <!-- No start button needed here -->
         </div>
    </div>

    <div id="top-right-leaderboard" class="ui-panel leaderboard">
         <h4 id="leaderboard-title">Leaderboard (-/-)</h4>
         <ul id="leaderboard-list">
             <li>Waiting for state...</li>
         </ul>
    </div>

    <!-- Admin Controls Panel -->
    <div id="admin-controls" class="ui-panel">
        <button id="admin-force-start">Force Start</button>
        <button id="admin-force-end">Force End</button>
        <button id="admin-reset-countdown">Reset Countdown</button>
        <!-- Add more controls later if needed -->
    </div>


    <!-- Game Over Modal (reuse from game.html structure) -->
     <div id="game-over-modal" class="modal hidden">
         <h2>Game Over!</h2>
        <p id="game-over-reason"></p>
        <p>Game ended by admin or naturally.</p> <!-- Generic message -->
        <!-- No Play Again button needed for admin? Or maybe a 'Reset Server State' button? -->
        <button id="admin-close-modal">Close</button>
    </div>


    <!-- Imports -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="/socket.io/socket.io.js"></script>
    <!-- Link to NEW Admin JS file -->
    <script type="module" src="/admin.js"></script>
</body>
</html>

--- FILE: client/environment.js ---
// environment.js
// Manages visual aspects of the game environment (lighting, sky, effects)

import * as THREE from 'three';
import { scene, sunLight, ambientLight, camera } from './sceneSetup.js';
import { gameState } from './gameState.js'; // Import gameState to read server state

// --- Configuration (Keep as before) ---
const skyColors = { day_sunny: new THREE.Color(0x87CEEB), day_cloudy: new THREE.Color(0xB0C4DE), night: new THREE.Color(0x000020) };
const fogColors = { day_sunny: new THREE.Color(0x87CEEB), day_cloudy: new THREE.Color(0xA9A9A9), night: new THREE.Color(0x000010) };
const FOG_DAY_NEAR = 50; const FOG_DAY_FAR = 150;
const FOG_NIGHT_NEAR = 9999; const FOG_NIGHT_FAR = 10000;
const ambientIntensity = { day_sunny: 0.6, day_cloudy: 0.4, night: 0.1 };
const sunIntensity = { day_sunny: 1.5, day_cloudy: 0.5, night: 0.0 };
const starCount = 7000;
const SMOOTHING_SPEED = 1.5;
const RAIN_COUNT = 7000; const RAIN_AREA_SIZE = 60; const RAIN_HEIGHT = 50; const RAIN_SPEED = 80; const RAIN_COLOR = 0xAAAAFF;

// --- Module State for Lerping (Keep as before) ---
let stars = null;
let currentAmbientIntensity = ambientIntensity.day_sunny; // Initial default
let currentSunIntensity = sunIntensity.day_sunny;
let currentSkyColor = skyColors.day_sunny.clone();
let currentFogColor = fogColors.day_sunny.clone();
let currentFogNear = FOG_DAY_NEAR;
let currentFogFar = FOG_DAY_FAR;

let targetAmbientIntensity = currentAmbientIntensity;
let targetSunIntensity = currentSunIntensity;
let targetSkyColor = currentSkyColor.clone();
let targetFogColor = currentFogColor.clone();
let targetFogNear = currentFogNear;
let targetFogFar = currentFogFar;
let targetStarsVisible = false;

// Rain State
let rainParticles = null;
let rainGeometry = null;
let rainMaterial = null;
let rainPositions = null;
let rainVelocities = null;

// --- Initialization Functions (Keep createStars, createRainSystem as before) ---
export function createStars() {
    if (stars) { /* cleanup */ if(stars.geometry) stars.geometry.dispose(); if(stars.material) stars.material.dispose(); if(scene) scene.remove(stars); stars = null; }
    const starGeometry = new THREE.BufferGeometry(); const starVertices = [];
    const starMaterial = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 0.4, sizeAttenuation: true, transparent: true, opacity: 0.9, depthWrite: false, blending: THREE.AdditiveBlending });
    const radius = 500;
    for (let i = 0; i < starCount; i++) { const phi = Math.acos(-1 + (2 * Math.random())); const theta = Math.random() * Math.PI * 2; const x = radius * Math.sin(phi) * Math.cos(theta); const y = radius * Math.cos(phi); const z = radius * Math.sin(phi) * Math.sin(theta); if (y > -radius * 0.05) starVertices.push(x, y, z); }
    starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3)); stars = new THREE.Points(starGeometry, starMaterial); stars.name = "stars"; stars.visible = false; stars.renderOrder = 1; if (scene) scene.add(stars);
    console.log("Stars created (Additive White) and added to scene.");
}
export function createRainSystem() {
    if (rainParticles) return; rainGeometry = new THREE.BufferGeometry();
    rainMaterial = new THREE.PointsMaterial({ color: RAIN_COLOR, size: 0.08, sizeAttenuation: true, transparent: true, opacity: 0.6, blending: THREE.NormalBlending, depthWrite: false });
    rainPositions = new Float32Array(RAIN_COUNT * 3); rainVelocities = new Array(RAIN_COUNT); const halfArea = RAIN_AREA_SIZE / 2;
    for (let i = 0; i < RAIN_COUNT; i++) { const i3 = i * 3; rainPositions[i3 + 0] = Math.random() * RAIN_AREA_SIZE - halfArea; rainPositions[i3 + 1] = Math.random() * RAIN_HEIGHT; rainPositions[i3 + 2] = Math.random() * RAIN_AREA_SIZE - halfArea; rainVelocities[i] = -RAIN_SPEED * (0.8 + Math.random() * 0.4); }
    rainGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3)); rainParticles = new THREE.Points(rainGeometry, rainMaterial); rainParticles.name = "rain"; rainParticles.visible = false; if (scene) { scene.add(rainParticles); console.log("Rain particle system created."); } else { console.error("Scene not available for adding rain system."); }
}


// --- Update Functions ---

/**
 * Sets the TARGET visual state based on conditions read from gameState.
 * Now takes arguments derived from gameState in main.js.
 * @param {boolean} isNight
 * @param {boolean} isCloudy - True if light multiplier indicates cloudy
 * @param {boolean} isRaining
 */
export function setWeatherTargets(isNight, isCloudy, isRaining) {
    if (isNight) {
        targetAmbientIntensity = ambientIntensity.night; targetSunIntensity = sunIntensity.night;
        targetSkyColor = skyColors.night; targetFogColor = fogColors.night;
        targetFogNear = FOG_NIGHT_NEAR; targetFogFar = FOG_NIGHT_FAR;
        targetStarsVisible = !isRaining; // Stars visible only if night and not raining
    } else { // Daytime
        targetAmbientIntensity = isCloudy ? ambientIntensity.day_cloudy : ambientIntensity.day_sunny;
        targetSunIntensity = isCloudy ? sunIntensity.day_cloudy : sunIntensity.day_sunny;
        targetSkyColor = isCloudy ? skyColors.day_cloudy : skyColors.day_sunny;
        targetFogColor = isCloudy ? fogColors.day_cloudy : fogColors.day_sunny;
        targetFogNear = FOG_DAY_NEAR; targetFogFar = FOG_DAY_FAR;
        targetStarsVisible = false; // No stars during day
    }
    // console.log(`ENV: Targets set - Night:${isNight}, Cloudy:${isCloudy}, Raining:${isRaining}, StarsTarget:${targetStarsVisible}`);
}

// Updates the actual visual environment state via lerping towards targets
// Reads targets directly, no need to read gameState here.
export function updateEnvironmentVisuals(deltaTime) {
    if (!scene || !scene.fog || !ambientLight || !sunLight) return; // Ensure scene objects exist

    const lerpFactor = Math.min(1.0, deltaTime * SMOOTHING_SPEED);

    // Lerp intensities
    currentAmbientIntensity = THREE.MathUtils.lerp(currentAmbientIntensity, targetAmbientIntensity, lerpFactor);
    currentSunIntensity = THREE.MathUtils.lerp(currentSunIntensity, targetSunIntensity, lerpFactor);

    // Lerp colors
    currentSkyColor.lerp(targetSkyColor, lerpFactor);
    currentFogColor.lerp(targetFogColor, lerpFactor);

    // Lerp fog distances
    currentFogNear = THREE.MathUtils.lerp(currentFogNear, targetFogNear, lerpFactor);
    currentFogFar = THREE.MathUtils.lerp(currentFogFar, targetFogFar, lerpFactor);

    // Apply current values
    ambientLight.intensity = currentAmbientIntensity;
    sunLight.intensity = currentSunIntensity;
    scene.background = currentSkyColor;
    scene.fog.color = currentFogColor;
    scene.fog.near = currentFogNear;
    scene.fog.far = currentFogFar;

    // Update star visibility (instant change is fine)
    if (stars && stars.visible !== targetStarsVisible) {
        stars.visible = targetStarsVisible;
        // console.log(`ENV: Stars visibility set to ${targetStarsVisible}`);
    }
}

// Makes rain visible
export function startRain() {
    if (rainParticles && !rainParticles.visible) { // Only change if not already visible
        rainParticles.visible = true;
        console.log("ENV: Starting rain effect.");
    }
}

// Makes rain invisible
export function stopRain() {
     if (rainParticles && rainParticles.visible) { // Only change if visible
        rainParticles.visible = false;
        console.log("ENV: Stopping rain effect.");
    }
}

// Animates the raindrops (Keep as before)
export function updateRain(deltaTime) {
    if (!rainParticles || !rainParticles.visible || !rainPositions || !rainVelocities) return;
    const positions = rainParticles.geometry.attributes.position.array; const halfArea = RAIN_AREA_SIZE / 2;
    for (let i = 0; i < RAIN_COUNT; i++) { const i3 = i * 3; positions[i3 + 1] += rainVelocities[i] * deltaTime; if (positions[i3 + 1] < 0) { positions[i3 + 0] = Math.random() * RAIN_AREA_SIZE - halfArea; positions[i3 + 1] = RAIN_HEIGHT + Math.random() * 5; positions[i3 + 2] = Math.random() * RAIN_AREA_SIZE - halfArea; } }
    rainParticles.geometry.attributes.position.needsUpdate = true;
}

--- FILE: client/ui/messageHandler.js ---
// client/ui/messageHandler.js
import { uiElements } from './elements.js';
// Import socket reference - it might be null initially
import { socket } from '../main.js';

let listenerAttached = false; // Module-level flag

/** Shows a message in the message log area. */
export function showMessage(text, type = 'info') {
     if (uiElements.messageLogUI) {
        uiElements.messageLogUI.textContent = text;
        uiElements.messageLogUI.className = `message ${type}`;
     } else {
         // console.warn(`Msg Log UI not found. (${type}): ${text}`); // Reduce noise
     }
}

/** Clears the message log area. */
export function clearMessage() {
    if (uiElements.messageLogUI) {
        uiElements.messageLogUI.textContent = '';
        uiElements.messageLogUI.className = 'message';
    }
}

/**
 * Attaches the listener for the 'serverMessage' event.
 * Should be called once the socket connection is established.
 */
export function attachServerMessageListener() {
    // Prevent attaching multiple times and ensure socket exists
    if (!socket || listenerAttached) {
        if(listenerAttached) console.log("Message Handler: Listener already attached.");
        if(!socket) console.warn("Message Handler: attach called but socket is not ready.");
        return;
    }

    socket.on('serverMessage', (data) => {
        console.log("Received server message:", data);
        showMessage(data.text, data.type || 'info');
    });

    listenerAttached = true;
    console.log("Message Handler: Server message listener attached.");
}

// --- DO NOT CALL setup automatically on load ---
// setupServerMessageListener(); // REMOVED - Call attachServerMessageListener from main.js instead

--- FILE: client/ui/update.js ---
// client/ui/update.js
import { gameState, getMyPlayerState } from '../gameState.js';
import * as Config from '../config.js';
import { uiElements } from './elements.js';

/** Updates all relevant UI elements based on the current gameState. */
export function updateUI() {
    // Allow update even before initial state for basic loading display
    if (!uiElements.dayCounterUI) { // Check only one essential element that should always exist on game page
        // console.warn("UpdateUI: Waiting for essential UI elements.");
        return;
    }

    const myState = getMyPlayerState();
    const phase = gameState.gamePhase;
    const allConnections = gameState.players; // Get all connections
    const playersOnly = Object.values(allConnections).filter(p => !p.isSpectator); // Filter out spectators
    const playerCount = playersOnly.length; // Count only actual players
    const aliveCount = playersOnly.filter(p => p.isAlive).length; // Count alive among players
    const isSpectator = gameState.isSpectator; // Use the flag from client gameState

    // --- Update Status Bars (Bottom Left) ---
    // Hide if spectator
    if (uiElements.bottomLeftStatus) {
        uiElements.bottomLeftStatus.style.display = isSpectator ? 'none' : 'block';
    }
    if (!isSpectator && gameState.initialStateReceived) { // Only update values if not spectator AND state received
        const carbon = myState?.carbonStorage ?? 0; const maxCarbon = Config.MAX_CARBON;
        const hydraulics = myState?.hydraulicSafety ?? 0; const maxHydraulics = myState?.maxHydraulic ?? Config.BASE_HYDRAULIC;
        const seeds = myState?.seedCount ?? 0;
        if (uiElements.carbonBar) uiElements.carbonBar.style.width = `${(carbon / maxCarbon) * 100}%`;
        if (uiElements.hydraulicBar) uiElements.hydraulicBar.style.width = maxHydraulics > 0 ? `${(hydraulics / maxHydraulics) * 100}%` : '0%';
        if (uiElements.carbonValueUI) uiElements.carbonValueUI.textContent = Math.floor(carbon);
        if (uiElements.hydraulicValueUI) uiElements.hydraulicValueUI.textContent = Math.floor(hydraulics);
        if (uiElements.seedCounterUI) uiElements.seedCounterUI.textContent = seeds;
    } else if (!isSpectator) {
         // Show default '--' if not spectator but state not ready
        if (uiElements.carbonValueUI) uiElements.carbonValueUI.textContent = '--';
        if (uiElements.hydraulicValueUI) uiElements.hydraulicValueUI.textContent = '--';
        if (uiElements.seedCounterUI) uiElements.seedCounterUI.textContent = '0';
        if (uiElements.carbonBar) uiElements.carbonBar.style.width = '0%';
        if (uiElements.hydraulicBar) uiElements.hydraulicBar.style.width = '0%';
    }

    // --- Update Info (Top Left) ---
    if (uiElements.dayCounterUI) uiElements.dayCounterUI.textContent = (phase !== 'loading') ? gameState.day : '-';
    if (uiElements.timeOfDayUI) {
        let timeText = '';
        if (phase === 'lobby' || phase === 'loading' || phase === 'ended') timeText = phase.charAt(0).toUpperCase() + phase.slice(1);
        else if (phase === 'countdown') timeText = 'Starting Soon!';
        else if (phase === 'playing') { if (gameState.isNight) timeText = 'Night'; else if (gameState.currentPeriodIndex >= 0) timeText = `Day Period ${gameState.currentPeriodIndex + 1}`; else timeText = 'Starting...'; }
        else timeText = 'Unknown Phase';
        uiElements.timeOfDayUI.textContent = timeText;
     }
    if (uiElements.cycleTimerUI) {
        let timeLeft = 0; if (phase === 'playing') { if (gameState.isNight) { const timeIntoNight = gameState.timeInCycle - Config.DAY_TOTAL_DURATION; timeLeft = Config.NIGHT_DURATION - timeIntoNight; } else if (gameState.currentPeriodIndex >= 0) { const timeIntoPeriod = gameState.timeInCycle - (gameState.currentPeriodIndex * Config.PERIOD_DURATION); timeLeft = Config.PERIOD_DURATION - timeIntoPeriod; } else { timeLeft = Config.PERIOD_DURATION - gameState.timeInCycle; } uiElements.cycleTimerUI.textContent = Math.max(0, Math.floor(timeLeft)); } else { uiElements.cycleTimerUI.textContent = '--'; }
     }
    if (uiElements.weatherStatusUI) {
        let weatherText = ''; if(phase === 'lobby' || phase === 'loading' || phase === 'ended' || phase === 'countdown') weatherText = '--'; else if (phase === 'playing') { if (gameState.isNight) weatherText = 'Night'; else weatherText = (gameState.currentLightMultiplier === Config.LIGHT_MULT_SUNNY) ? 'Sunny' : 'Cloudy'; if (gameState.isRaining) weatherText += ', Raining'; if (gameState.currentDroughtFactor > Config.DROUGHT_MULT_BASE + Config.DROUGHT_VARIATION * 0.6) weatherText += ' (Dry)'; else if (gameState.currentDroughtFactor < Config.DROUGHT_MULT_BASE - Config.DROUGHT_VARIATION * 0.6) weatherText += ' (Wet)'; } else weatherText = 'Initializing...'; uiElements.weatherStatusUI.textContent = weatherText;
     }

    // --- Update Lobby/Countdown UI (Top Left) ---
    if (uiElements.lobbyInfoPanel) {
        // Show only if NOT spectator AND in lobby/countdown
        const showLobby = !isSpectator && (phase === 'lobby' || phase === 'countdown');
        uiElements.lobbyInfoPanel.style.display = showLobby ? 'block' : 'none';
        if (showLobby) {
            if (uiElements.lobbyPlayerCountUI) uiElements.lobbyPlayerCountUI.textContent = Object.keys(allConnections).length; // Show total connections in lobby
            if (uiElements.startCountdownButton) { uiElements.startCountdownButton.disabled = (phase === 'countdown'); uiElements.startCountdownButton.textContent = (phase === 'countdown') ? 'Countdown...' : 'Start Countdown'; }
            if (uiElements.countdownTimerDisplayUI) { if (phase === 'countdown' && gameState.countdownTimer !== null) { uiElements.countdownTimerDisplayUI.textContent = `Starting in: ${gameState.countdownTimer}s`; uiElements.countdownTimerDisplayUI.style.display = 'block'; } else { uiElements.countdownTimerDisplayUI.style.display = 'none'; } }
         }
    }


    // --- Update Controls (Bottom Right) ---
    if (uiElements.controlPanelRight) {
        // Show controls ONLY if playing, alive, and NOT spectator
        const showControls = phase === 'playing' && myState && myState.isAlive && !isSpectator && !gameState.gameOver;
        uiElements.controlPanelRight.style.display = showControls ? 'flex' : 'none';
    }

    // --- Update Leaderboard / Player List (Top Right) ---
    if (uiElements.leaderboardTitleUI) {
         // Show total connections in lobby title, show active player count otherwise
         if (phase === 'lobby' || phase === 'countdown') uiElements.leaderboardTitleUI.textContent = `Lobby (${Object.keys(allConnections).length})`;
         else uiElements.leaderboardTitleUI.textContent = `Leaderboard (${aliveCount}/${playerCount})`; // Show Alive/Total Players
     }
    if (uiElements.leaderboardListUI) {
        let listHTML = '';
        // Filter out spectators BEFORE sorting and rendering the list
        const playersToDisplay = Object.values(allConnections).filter(p => !p.isSpectator);

        // Sort the filtered players
        playersToDisplay.sort((a, b) => {
            if (phase === 'lobby' || phase === 'countdown') {
                 return (a?.playerName || '').localeCompare(b?.playerName || ''); // Sort lobby alphabetically
            } else {
                return (b?.seedCount ?? 0) - (a?.seedCount ?? 0); // Sort game by seeds
            }
        });

        // Generate HTML only for non-spectators
        playersToDisplay.forEach(player => {
            const isMe = player.id === gameState.myId;
            let status = '';
            // Determine status based on phase (already filtered spectators)
            if (phase === 'playing' || phase === 'ended') status = player.isAlive ? '' : ' (Dead)';
            else if (phase === 'lobby' || phase === 'countdown') status = player.hasChosenSpawn ? ' (Placed)' : '';
            const name = player.playerName || `Player ${player.id.substring(0,4)}`;
            const seeds = (phase === 'playing' || phase === 'ended') ? `: ${player.seedCount} Seeds` : '';
            listHTML += `<li${isMe ? ' style="font-weight: bold;"' : ''}>${name}${status}${seeds}</li>`;
        });

        // Handle empty player list or only spectators connected
        if(listHTML === '' && phase !== 'loading') {
            if (Object.keys(allConnections).length > 0 && playerCount === 0) { // Check if connections exist but no players
                 listHTML = '<li>Only spectators connected...</li>';
            } else if (Object.keys(allConnections).length === 0) { // Check if truly empty
                 listHTML = '<li>Waiting for players...</li>';
            }
             // If listHTML is still empty here, it means players exist but loop didn't add them? Should not happen.
        }

        uiElements.leaderboardListUI.innerHTML = listHTML;
     }
}

--- FILE: server/package.json ---
{
  "name": "server",
  "version": "1.0.0",
  "main": "server.js",
  "type": "module",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "express": "^5.1.0",
    "socket.io": "^4.8.1"
  }
}

--- FILE: client/settings.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Island Canopy Sim - Settings</title>
    <link rel="stylesheet" href="style.css"> <!-- Shared style or create settings.css -->
     <style>
        /* Basic Settings Page Specific Styles */
         body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #333;
            color: #f0f0f0;
            font-family: sans-serif;
        }
        .settings-container {
            background-color: rgba(0, 0, 0, 0.6);
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 500px; /* Limit max width */
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
         h2 {
            text-align: center;
            color: #ccc;
            margin-bottom: 25px;
        }
        .setting-item {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding-bottom: 15px;
            border-bottom: 1px solid #444;
        }
        .setting-item label {
            flex-basis: 120px; /* Fixed width for labels */
            flex-shrink: 0;
            font-weight: bold;
            color: #bbb;
        }
        .setting-item input[type="text"],
        .setting-item input[type="color"] {
             padding: 8px;
             border: 1px solid #555;
             background-color: #444;
             color: #eee;
             border-radius: 4px;
             flex-grow: 1; /* Allow input to take space */
        }
         .setting-item input[type="color"] {
            min-width: 50px; /* Ensure color picker is usable */
            height: 40px;
            padding: 2px;
            flex-grow: 0; /* Don't let color picker grow too much */
        }
        .placeholder { /* Style for future feature area */
            border: 1px dashed #555;
            padding: 15px;
            text-align: center;
            color: #777;
            font-style: italic;
            margin-top: 10px;
            width: 100%; /* Take full width */
        }
         .button-group {
            margin-top: 30px;
            text-align: center;
        }
         button {
             padding: 10px 20px;
             font-size: 1em;
             cursor: pointer;
             border: none;
             border-radius: 5px;
             background-color: #008080; /* Teal */
             color: #f0f0f0;
             transition: background-color 0.3s ease;
         }
         button:hover {
             background-color: #009999; /* Darker Teal */
         }
    </style>
</head>
<body>
    <div class="settings-container">
        <h2>Settings</h2>

        <div class="setting-item">
            <label for="player-name">Player Name:</label>
            <input type="text" id="player-name" maxlength="16" placeholder="Treebard">
        </div>

        <div class="setting-item">
            <label for="leaf-color">Leaf Color:</label>
            <input type="color" id="leaf-color" value="#228B22">
        </div>

        <div class="setting-item">
            <label for="trunk-color">Trunk Color:</label>
            <input type="color" id="trunk-color" value="#8B4513">
        </div>

         <div class="setting-item">
             <label>Canopy Style:</label>
             <div class="placeholder">
                 Advanced Customization (Paint / Image Upload) Coming Soon!
             </div>
         </div>


        <div class="button-group">
            <button id="save-settings">Save & Back</button>
        </div>

    </div>

    <script src="settings.js"></script>
</body>
</html>

--- FILE: server/config.js ---
// server/config.js
// Game Constants & Configuration
// (Content copied from root config.js)

export const k_TA_LA_RATIO = 0.01; // Trunk cross-section area / Leaf Area ratio
export const INITIAL_LEAF_AREA = 5;
export const INITIAL_TRUNK_HEIGHT = 2;
export const INITIAL_CARBON = 100;
export const INITIAL_HYDRAULICS = 100; // Starting hydraulic safety value

export const MAX_CARBON = 200; // Maximum carbon storage capacity

// Hydraulic Buffer Configuration
export const BASE_HYDRAULIC = 50; // Base hydraulic safety buffer independent of size
export const HYDRAULIC_SCALE_PER_LA = 10; // Additional buffer capacity per unit of currentLA

export const PHOTOSYNTHESIS_RATE_PER_LA = 0.5; // Carbon gain per LA per second at max light & stomata=1
export const RESPIRATION_RATE_PER_LA = 0.02;   // Carbon loss per LA per second
export const RESPIRATION_RATE_PER_TRUNK_VOL = 0.01; // Carbon loss per trunk volume per second
export const TRANSPIRATION_RATE_PER_LA = 0.4; // Water loss rate per LA per sec at stomata=1, normal drought
export const HYDRAULIC_RECOVERY_RATE = 2;   // Base safety gain per second if stomata closed & water available
export const HYDRAULIC_DAMAGE_THRESHOLD = 20; // Below this, start taking damage
export const CROWN_DIEBACK_RATE = 0.05;      // Proportion of canopy LA potentially lost per second below threshold

export const GROWTH_COST_PER_LA = 5;        // Carbon cost to add 1 unit of LA (includes implicit trunk cost)
export const SEED_COST = 1;                 // Carbon cost per seed

// Time Structure Constants
export const PERIOD_DURATION = 7.0;         // Duration of each daytime weather period (seconds)
export const NUM_DAY_PERIODS = 3;           // Number of weather periods per day
export const DAY_TOTAL_DURATION = PERIOD_DURATION * NUM_DAY_PERIODS; // Total duration of all day periods
export const NIGHT_DURATION = 3.0;          // Duration of nighttime (seconds)
export const TOTAL_CYCLE_DURATION = DAY_TOTAL_DURATION + NIGHT_DURATION; // Full day-night cycle length
export const GROWTH_OFFSET_NIGHT = 1.5;     // Time into night when growth allocation occurs (seconds)

// Weather Probabilities & Effects
export const SUNNY_PROB = 2.0 / 3.0;        // Probability of a period being sunny (vs cloudy)
export const RAIN_PROB_IF_CLOUDY = 0.5;     // Probability of rain if a period is cloudy

export const LIGHT_MULT_SUNNY = 1.0;        // Photosynthesis multiplier for sunny weather
export const LIGHT_MULT_CLOUDY = 0.4;       // Photosynthesis multiplier for cloudy weather

export const DROUGHT_MULT_BASE = 1.0;       // Base drought factor (normal conditions)
export const DROUGHT_VARIATION = 0.4;       // Max +/- variation around the base for random drought factor

export const RAIN_RECOVERY_BONUS_MULT = 3.0; // Multiplier for HYDRAULIC_RECOVERY_RATE during rain
export const NIGHT_RAIN_HYDRAULIC_BOOST = 20.0; // Absolute hydraulic units added during rainy night (foliar uptake)

// Canopy Tile Configuration (Client might still need this, but server sim doesn't directly)
// export const CANOPY_TILE_GRID_SIZE = 10;
// export const CANOPY_TILE_THICKNESS = 0.1;

// Island Configuration (Client primarily needs this, server might for spawn validation)
// export const ISLAND_RADIUS = 50;
// export const WATER_LEVEL = 0;
// export const ISLAND_LEVEL = 0.1;

// Default Colors (Client only)
// export const DEFAULT_LEAF_COLOR = '#228B22';
// export const DEFAULT_TRUNK_COLOR = '#8B4513';

// Fog constants (Client only)
// export const FOG_DAY_NEAR = 50;
// export const FOG_DAY_FAR = 150;
// export const FOG_NIGHT_NEAR = 9999;
// export const FOG_NIGHT_FAR = 10000;

--- FILE: client/ui/gameOver.js ---
// client/ui/gameOver.js
import { gameState, getMyPlayerState } from '../gameState.js';
import { uiElements } from './elements.js';
// Import restart handler for the player button
import { handleRestart } from '../main.js';

/** Displays the Game Over modal. */
export function showGameOverUI() {
    console.log("UI: showGameOverUI called.");
    if (!uiElements.gameOverModal) { console.error("UI ERROR: gameOverModal element not found!"); return; }
    // Check optional elements safely
    if (!uiElements.gameOverReasonUI) { console.warn("UI element gameOverReasonUI missing."); }
    if (!uiElements.finalDayUI) { console.warn("UI element finalDayUI missing."); }
    if (!uiElements.finalSeedsUI) { console.warn("UI element finalSeedsUI missing."); }

    const myFinalState = getMyPlayerState();
    const finalDay = gameState.day;
    // Show N/A seeds if spectator or state missing
    const finalSeeds = (myFinalState && !gameState.isSpectator) ? myFinalState.seedCount : 'N/A';
    // Determine if this client is admin (by checking if admin controls exist on page)
    const isAdminView = !!document.getElementById('admin-controls'); // Check if admin controls are present

    // --- Populate Modal Content ---
    let reasonText = gameState.gameOverReason || "The game has ended!"; // Default reason
    if (gameState.winnerId) {
        const winnerState = gameState.players[gameState.winnerId];
        const winnerName = winnerState?.playerName || `Player ${gameState.winnerId.substring(0,4)}`;
        // Check if WE are the winner (and not a spectator)
        if (gameState.winnerId === gameState.myId && !gameState.isSpectator) { reasonText += `<br><strong>Congratulations, you had the most seeds!</strong>`; }
        else { reasonText += `<br>Winner: ${winnerName} with ${winnerState?.seedCount ?? '?'} seeds.`; }
    } else if (reasonText.indexOf("admin") === -1 && reasonText.indexOf("ended") > -1) { // Avoid adding "no winner" if admin ended it or just ended naturally
         reasonText += "<br>No winner declared.";
    }

    if(uiElements.gameOverReasonUI) uiElements.gameOverReasonUI.innerHTML = reasonText;

    // Show/Hide player-specific stats based on view type and spectator status
    const showPlayerStats = !isAdminView && !gameState.isSpectator; // Show stats only if regular player view AND not spectator

    if(uiElements.finalDayUI && uiElements.finalDayUI.parentElement) { // Check parent exists
        uiElements.finalDayUI.textContent = finalDay;
        uiElements.finalDayUI.parentElement.style.display = showPlayerStats ? 'block' : 'none'; // Show/hide the whole <p> tag
    }
    if(uiElements.finalSeedsUI && uiElements.finalSeedsUI.parentElement) { // Check parent exists
        uiElements.finalSeedsUI.textContent = finalSeeds;
         uiElements.finalSeedsUI.parentElement.style.display = showPlayerStats ? 'block' : 'none'; // Show/hide the whole <p> tag
    }

    // --- Show/Hide and Setup Buttons ---
    const adminCloseButton = document.getElementById('admin-close-modal'); // Reference admin specific button if it exists

    // Regular Player View: Show 'Play Again' (which reloads to '/')
    if (uiElements.restartButton) {
        uiElements.restartButton.style.display = showPlayerStats ? 'inline-block' : 'none';
        if (showPlayerStats) {
            // Attach listener (remove first to prevent duplicates if modal shown multiple times)
            uiElements.restartButton.removeEventListener('click', handleRestart);
            uiElements.restartButton.addEventListener('click', handleRestart);
        }
    }
    // Admin View: Show 'Close'
    if (adminCloseButton) {
        adminCloseButton.style.display = isAdminView ? 'inline-block' : 'none';
         if (isAdminView) {
             // Attach listener (remove first to prevent duplicates)
             adminCloseButton.removeEventListener('click', hideGameOverModal);
             adminCloseButton.addEventListener('click', hideGameOverModal);
         }
    } else if (isAdminView) {
         // Warn if admin view but expected button is missing
         console.warn("Admin view detected, but 'admin-close-modal' button not found in HTML.");
    }


    // Show the Modal itself
    uiElements.gameOverModal.classList.remove('hidden');
    console.log("UI: Game over modal made visible.");
}

/** Hides the Game Over modal. */
export function hideGameOverModal() {
    if (uiElements.gameOverModal) {
        uiElements.gameOverModal.classList.add('hidden');
        console.log("UI: Game over modal hidden.");
    } else { console.warn("UI: Tried to hide game over modal, element not found."); }
}

--- FILE: client/ui/updateAdmin.js ---
// client/ui/updateAdmin.js - UI Updater for Admin Panel
import { gameState } from '../gameState.js';
import * as Config from '../config.js';
import { uiElements } from './elements.js'; // Use cached elements

/** Updates admin UI elements based on the current gameState. */
export function updateUI() { // Renamed function locally
    // Wait until elements are cached, no need to wait for initial state like player view
    if (!uiElements.dayCounterUI) { return; }

    const phase = gameState.gamePhase;
    const allConnections = gameState.players;
    const playersOnly = Object.values(allConnections).filter(p => !p.isSpectator);
    const playerCount = playersOnly.length;
    const aliveCount = playersOnly.filter(p => p.isAlive).length;

    // --- Update Info (Top Left) ---
    // (Same as regular update.js)
    if (uiElements.dayCounterUI) uiElements.dayCounterUI.textContent = (phase !== 'loading') ? gameState.day : '-';
    if (uiElements.timeOfDayUI) { let timeText = ''; if (phase === 'lobby' || phase === 'loading' || phase === 'ended') timeText = phase.charAt(0).toUpperCase() + phase.slice(1); else if (phase === 'countdown') timeText = 'Starting Soon!'; else if (phase === 'playing') { if (gameState.isNight) timeText = 'Night'; else if (gameState.currentPeriodIndex >= 0) timeText = `Day Period ${gameState.currentPeriodIndex + 1}`; else timeText = 'Starting...'; } else timeText = 'Unknown Phase'; uiElements.timeOfDayUI.textContent = timeText; }
    if (uiElements.cycleTimerUI) { let timeLeft = 0; if (phase === 'playing') { if (gameState.isNight) { const timeIntoNight = gameState.timeInCycle - Config.DAY_TOTAL_DURATION; timeLeft = Config.NIGHT_DURATION - timeIntoNight; } else if (gameState.currentPeriodIndex >= 0) { const timeIntoPeriod = gameState.timeInCycle - (gameState.currentPeriodIndex * Config.PERIOD_DURATION); timeLeft = Config.PERIOD_DURATION - timeIntoPeriod; } else { timeLeft = Config.PERIOD_DURATION - gameState.timeInCycle; } uiElements.cycleTimerUI.textContent = Math.max(0, Math.floor(timeLeft)); } else { uiElements.cycleTimerUI.textContent = '--'; } }
    if (uiElements.weatherStatusUI) { let weatherText = ''; if(phase === 'lobby' || phase === 'loading' || phase === 'ended' || phase === 'countdown') weatherText = '--'; else if (phase === 'playing') { if (gameState.isNight) weatherText = 'Night'; else weatherText = (gameState.currentLightMultiplier === Config.LIGHT_MULT_SUNNY) ? 'Sunny' : 'Cloudy'; if (gameState.isRaining) weatherText += ', Raining'; if (gameState.currentDroughtFactor > Config.DROUGHT_MULT_BASE + Config.DROUGHT_VARIATION * 0.6) weatherText += ' (Dry)'; else if (gameState.currentDroughtFactor < Config.DROUGHT_MULT_BASE - Config.DROUGHT_VARIATION * 0.6) weatherText += ' (Wet)'; } else weatherText = 'Initializing...'; uiElements.weatherStatusUI.textContent = weatherText; }

    // --- Update Lobby/Countdown Info (Top Left) ---
    // (Same as regular update.js, but button is hidden via HTML)
    if (uiElements.lobbyInfoPanel) {
        const showLobby = (phase === 'lobby' || phase === 'countdown');
        uiElements.lobbyInfoPanel.style.display = showLobby ? 'block' : 'none';
        if (showLobby) {
            if (uiElements.lobbyPlayerCountUI) uiElements.lobbyPlayerCountUI.textContent = Object.keys(allConnections).length;
             // No start button logic needed here
            if (uiElements.countdownTimerDisplayUI) { if (phase === 'countdown' && gameState.countdownTimer !== null) { uiElements.countdownTimerDisplayUI.textContent = `Starting in: ${gameState.countdownTimer}s`; uiElements.countdownTimerDisplayUI.style.display = 'block'; } else { uiElements.countdownTimerDisplayUI.style.display = 'none'; } }
        }
    }

    // --- Update Leaderboard / Player List (Top Right) ---
    // (Same as regular update.js - shows non-spectators)
    if (uiElements.leaderboardTitleUI) { if (phase === 'lobby' || phase === 'countdown') uiElements.leaderboardTitleUI.textContent = `Lobby (${Object.keys(allConnections).length})`; else uiElements.leaderboardTitleUI.textContent = `Leaderboard (${aliveCount}/${playerCount})`; }
    if (uiElements.leaderboardListUI) { let listHTML = ''; const playersToDisplay = Object.values(allConnections).filter(p => !p.isSpectator); playersToDisplay.sort((a, b) => { if (phase === 'lobby' || phase === 'countdown') { return (a?.playerName || '').localeCompare(b?.playerName || ''); } else { return (b?.seedCount ?? 0) - (a?.seedCount ?? 0); } }); playersToDisplay.forEach(player => { const isMe = player.id === gameState.myId; let status = ''; if (player.isSpectator) status = ' (Spectating)'; else if (phase === 'playing' || phase === 'ended') status = player.isAlive ? '' : ' (Dead)'; else if (phase === 'lobby' || phase === 'countdown') status = player.hasChosenSpawn ? ' (Placed)' : ''; const name = player.playerName || `Player ${player.id.substring(0,4)}`; const seeds = (phase === 'playing' || phase === 'ended') ? `: ${player.seedCount} Seeds` : ''; listHTML += `<li${isMe ? ' style="font-weight: bold;"' : ''}>${name}${status}${seeds}</li>`; }); if(listHTML === '' && phase !== 'loading') { if (Object.keys(allConnections).length > 0 && playerCount === 0) listHTML = '<li>Only spectators connected...</li>'; else if (Object.keys(allConnections).length === 0) listHTML = '<li>Waiting for server...</li>'; } uiElements.leaderboardListUI.innerHTML = listHTML; }

    // No need to update player status bars or controls for admin view
}

--- FILE: server/game/GameState.js ---
// server/game/GameState.js
import * as Config from '../config.js'; // Use server config

// --- Core State Variables ---
let globalGameState = {
    day: 1,
    timeInCycle: 0.0,
    currentPeriodIndex: -1, // -1: Initial/Night, 0-2: Day periods
    isNight: false,
    currentLightMultiplier: Config.LIGHT_MULT_SUNNY, // Initial assumption
    currentDroughtFactor: Config.DROUGHT_MULT_BASE,
    isRaining: false,
    gamePhase: 'lobby', // 'lobby', 'countdown', 'playing', 'ended'
    countdownTimer: null, // Holds remaining countdown seconds, or null
};
let players = {}; // { socketId: playerData }

// --- State Management Functions ---

/** Creates initial state for a new player. */
function initializePlayerState(socketId) {
    const initialLA = Config.INITIAL_LEAF_AREA;
    const baseHeight = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
    const maxHydraulic = Config.BASE_HYDRAULIC + Config.HYDRAULIC_SCALE_PER_LA * initialLA;
    return {
        id: socketId,
        // --- Attributes ---
        playerName: `Player_${socketId.substring(0, 4)}`,
        leafColor: '#228B22', trunkColor: '#8B4513',
        spawnPoint: { x: 0, y: baseHeight, z: 0 }, // Default, updated later
        isAlive: false, // Starts not alive
        hasChosenSpawn: false,
        isSpectator: false, // Defaults to false
        // --- Resources ---
        carbonStorage: Config.INITIAL_CARBON, hydraulicSafety: Math.min(Config.INITIAL_HYDRAULICS, maxHydraulic), maxHydraulic: maxHydraulic,
        // --- Size & Structure ---
        currentLA: initialLA, effectiveLA: initialLA, trunkHeight: Config.INITIAL_TRUNK_HEIGHT,
        trunkWidth: Math.sqrt(initialLA * Config.k_TA_LA_RATIO), trunkDepth: Math.sqrt(initialLA * Config.k_TA_LA_RATIO),
        // --- Status & Output ---
        seedCount: 0, damagedLAPercentage: 0,
        // --- Inputs (Server authoritative) ---
        stomatalConductance: 0.5, lastSavingsPercent: 50, lastGrowthRatioPercent: 50,
        // --- Internal Sim State ---
        foliarUptakeAppliedThisNight: false, growthAppliedThisCycle: false,
    };
}

/** Adds a new player to the state. */
export function addPlayer(socketId) {
    if (!players[socketId]) {
        players[socketId] = initializePlayerState(socketId);
        console.log(`GameState: Added player ${socketId}. Total: ${Object.keys(players).length}`);
    } else {
        console.warn(`GameState: Player ${socketId} already exists.`);
    }
}

/** Removes a player from the state. */
export function removePlayer(socketId) {
    if (players[socketId]) {
        delete players[socketId];
        console.log(`GameState: Removed player ${socketId}. Remaining: ${Object.keys(players).length}`);
        return true;
    }
    return false;
}

/** Retrieves state for a specific player. */
export function getPlayerState(socketId) {
    return players[socketId] || null;
}

/** Retrieves the entire players object. */
export function getAllPlayers() {
    return players;
}

/** Retrieves the global game state object. */
export function getGlobalState() {
    return globalGameState;
}

/** Updates specific properties of the global state. */
export function updateGlobalState(updates) {
     Object.assign(globalGameState, updates);
}

/** Sets the current game phase. */
export function setGamePhase(phase) {
    if (['lobby', 'countdown', 'playing', 'ended'].includes(phase)) {
        if (globalGameState.gamePhase !== phase) {
             console.log(`GameState: Changing phase from ${globalGameState.gamePhase} to ${phase}`);
             globalGameState.gamePhase = phase;
             if (phase !== 'countdown') globalGameState.countdownTimer = null; // Reset timer unless entering countdown
        }
    } else { console.error(`GameState: Invalid phase: ${phase}`); }
}

/** Resets global state variables to defaults. */
export function resetGlobalStateValues() {
     console.log("GameState: Resetting global values...");
     Object.assign(globalGameState, {
        day: 1, timeInCycle: 0.0, currentPeriodIndex: -1, isNight: false,
        currentLightMultiplier: Config.LIGHT_MULT_SUNNY, currentDroughtFactor: Config.DROUGHT_MULT_BASE,
        isRaining: false, gamePhase: 'lobby', countdownTimer: null
     });
}

--- FILE: client/ui/controlsHandlers.js ---
// client/ui/controlsHandlers.js
import { uiElements } from './elements.js';
// Import the socket instance from main.js
import { socket } from '../main.js';
// We no longer directly modify gameState here
// import { gameState } from '../gameState.js';

/**
 * Handles changes to the Stomata Slider input.
 * Updates the UI display and sends the new value to the server.
 * @param {Event} e - The input event object.
 */
export function handleStomataChange(e) {
    const newValue = parseFloat(e.target.value);

    // Update UI display immediately for responsiveness
    if (uiElements.stomataValueUI) {
        uiElements.stomataValueUI.textContent = `${Math.round(newValue * 100)}%`;
    }

    // --- Send update to server ---
    if (socket && socket.connected) {
        // console.log(`UI->Server: Emitting updateStomata: ${newValue}`); // Debug log
        socket.emit('updateStomata', { value: newValue });
    } else {
        console.warn("Socket not connected, cannot send stomata update.");
    }

    // --- REMOVE direct gameState modification ---
    // gameState.stomatalConductance = newValue;
}

/**
 * Handles changes to EITHER the Savings or Growth Ratio sliders.
 * Updates the UI display and sends the new allocation intent to the server.
 */
export function handleAllocationSliderChange() {
    // Check required elements exist
    if (!uiElements.savingsSlider || !uiElements.growthRatioSlider ||
        !uiElements.savingsPercentageUI || !uiElements.growthRatioPercentageUI) {
            console.warn("Allocation slider UI elements missing in handler.");
            return;
        }

    // Read current values from both sliders
    const savingsPercent = parseInt(uiElements.savingsSlider.value) || 0;
    const growthRatioPercent = parseInt(uiElements.growthRatioSlider.value) || 0;

    // Update percentage displays immediately
    uiElements.savingsPercentageUI.textContent = `${savingsPercent}%`;
    const seedRatioPercent = 100 - growthRatioPercent;
    uiElements.growthRatioPercentageUI.textContent = `${growthRatioPercent}%/${seedRatioPercent}%`;

    // --- Send update to server ---
    if (socket && socket.connected) {
         // console.log(`UI->Server: Emitting updateAllocation: Savings=${savingsPercent}, GrowthRatio=${growthRatioPercent}`); // Debug log
         socket.emit('updateAllocation', {
             savings: savingsPercent,
             growthRatio: growthRatioPercent
         });
    } else {
         console.warn("Socket not connected, cannot send allocation update.");
    }

    // --- REMOVE direct gameState modification ---
    // gameState.lastSavingsPercent = savingsPercent;
    // gameState.lastGrowthRatioPercent = growthRatioPercent;
}

--- FILE: client/config.js ---
// config.js (Project Root - Client-Side Config)

// --- UI & Display Constants ---
export const MAX_CARBON = 200; // Used for UI bar calculation
export const BASE_HYDRAULIC = 50; // Fallback for UI bar if player state not ready

// --- Rendering & Visual Defaults ---
export const INITIAL_TRUNK_HEIGHT = 2; // Used as fallback for camera target
export const ISLAND_RADIUS = 50; // <<-- Ensure this is present and correct
export const WATER_LEVEL = 0; // <<-- Ensure this is present and correct
export const ISLAND_LEVEL = 0.1; // Needed for positioning trees? Check tree.js usage.
export const DEFAULT_LEAF_COLOR = '#228B22'; // Forest Green - Used if server doesn't send color? Or for material fallback.
export const DEFAULT_TRUNK_COLOR = '#8B4513'; // Saddle Brown - Used if server doesn't send color? Or for material fallback.

// --- Canopy Tile Configuration (Client needs for rendering) ---
export const CANOPY_TILE_GRID_SIZE = 10;
export const CANOPY_TILE_THICKNESS = 0.1;

// --- Tree Structure Ratio (Client needs for rendering calculations) ---
export const k_TA_LA_RATIO = 0.01; // Trunk cross-section area / Leaf Area ratio
export const INITIAL_LEAF_AREA = 5; // Used in tree.js for calculating initial tile size

// --- Environment Visuals (Client needs for environment.js defaults/calcs) ---
export const PERIOD_DURATION = 7.0;
export const NUM_DAY_PERIODS = 3;
export const DAY_TOTAL_DURATION = PERIOD_DURATION * NUM_DAY_PERIODS;
export const NIGHT_DURATION = 3.0;
export const TOTAL_CYCLE_DURATION = DAY_TOTAL_DURATION + NIGHT_DURATION;
export const LIGHT_MULT_SUNNY = 1.0;
export const LIGHT_MULT_CLOUDY = 0.4;
export const DROUGHT_MULT_BASE = 1.0;
export const DROUGHT_VARIATION = 0.4;


// NOTE: Simulation rates, costs, probabilities, etc., are now primarily server-side
// in server/config.js and should NOT be duplicated here unless specifically
// needed for some client-side prediction or display logic (which we currently don't have).

--- FILE: server/network/connection.js ---
// server/network/connection.js
import { addPlayer, removePlayer, getGlobalState, getAllPlayers, setGamePhase, getPlayerState, updateGlobalState } from '../game/GameState.js';
import { getFullGameStateSnapshot, broadcastGameState } from './stateBroadcaster.js';
import { stopSimulation, startGame as triggerServerStartGame, adminSockets } from '../server.js';
// Import resetGame explicitly ONLY if needed elsewhere, endGame now triggers reset
import { resetGame, startLobbyCountdown, cancelLobbyCountdown, endGame } from '../game/gameLogic.js';
import * as Config from '../config.js';

const MIN_SPAWN_DISTANCE_SQ = 4 * 4;

/** Sets up event listeners for a newly connected socket. */
export function handleConnection(socket, io) { /* ... connection setup ... */
    console.log(`Connection: Player connected: ${socket.id}`);
    socket.on('adminAuthenticate', (data) => { /* ... admin auth logic ... */ const serverAdminPassword = process.env.ADMIN_PASSWORD || "defaultAdminPass123"; if (data?.password && data.password === serverAdminPassword) { console.log(`Connection: Admin auth OK for ${socket.id}`); adminSockets.add(socket.id); socket.emit('adminAuthResult', { success: true }); handleJoinRequest(socket, io, { intent: 'spectate' }, true); setupInputAndActionListeners(socket, io); } else { console.warn(`Connection: Admin auth FAILED for ${socket.id}`); socket.emit('adminAuthResult', { success: false, reason: 'Invalid Password' }); setTimeout(() => socket.disconnect(true), 1000); } });
    const regularJoinListener = (data) => { if (adminSockets.has(socket.id)) { socket.off('playerJoinRequest', regularJoinListener); return; } handleJoinRequest(socket, io, data, false); setupInputAndActionListeners(socket, io); };
    socket.on('playerJoinRequest', regularJoinListener);
    socket.on('disconnect', () => { handleDisconnect(socket, io); });
} // End of handleConnection


/** Handles the logic AFTER receiving 'playerJoinRequest' or admin auth */
function handleJoinRequest(socket, io, data, isAdmin) { /* ... join request logic ... */
    const intent = isAdmin ? 'spectate' : (data?.intent || 'single'); const playerName = data?.playerName; console.log(`Join Handling: Processing join for ${socket.id}. Intent: ${intent}, Admin: ${isAdmin}`); if (getPlayerState(socket.id)) { return; } addPlayer(socket.id); const playerState = getPlayerState(socket.id); if (!playerState) { socket.disconnect(true); return; } if (playerName && !isAdmin) playerState.playerName = playerName.substring(0, 16); playerState.isSpectator = (intent === 'spectate' || isAdmin); if(isAdmin) playerState.playerName = `ADMIN_${socket.id.substring(0,4)}`; const currentPhase = getGlobalState().gamePhase; const playerCount = Object.keys(getAllPlayers()).length; const isFirstPlayer = (playerCount === 1);
    if (intent === 'single' && !isAdmin) { if (isFirstPlayer && (currentPhase === 'lobby' || currentPhase === 'ended')) { console.log(`Join Handling: Player ${socket.id} starting single.`); resetGame(); const freshPlayerState = getPlayerState(socket.id) || addPlayer(socket.id); if (freshPlayerState) { freshPlayerState.isAlive = true; freshPlayerState.isSpectator = false; const baseHeight = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1; freshPlayerState.spawnPoint = { x: 0, y: baseHeight, z: 0 }; setGamePhase('playing'); console.log(`Join Handling: Player ${socket.id} marked alive.`); broadcastGameState(io, getAllPlayers(), getGlobalState()); triggerServerStartGame(); } } else { console.warn(`Join Handling: Player ${socket.id} req single, cannot start. Observer.`); playerState.isAlive = false; playerState.isSpectator = true; socket.emit('gameStateUpdate', getFullGameStateSnapshot(getAllPlayers(), getGlobalState())); }
    } else { if (currentPhase === 'playing' || currentPhase === 'countdown') { console.log(`Join Handling: ${socket.id} (Admin:${isAdmin}) joining mid-game/countdown. Observer.`); playerState.isAlive = false; } else { console.log(`Join Handling: ${socket.id} (Admin:${isAdmin}) joining lobby/ended. Phase: ${currentPhase}`); playerState.isAlive = false; /* Reset handled by endGame now */ } socket.emit('gameStateUpdate', getFullGameStateSnapshot(getAllPlayers(), getGlobalState())); broadcastGameState(io, getAllPlayers(), getGlobalState()); }
}


/** Sets up listeners for controls AND actions coming from the client */
function setupInputAndActionListeners(socket, io) { /* ... input/action listeners ... */
     socket.on('updateStomata', (data) => { const ps = getPlayerState(socket.id); if (ps && ps.isAlive && !ps.isSpectator && typeof data?.value === 'number') ps.stomatalConductance = Math.max(0, Math.min(1, data.value)); });
     socket.on('updateAllocation', (data) => { const ps = getPlayerState(socket.id); if (ps && ps.isAlive && !ps.isSpectator && typeof data?.savings === 'number' && typeof data?.growthRatio === 'number') { ps.lastSavingsPercent = Math.max(0, Math.min(100, data.savings)); ps.lastGrowthRatioPercent = Math.max(0, Math.min(100, data.growthRatio)); } });
     socket.on('requestStartCountdown', () => { console.log(`Conn: Received 'requestStartCountdown' from ${socket.id}`); const ps = getPlayerState(socket.id); const phase = getGlobalState().gamePhase; if (ps && !ps.isSpectator && phase === 'lobby') startLobbyCountdown(io); else console.log(`Conn: Ignoring start countdown. Phase:${phase}, Player:${!!ps}, Spectator:${ps?.isSpectator}`); });
     socket.on('selectSpawnPoint', (coords) => { /* ... spawn selection logic ... */ const ps = getPlayerState(socket.id); const phase = getGlobalState().gamePhase; const players = getAllPlayers(); console.log(`Conn: Received 'selectSpawnPoint' from ${socket.id}:`, coords); if (!ps || ps.isSpectator || !coords || typeof coords.x !== 'number' || typeof coords.z !== 'number') { socket.emit('spawnPointInvalid', { reason: 'Invalid data/spectator.' }); return; } if (phase !== 'lobby') { socket.emit('spawnPointInvalid', { reason: 'Can only select in lobby.' }); return; } if (ps.hasChosenSpawn) { socket.emit('spawnPointInvalid', { reason: 'Already chosen.' }); return; } const islandRadius = Config.ISLAND_RADIUS || 50; const distSqFromCenter = coords.x**2 + coords.z**2; if (distSqFromCenter > islandRadius*islandRadius) { socket.emit('spawnPointInvalid', { reason: 'Outside island.' }); return; } let tooClose = false; for (const op of Object.values(players)) { if (op.id !== socket.id && op.hasChosenSpawn) { const dx = coords.x - op.spawnPoint.x; const dz = coords.z - op.spawnPoint.z; const distSq = dx*dx + dz*dz; if (distSq < MIN_SPAWN_DISTANCE_SQ) { tooClose = true; break; } } } if (tooClose) { socket.emit('spawnPointInvalid', { reason: 'Too close.' }); return; } console.log(`Conn: Spawn point for ${socket.id} confirmed.`); const baseHeight = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1; ps.spawnPoint = { x: coords.x, y: baseHeight, z: coords.z }; ps.hasChosenSpawn = true; socket.emit('spawnPointConfirmed', ps.spawnPoint); broadcastGameState(io, players, getGlobalState()); });
     socket.on('adminForceStart', () => { if (adminSockets.has(socket.id)) { console.log(`ADMIN COMMAND: Force Start from ${socket.id}`); const phase = getGlobalState().gamePhase; if (phase === 'lobby' || phase === 'countdown') { cancelLobbyCountdown(); triggerServerStartGame(); showMessageToAll(io, 'Admin forced game start!', 'warning'); } else { console.log("ADMIN: Cannot Force Start, invalid phase."); socket.emit('serverMessage', { text: 'Cannot force start now.', type: 'error'}); } } else { console.warn(`Unauthorized adminForceStart from ${socket.id}`); } });
     socket.on('adminForceEnd', () => { if (adminSockets.has(socket.id)) { console.log(`ADMIN COMMAND: Force End from ${socket.id}`); const phase = getGlobalState().gamePhase; if (phase === 'playing' || phase === 'countdown') { endGame(io, getAllPlayers(), getGlobalState(), "Game ended by admin."); showMessageToAll(io, 'Admin ended the game.', 'warning'); } else { console.log("ADMIN: Cannot Force End, invalid phase."); socket.emit('serverMessage', { text: 'Cannot force end now.', type: 'error'}); } } else { console.warn(`Unauthorized adminForceEnd from ${socket.id}`); } });
     socket.on('adminResetCountdown', () => { if (adminSockets.has(socket.id)) { console.log(`ADMIN COMMAND: Reset Countdown from ${socket.id}`); const phase = getGlobalState().gamePhase; if (phase === 'countdown') { cancelLobbyCountdown(); startLobbyCountdown(io); showMessageToAll(io, 'Admin reset the countdown.', 'info'); } else if (phase === 'lobby') { startLobbyCountdown(io); showMessageToAll(io, 'Admin started the countdown.', 'info'); } else { console.log("ADMIN: Cannot Reset/Start Countdown, invalid phase."); socket.emit('serverMessage', { text: 'Cannot reset/start countdown now.', type: 'error'}); } } else { console.warn(`Unauthorized adminResetCountdown from ${socket.id}`); } });
} // End of setupInputAndActionListeners


/** Handles socket disconnection */
function handleDisconnect(socket, io) {
     console.log(`Connection: Player disconnected: ${socket.id}`);
     if (adminSockets.has(socket.id)) { adminSockets.delete(socket.id); console.log(`Connection: Removed ${socket.id} from admins.`); }
     const wasRemoved = removePlayer(socket.id);
     if (wasRemoved) {
         io.emit('playerDisconnected', socket.id);
         broadcastGameState(io, getAllPlayers(), getGlobalState()); // Broadcast updated player list

         const remainingPlayerCount = Object.keys(getAllPlayers()).length;
         const currentPhase = getGlobalState().gamePhase;

         // *** REMOVE resetGame call from here ***
         // if (remainingPlayerCount === 0) {
         //     console.log("Connection: Last player disconnected. Resetting game.");
         //     resetGame(); // Let endGame handle reset now
         // } else
         if (currentPhase === 'countdown') {
              console.log("Connection: Player left during countdown. Continues.");
              // Logic to cancel if needed based on player count can remain
              const activePlayerCount = Object.keys(getAllPlayers()).filter(id => !getPlayerState(id)?.isSpectator).length;
              if(activePlayerCount === 0 && remainingPlayerCount > 0){ // Only spectators left
                   console.log("Connection: Only spectators left in countdown. Resetting to lobby.");
                   cancelLobbyCountdown();
                   setGamePhase('lobby');
                   broadcastGameState(io, getAllPlayers(), getGlobalState());
              }
         }
     } else { console.warn(`Connection: Disconnect for ${socket.id}, player not found.`); }
}

/** Helper to broadcast a message to all clients */
function showMessageToAll(io, text, type = 'info') {
    io.emit('serverMessage', { text, type });
}

--- FILE: server/server.js ---
// server/server.js (Main Entry Point)

import express from 'express';
import http from 'http';
import { Server as SocketIOServer } from 'socket.io';
import path from 'path';
import { fileURLToPath } from 'url';

// Import Server Modules
import { handleConnection } from './network/connection.js';
import { updateSimulationTick } from './game/simulation.js';
import { broadcastGameState, getFullGameStateSnapshot } from './network/stateBroadcaster.js';
// Import state getters/setters needed here
import { getGlobalState, getAllPlayers, setGamePhase, getPlayerState } from './game/GameState.js';
import { resetGame } from './game/gameLogic.js'; // Import resetGame
import * as Config from './config.js'; // Import server config for startGame

// --- Configuration & Setup ---
const PORT = process.env.PORT || 3000;
const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || "defaultAdminPass123"; // Use env var or fallback
const TICK_RATE = 20; // Updates per second
const TICK_INTERVAL_MS = 1000 / TICK_RATE;

// ES Module path setup
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const clientPath = path.join(__dirname, '..', 'client'); // Path to client files

// Express and HTTP Server
const app = express();
const httpServer = http.createServer(app);

// Socket.IO Server
const io = new SocketIOServer(httpServer);

// --- Simulation Loop State ---
let simulationInterval = null;
let lastTickTime = Date.now();

// --- Admin Tracking (Simple Set for authorized socket IDs) ---
// Export so connection handler can potentially use it or add to it
export const adminSockets = new Set();

// --- Express Routes & Static Files ---
console.log(`Serving static files from: ${clientPath}`);
app.use(express.static(clientPath));

app.get('/', (req, res) => { res.sendFile(path.join(clientPath, 'index.html')); });
app.get('/game', (req, res) => { res.sendFile(path.join(clientPath, 'game.html')); });
app.get('/settings', (req, res) => { res.sendFile(path.join(clientPath, 'settings.html')); });

// +++ Admin Route +++
app.get('/admin', (req, res) => {
    const providedPassword = req.query.pw; // Get password from query param ?pw=...
    if (providedPassword && providedPassword === ADMIN_PASSWORD) {
        console.log("Admin access granted via HTTP route.");
        // Serve the admin HTML page
        res.sendFile(path.join(clientPath, 'admin.html'));
        // Note: We mark the socket as admin upon WebSocket authentication now
    } else {
        console.log("Admin access denied. Incorrect or missing password.");
        res.status(403).send('Forbidden: Incorrect Admin Password');
    }
});

// --- Socket.IO Setup ---
io.on('connection', (socket) => {
    handleConnection(socket, io); // Delegate connection handling
});

// --- Main Simulation Loop Function ---
function runGameTick() {
    const now = Date.now();
    // Prevent large deltaTime jumps if server lags or loop stops/restarts
    const deltaTime = Math.min((now - lastTickTime) / 1000.0, 1.0 / TICK_RATE * 5); // Max delta = 5 ticks
    lastTickTime = now;

    // Get current state
    const globalState = getGlobalState();
    const players = getAllPlayers();

    // 1. Update Game Simulation State (only if playing)
    if (globalState.gamePhase === 'playing') {
        updateSimulationTick(deltaTime, io); // Pass io instance
    }

    // 2. Broadcast Updated State to Clients (always broadcast)
    broadcastGameState(io, players, globalState);
}

// --- Simulation Control Functions (Exported for use by other modules) ---

/**
 * Starts the main game simulation loop and transitions players to the playing state.
 * Ensures players are marked alive and have spawn points assigned if needed.
 * Idempotent: safe to call even if game is already playing.
 */
export function startGame() {
    const globalState = getGlobalState();
    const players = getAllPlayers();

    // --- Phase Check & Set ---
    // Allow starting from 'lobby', 'countdown', or if already 'playing'
    if (!['lobby', 'countdown', 'playing'].includes(globalState.gamePhase)) {
        console.warn(`Server: startGame called with invalid phase: ${globalState.gamePhase}. Aborting.`);
        return;
    }
    // Ensure phase is set to 'playing'
    if (globalState.gamePhase !== 'playing') {
         console.log(`Server: startGame - Setting phase to 'playing' (was ${globalState.gamePhase}).`);
         setGamePhase('playing');
    } else {
        console.log("Server: startGame called when already playing (ensuring loop runs).");
    }

    // --- Prepare Players ---
    let playersToStartCount = 0;
    let activePlayersFound = false; // Track if we find anyone to actually start
    Object.values(players).forEach(p => {
        const playerState = getPlayerState(p.id); // Get potentially updated state
        if (playerState) {
            if (playerState.isSpectator) { // Skip spectators
                playerState.isAlive = false; return;
            }
            activePlayersFound = true; // Found at least one non-spectator

            // Assign spawn ONLY if they haven't chosen AND game wasn't already playing
            if (!playerState.hasChosenSpawn && globalState.gamePhase !== 'playing') { // Condition modified slightly, maybe not needed if logic ensures phase is now 'playing'? Let's keep for safety on first start.
                 console.warn(`Server: Player ${p.id} starting without chosen spawn! Assigning default offset.`);
                 const activePlayersList = Object.values(players).filter(pl => !pl.isSpectator);
                 const index = activePlayersList.findIndex(ap => ap.id === p.id);
                 const activePlayerCount = activePlayersList.length || 1;
                 const angle = (index / activePlayerCount) * Math.PI * 2; const radius = 5 + Math.random() * 5;
                 const baseHeight = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
                 playerState.spawnPoint = { x: radius * Math.cos(angle), y: baseHeight, z: radius * Math.sin(angle) };
                 playerState.hasChosenSpawn = true;
             } else if (!playerState.spawnPoint) {
                 // Safety: If somehow spawnPoint is missing even if chosen, assign default
                 console.error(`Server: Player ${p.id} missing spawnPoint in startGame! Assigning default.`);
                  const baseHeight = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
                  playerState.spawnPoint = { x: 0, y: baseHeight, z: 0 }; // Fallback to center
             }

             // Mark player alive
             if (!playerState.isAlive) { playerState.isAlive = true; console.log(`Server: Marking player ${p.id} alive in startGame.`); }
             console.log(`Server: Player ${p.id} ready/starting at spawn: (${p.spawnPoint?.x?.toFixed(1)}, ${p.spawnPoint?.z?.toFixed(1)})`);
             playersToStartCount++;
        }
    });

    // --- Validation & Simulation Start ---
    if (!activePlayersFound && Object.keys(players).length > 0) { // If only spectators were connected
        console.log("Server: startGame - Only spectators present. Resetting to lobby.");
        resetGame(); return;
    }
    if (playersToStartCount === 0 && activePlayersFound) { // If active players exist but none ended up marked alive?
         console.error("Server: startGame - Active players found, but none started? Resetting.");
         resetGame(); return;
    }

    // Start the interval ONLY if it's not already running
    if (!simulationInterval) {
        console.log(`Server: Starting simulation loop interval for ${playersToStartCount} active players.`);
        lastTickTime = Date.now();
        simulationInterval = setInterval(runGameTick, TICK_INTERVAL_MS);
    } else {
        console.log("Server: Simulation loop already running.");
    }

    // Broadcast the state immediately after setup
    broadcastGameState(io, players, getGlobalState());
}


/** Stops the main game simulation loop. */
export function stopSimulation() {
    if (simulationInterval) {
        console.log("Server: Stopping simulation loop interval.");
        clearInterval(simulationInterval);
        simulationInterval = null;
    }
    // else { console.log("Server: Simulation loop already stopped."); } // Reduce noise
}

// --- Start HTTP Server ---
httpServer.listen(PORT, () => {
    console.log(`Server listening on port ${PORT}`);
    console.log(`Admin access requires query param: ?pw=${ADMIN_PASSWORD}`); // Log hint
    resetGame(); // Ensure initial state is lobby on server start
});

--- FILE: client/index.js ---
// client/index.js (Landing Page Logic)

document.addEventListener('DOMContentLoaded', () => {
    const singlePlayerButton = document.getElementById('start-single-player');
    const multiPlayerButton = document.getElementById('start-multi-player');
    const spectateButton = document.getElementById('spectate-game'); // Get spectate button
    const settingsButton = document.getElementById('open-settings');

    // Function to set mode and navigate
    function startGame(mode) {
        console.log(`Index: Setting mode to ${mode} and navigating to /game`);
        sessionStorage.setItem('gameModeIntent', mode); // Store intent
        window.location.href = '/game'; // Navigate to the game page
    }

    if (singlePlayerButton) {
        singlePlayerButton.addEventListener('click', () => {
            startGame('single');
        });
    }

    if (multiPlayerButton) {
        multiPlayerButton.disabled = false; // Ensure enabled
        multiPlayerButton.textContent = 'Multiplayer';
        multiPlayerButton.addEventListener('click', () => {
             startGame('multi');
        });
    }

    // Add listener for spectate button
    if (spectateButton) {
         spectateButton.addEventListener('click', () => {
             startGame('spectate');
         });
    }

    if (settingsButton) {
        settingsButton.addEventListener('click', () => {
            console.log("Navigating to Settings...");
            window.location.href = '/settings';
        });
    }
});

--- FILE: client/tree.js ---
// client/tree.js
import * as THREE from 'three';
import * as Config from './config.js';
import { scene } from './sceneSetup.js';
import { gameState } from './gameState.js';

// --- Shared Materials ---
// These might need to become non-shared if we implement player colors
let sharedTrunkMaterial = null;
let sharedCanopyMaterial = null;
function ensureSharedMaterials() {
    const leafColor = Config.DEFAULT_LEAF_COLOR; const trunkColor = Config.DEFAULT_TRUNK_COLOR;
    if (!sharedTrunkMaterial) sharedTrunkMaterial = new THREE.MeshStandardMaterial({ color: trunkColor, name: 'sharedTrunkMaterial' });
    // else sharedTrunkMaterial.color.set(trunkColor); // Don't reset if maybe customized later
    if (!sharedCanopyMaterial) sharedCanopyMaterial = new THREE.MeshStandardMaterial({ color: leafColor, name: 'sharedCanopyMaterial' });
    // else sharedCanopyMaterial.color.set(leafColor);
}

// --- Helper Functions ---
function shuffleArray(array) { /* Fisher-Yates */ for (let i=array.length-1; i>0; i--) { const j=Math.floor(Math.random()*(i+1)); [array[i],array[j]]=[array[j],array[i]]; } }

function calculateDimensions(playerData) {
    const potentialLA = Math.max(0.0001, playerData.currentLA || Config.INITIAL_LEAF_AREA);
    const canopyWidth = Math.sqrt(potentialLA); const trunkArea = potentialLA * Config.k_TA_LA_RATIO;
    const trunkWidth = Math.sqrt(trunkArea); const trunkHeight = playerData.trunkHeight || Config.INITIAL_TRUNK_HEIGHT;
    return { canopyWidth: canopyWidth, canopyDepth: canopyWidth, trunkWidth: trunkWidth, trunkDepth: trunkWidth, trunkHeight: trunkHeight };
}

// --- Tree Creation/Update ---
export function createOrUpdateTree(playerId, playerData) {
    ensureSharedMaterials();
    let treeMeshGroup = gameState.playerTrees.get(playerId);
    const dimensions = calculateDimensions(playerData);
    const baseHeight = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;

    // Determine target position using spawnPoint from server data
    // Fallback to 0,0 if spawnPoint is missing for some reason
    const targetPosition = new THREE.Vector3(
        playerData.spawnPoint?.x ?? 0,
        baseHeight,
        playerData.spawnPoint?.z ?? 0
    );

    if (!treeMeshGroup) {
        // --- Create New Tree ---
        // console.log(`TREE: Creating new tree for player ${playerId}`);
        treeMeshGroup = new THREE.Group(); treeMeshGroup.name = `playerTree_${playerId}`;

        // Create Trunk
        const trunkGeometry = new THREE.BoxGeometry(dimensions.trunkWidth || 0.1, dimensions.trunkHeight || 0.1, dimensions.trunkDepth || 0.1);
        const trunkMesh = new THREE.Mesh(trunkGeometry, sharedTrunkMaterial); // Use shared material
        trunkMesh.name = "trunk"; trunkMesh.position.y = (dimensions.trunkHeight / 2);
        trunkMesh.castShadow = true; trunkMesh.receiveShadow = true; treeMeshGroup.add(trunkMesh);

        // Create Canopy Group
        const canopyGroup = new THREE.Group(); canopyGroup.name = "canopyGroup"; const tiles = [];
        const gridSize = Config.CANOPY_TILE_GRID_SIZE; const totalTiles = gridSize * gridSize;
        const initialDims = calculateDimensions({ currentLA: Config.INITIAL_LEAF_AREA, trunkHeight: Config.INITIAL_TRUNK_HEIGHT });
        const tileWidth = initialDims.canopyWidth / gridSize; const tileDepth = initialDims.canopyDepth / gridSize;
        const tileThickness = Config.CANOPY_TILE_THICKNESS;
        const tileGeometry = new THREE.BoxGeometry(tileWidth, tileThickness, tileDepth);
        for (let i = 0; i < gridSize; i++) { for (let j = 0; j < gridSize; j++) {
            const tileMesh = new THREE.Mesh(tileGeometry, sharedCanopyMaterial); // Use shared material
            const xPos = (i-(gridSize-1)/2)*tileWidth; const zPos = (j-(gridSize-1)/2)*tileDepth;
            tileMesh.position.set(xPos, 0, zPos); tileMesh.castShadow=true; tileMesh.receiveShadow=true;
            tileMesh.name = `canopyTile_${i}_${j}`; canopyGroup.add(tileMesh); tiles.push(tileMesh); } }
        shuffleArray(tiles); canopyGroup.userData.tiles = tiles; canopyGroup.userData.initialWidth = initialDims.canopyWidth;
        treeMeshGroup.add(canopyGroup);

        // Set initial position
        treeMeshGroup.position.copy(targetPosition);

        // Add to scene and map
        if (scene) scene.add(treeMeshGroup); else console.error("Scene not found for tree");
        gameState.playerTrees.set(playerId, treeMeshGroup);

        // Apply initial geometry/tiles update
        updateTreeGeometry(treeMeshGroup, playerData, dimensions);
        updateCanopyTiles(treeMeshGroup, playerData);

    } else {
        // --- Update Existing Tree ---
        // Update position if necessary (e.g., if spawn point changed somehow, though unlikely)
        if (!treeMeshGroup.position.equals(targetPosition)) {
            treeMeshGroup.position.copy(targetPosition);
        }
        updateTreeGeometry(treeMeshGroup, playerData, dimensions);
        updateCanopyTiles(treeMeshGroup, playerData);
    }

    // Set visibility based on server 'isAlive' state
    // Ensure visibility reflects player status EVEN if tree object already existed
    treeMeshGroup.visible = playerData.isAlive;
}

// --- Update Helpers ---
function updateTreeGeometry(treeMeshGroup, playerData, dimensions) { /* ... geometry update logic ... */
    if (!treeMeshGroup) return; const trunkMesh = treeMeshGroup.getObjectByName("trunk"); const canopyGroup = treeMeshGroup.getObjectByName("canopyGroup");
    if (trunkMesh && trunkMesh.geometry) { const params = trunkMesh.geometry.parameters; const heightChanged = Math.abs(params.height - dimensions.trunkHeight)>0.01; if (Math.abs(params.width - dimensions.trunkWidth)>0.01 || heightChanged || Math.abs(params.depth - dimensions.trunkDepth)>0.01) { trunkMesh.geometry.dispose(); trunkMesh.geometry = new THREE.BoxGeometry(dimensions.trunkWidth, dimensions.trunkHeight, dimensions.trunkDepth); } trunkMesh.position.y = dimensions.trunkHeight / 2; } // Always update position Y
    if (canopyGroup) { const tileThickness = Config.CANOPY_TILE_THICKNESS; canopyGroup.position.y = dimensions.trunkHeight + (tileThickness / 2); const initialWidth = canopyGroup.userData.initialWidth || 1; const currentWidth = dimensions.canopyWidth; const scaleFactor = currentWidth > 0.01 ? currentWidth / initialWidth : 0.01; if (Math.abs(canopyGroup.scale.x - scaleFactor) > 0.001) { canopyGroup.scale.set(scaleFactor, 1, scaleFactor); } }
}

function updateCanopyTiles(treeMeshGroup, playerData) { /* ... tile visibility logic ... */
    if (!treeMeshGroup || !sharedCanopyMaterial) return; const canopyGroup = treeMeshGroup.getObjectByName("canopyGroup"); if (!canopyGroup || !canopyGroup.userData.tiles) return; const tiles = canopyGroup.userData.tiles; const totalTiles = tiles.length; if (totalTiles === 0) return; const damagePercent = playerData.damagedLAPercentage || 0; const hiddenTilesCount = Math.floor(totalTiles * damagePercent); for (let i = 0; i < totalTiles; i++) { tiles[i].visible = (i >= hiddenTilesCount); }
    // --- TODO: Implement per-player tinting later ---
    const baseColor = new THREE.Color(Config.DEFAULT_LEAF_COLOR); sharedCanopyMaterial.color.set(baseColor);
}

// --- Removal & Disposal ---
export function removeTree(playerId) {
    const treeMeshGroup = gameState.playerTrees.get(playerId);
    if (treeMeshGroup) {
        // console.log(`TREE: Removing tree for player ${playerId}`); // Reduce noise
        disposeTreeGroup(treeMeshGroup);
        if (scene && treeMeshGroup.parent) scene.remove(treeMeshGroup);
        gameState.playerTrees.delete(playerId);
    }
}

function disposeTreeGroup(group) {
    if (!group) return; group.traverse((obj) => { if (obj.isMesh && obj.geometry) obj.geometry.dispose(); });
}

export function disposeAllTrees() {
    gameState.playerTrees.forEach(treeGroup => { disposeTreeGroup(treeGroup); if(scene && treeGroup.parent) scene.remove(treeGroup); });
    gameState.playerTrees.clear();
    disposeSharedTreeMaterials(); // Dispose shared materials if appropriate
    console.log("Disposed all player trees and shared materials.");
}

// Only dispose shared materials if they exist - maybe on full client shutdown/reset?
export function disposeSharedTreeMaterials() {
    if (sharedTrunkMaterial) { sharedTrunkMaterial.dispose(); sharedTrunkMaterial = null; }
    if (sharedCanopyMaterial) { sharedCanopyMaterial.dispose(); sharedCanopyMaterial = null; }
}

--- FILE: client/settings.js ---
// settings.js (in project root)

document.addEventListener('DOMContentLoaded', () => {
    const playerNameInput = document.getElementById('player-name');
    const leafColorInput = document.getElementById('leaf-color');
    const trunkColorInput = document.getElementById('trunk-color');
    const saveButton = document.getElementById('save-settings');

    // --- Load existing settings from localStorage ---
    function loadSettings() {
        const storedName = localStorage.getItem('playerName');
        const storedLeafColor = localStorage.getItem('leafColor');
        const storedTrunkColor = localStorage.getItem('trunkColor');

        if (playerNameInput) {
            playerNameInput.value = storedName || 'Treebard'; // Use default if not set
        }
        if (leafColorInput) {
            leafColorInput.value = storedLeafColor || '#228B22'; // Default green
        }
        if (trunkColorInput) {
            trunkColorInput.value = storedTrunkColor || '#8B4513'; // Default brown
        }
        console.log('Settings loaded from localStorage');
    }

    // --- Save current settings to localStorage ---
    function saveSettings() {
        if (playerNameInput) {
            localStorage.setItem('playerName', playerNameInput.value || 'Treebard');
        }
        if (leafColorInput) {
            localStorage.setItem('leafColor', leafColorInput.value);
        }
        if (trunkColorInput) {
            localStorage.setItem('trunkColor', trunkColorInput.value);
        }
        console.log('Settings saved to localStorage');
    }

    // --- Event Listener for Save Button ---
    if (saveButton) {
        saveButton.addEventListener('click', () => {
            saveSettings();
            // Navigate back to the root landing page route
            window.location.href = '/';
        });
    }

    // --- Initial Load ---
    loadSettings();
});

--- FILE: client/style.css ---
/* === Global & Base Styles === */
body, html {
    margin: 0;
    padding: 0;
    overflow: hidden; /* Prevent scrollbars on the page */
    font-family: sans-serif;
    background-color: #333; /* Fallback background */
    color: #eee;       /* Default text color */
}

#game-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0; /* Ensure canvas is behind UI panels */
}

#game-canvas {
    display: block;
    width: 100%;
    height: 100%;
}

/* === General UI Panel Styling === */
.ui-panel {
    position: absolute; /* Position panels absolutely relative to body/viewport */
    background-color: rgba(0, 0, 0, 0.65); /* Slightly darker background for panels */
    border: 1px solid #444;
    border-radius: 6px;
    padding: 10px;
    box-sizing: border-box; /* Include padding and border in element's total width and height */
    color: #eee;
    z-index: 10; /* Ensure panels are above the canvas */
    pointer-events: auto; /* Allow interaction with panels */
}

.ui-panel h3, .ui-panel h4 { /* General headings for panels */
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 1.0em; /* Slightly smaller headings */
    color: #ddd;
    border-bottom: 1px solid #555;
    padding-bottom: 5px;
}

.ui-panel p, .ui-panel div, .ui-panel label, .ui-panel span {
    font-size: 0.9em; /* Consistent font size within panels */
}

/* === Specific Panel Positioning === */

/* --- Top Left Info Panel --- */
#top-left-info {
    top: 10px;
    left: 10px;
    min-width: 180px; /* Ensure some minimum width */
}
#top-left-info p {
    margin: 4px 0; /* Tighter spacing */
}
#top-left-info span {
    font-weight: bold;
    color: #ffc107; /* Amber highlight for values */
}
.message { /* Message Log styling */
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px dashed #555;
    color: #ffcc00;
    font-weight: bold;
    min-height: 1.2em;
    font-size: 0.85em; /* Smaller message text */
}
.message.warning { color: #ff9800; }
.message.error { color: #f44336; }


/* --- Top Right Leaderboard --- */
#top-right-leaderboard {
    top: 10px;
    right: 10px;
    min-width: 200px;
    max-width: 280px;
    background-color: rgba(0, 0, 0, 0.5); /* More translucent */
}
#top-right-leaderboard h4 {
    font-size: 0.9em;
    text-align: center;
    border: none; /* Remove border for header */
    padding-bottom: 0;
    margin-bottom: 5px;
}
#top-right-leaderboard ul {
    list-style: none;
    padding: 0;
    margin: 0;
    font-size: 0.85em;
}
#top-right-leaderboard li {
    padding: 3px 0;
    border-bottom: 1px dotted #444;
}
#top-right-leaderboard li:last-child {
    border-bottom: none;
}


/* --- Bottom Left Status Panel --- */
#bottom-left-status {
    bottom: 10px;
    left: 10px;
    width: 220px; /* Fixed width */
}
#bottom-left-status .status-bar-container {
    margin-bottom: 10px;
}
#bottom-left-status label {
    display: block;
    margin-bottom: 2px;
    font-size: 0.85em;
    color: #ccc;
}
.bar-outer {
    background-color: #555;
    border-radius: 3px;
    height: 15px;
    width: 100%;
    overflow: hidden;
}
.bar-inner {
    height: 100%;
    border-radius: 3px;
    transition: width 0.2s ease-in-out;
}
.carbon { background-color: #4CAF50; }
.hydraulic { background-color: #2196F3; }
#bottom-left-status span#carbon-value,
#bottom-left-status span#hydraulic-value {
    float: right;
    font-size: 0.8em;
    line-height: 15px;
    margin-left: 5px;
    color: #ccc;
}
#bottom-left-status p { /* Seed count display */
    margin: 8px 0 0 0;
    clear: both;
    font-weight: bold;
}
#bottom-left-status p span#seed-counter {
     color: #ffc107;
}


/* --- ++ NEW: Bottom Right Control Panel ++ --- */
#control-panel-right {
    bottom: 10px;
    right: 10px;
    width: 200px; /* Adjust width as needed for vertical layout */
    display: flex;
    flex-direction: column; /* Stack controls vertically */
    gap: 15px; /* Space between control rows */
    padding: 15px 10px; /* Adjust padding */
}

/* ++ REMOVED Styles for #bottom-bar-controls ++ */
/* #bottom-bar-controls { ... } */

/* Styling for rows within the vertical panel */
.control-row {
    display: grid; /* Use grid for alignment within the row */
    grid-template-columns: auto 1fr; /* Label | Slider/Value Area */
    grid-template-rows: auto auto; /* Row 1 for Label/Value, Row 2 for Slider */
    gap: 2px 8px; /* Small vertical gap, larger horizontal */
    align-items: center;
    width: 100%; /* Ensure row takes full width of panel */
}

.control-row label {
    grid-column: 1 / 2; /* Label in first column */
    grid-row: 1 / 2;    /* Label in first row */
    white-space: nowrap;
    color: #ccc;
    font-size: 0.85em;
    justify-self: start; /* Align label left */
}

.control-row input[type="range"] {
    grid-column: 1 / 3; /* Slider spans both columns */
    grid-row: 2 / 3;    /* Slider in second row */
    width: 100%;        /* Slider takes full width */
    cursor: pointer;
    margin-top: 2px; /* Small space below label/value */
}

.control-row span { /* Percentage displays */
    grid-column: 2 / 3; /* Value in second column */
    grid-row: 1 / 2;    /* Value in first row (aligned with label) */
    font-size: 0.85em;
    font-weight: bold;
    color: #ccc;
    text-align: right; /* Align value right */
    white-space: nowrap;
    justify-self: end; /* Ensure right alignment in grid */
}
/* Adjust min-width if needed for specific value spans */
/* .control-row span#growth-ratio-percentage { min-width: 75px; } */


/* === General Interactive Element Styling === */
input[type="range"], input[type="color"], input[type="number"], button {
     pointer-events: auto; /* Ensure these are always interactive */
}
input[type="color"] {
    min-width: 40px; height: 25px; border: 1px solid #555;
    cursor: pointer; padding: 0; vertical-align: middle;
}

/* === Game Over Modal Styling (Unchanged) === */
.modal {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background-color: rgba(40, 40, 40, 0.9); padding: 20px; border: 1px solid #666;
    border-radius: 10px; z-index: 100; min-width: 300px; text-align: center;
    pointer-events: auto; color: #eee;
}
.modal.hidden { display: none; }
.modal h2 { margin-top: 0; color: #eee; margin-bottom: 15px; }
.modal p { color: #eee; margin: 10px 0; line-height: 1.4; }
.modal p span { font-weight: bold; color: #ffc107; }
#game-over-reason { font-style: italic; color: #ffdddd; margin-bottom: 20px !important; }
.modal button { padding: 10px 20px; margin-top: 20px; cursor: pointer; background-color: #555; border: none; color: #eee; border-radius: 5px; }
.modal button:hover { background-color: #777; }

--- FILE: server/game/simulation.js ---
// server/game/simulation.js
import * as Config from '../config.js';
import { getGlobalState, getAllPlayers } from './GameState.js';
import { endGame } from './gameLogic.js';

let previousPeriodIndex = -2; // Internal state for weather change detection

/** Updates the entire game state for one tick. */
export function updateSimulationTick(deltaTime, io) {
    const globalState = getGlobalState();
    const players = getAllPlayers();

    if (globalState.gamePhase !== 'playing') { return; }

    // --- 1. Update Global Time ---
    globalState.timeInCycle += deltaTime;

    // --- 2. Handle Cycle Transitions & Weather ---
    let enteringNewDay = false;
    if (globalState.timeInCycle >= Config.TOTAL_CYCLE_DURATION) {
        enteringNewDay = true; globalState.day++; globalState.timeInCycle -= Config.TOTAL_CYCLE_DURATION;
        globalState.currentPeriodIndex = 0; globalState.isNight = false;
        Object.values(players).forEach(p => { p.growthAppliedThisCycle = false; });
        previousPeriodIndex = -1;
    }
    let calculatedPeriodIndex;
    if (globalState.timeInCycle < Config.DAY_TOTAL_DURATION) { calculatedPeriodIndex = Math.floor(globalState.timeInCycle / Config.PERIOD_DURATION); globalState.isNight = false; }
    else { calculatedPeriodIndex = -1; globalState.isNight = true; }

    const periodChanged = calculatedPeriodIndex !== previousPeriodIndex;
    if (periodChanged) {
        const oldPeriodIndex = previousPeriodIndex; // Store before updating tracker
        previousPeriodIndex = calculatedPeriodIndex; // Update tracker
        if (!globalState.isNight) {
            const isCloudy = generatePeriodWeather(globalState);
            globalState.isRaining = isCloudy && (Math.random() < Config.RAIN_PROB_IF_CLOUDY);
        } else {
             // Only generate night weather once when actually entering night phase
             if (oldPeriodIndex !== -1) { // Check if we weren't already in night
                 generateNightWeather(globalState);
                 Object.values(players).forEach(p => { p.foliarUptakeAppliedThisNight = false; });
             }
        }
         globalState.currentPeriodIndex = calculatedPeriodIndex; // Update official state index
    }

    // --- 3. Update Each Player's State ---
    let playersAliveThisTick = 0;
    Object.values(players).forEach(playerState => {
        // <<< This check correctly skips dead players AND spectators >>>
        if (!playerState.isAlive) return;

        updatePlayerPhysiology(playerState, globalState, deltaTime);

        if ((playerState.carbonStorage <= 0 || playerState.hydraulicSafety <= 0)) {
            console.log(`SIM: Player ${playerState.id} died.`);
            playerState.isAlive = false;
        } else {
            playersAliveThisTick++;
        }
    });

    // --- Check for Game End Condition ---
    const totalPlayers = Object.keys(players).length;
    // Check only active players (non-spectators)
    const activePlayers = Object.values(players).filter(p => !p.isSpectator).length;
    if (playersAliveThisTick === 0 && activePlayers > 0 && globalState.gamePhase === 'playing') {
         console.log("SIM: All active players are dead condition met. Triggering endGame.");
         endGame(io, players, globalState); // Pass necessary info
    }
}

// --- Simulation Helper Functions ---

/** Updates physiological state for a single player. */
function updatePlayerPhysiology(playerState, globalState, deltaTime) {
     const stomata = playerState.stomatalConductance; const effLA = Math.max(0, playerState.effectiveLA); const currentLA = Math.max(0, playerState.currentLA); const trunkVolume = Math.max(0, playerState.trunkWidth * playerState.trunkDepth * playerState.trunkHeight);
     let potentialCarbonGain = 0; if (!globalState.isNight) potentialCarbonGain = Config.PHOTOSYNTHESIS_RATE_PER_LA * effLA * stomata * globalState.currentLightMultiplier;
     const respirationLoss = (Config.RESPIRATION_RATE_PER_LA * currentLA + Config.RESPIRATION_RATE_PER_TRUNK_VOL * trunkVolume);
     const waterLoss = Config.TRANSPIRATION_RATE_PER_LA * effLA * stomata * globalState.currentDroughtFactor; let currentRecoveryRate = Config.HYDRAULIC_RECOVERY_RATE; if (globalState.isRaining) currentRecoveryRate *= Config.RAIN_RECOVERY_BONUS_MULT;
     const hydraulicChange = (currentRecoveryRate * (1 - stomata)) - waterLoss; playerState.hydraulicSafety += hydraulicChange * deltaTime;
     const potentialGainThisStep = potentialCarbonGain * deltaTime; const respirationLossThisStep = respirationLoss * deltaTime; const currentStorage = playerState.carbonStorage; const maxPossibleGain = Math.max(0, Config.MAX_CARBON - currentStorage); const actualGain = Math.min(potentialGainThisStep, maxPossibleGain); playerState.carbonStorage = currentStorage + actualGain - respirationLossThisStep;
     playerState.carbonStorage = Math.max(0, playerState.carbonStorage); playerState.hydraulicSafety = Math.max(0, Math.min(playerState.maxHydraulic, playerState.hydraulicSafety));
     if (playerState.hydraulicSafety < Config.HYDRAULIC_DAMAGE_THRESHOLD) { const damageIncrease = Config.CROWN_DIEBACK_RATE * deltaTime; playerState.damagedLAPercentage = Math.min(1, playerState.damagedLAPercentage + damageIncrease); playerState.effectiveLA = playerState.currentLA * (1 - playerState.damagedLAPercentage); }
     if (globalState.isNight) { if (globalState.isRaining && !playerState.foliarUptakeAppliedThisNight) { const boostAmount = Config.NIGHT_RAIN_HYDRAULIC_BOOST; playerState.hydraulicSafety = Math.min(playerState.hydraulicSafety + boostAmount, playerState.maxHydraulic); playerState.foliarUptakeAppliedThisNight = true; } const timeIntoNight = globalState.timeInCycle - Config.DAY_TOTAL_DURATION; if (timeIntoNight >= Config.GROWTH_OFFSET_NIGHT && !playerState.growthAppliedThisCycle) { applyAllocation(playerState); playerState.growthAppliedThisCycle = true; } }
}

/** Generates weather for a daytime period. */
function generatePeriodWeather(globalState) { const isSunny = Math.random() < Config.SUNNY_PROB; const isCloudy = !isSunny; globalState.currentLightMultiplier = isCloudy ? Config.LIGHT_MULT_CLOUDY : Config.LIGHT_MULT_SUNNY; const droughtVariation = (Math.random() * 2 - 1) * Config.DROUGHT_VARIATION; globalState.currentDroughtFactor = Math.max(0.1, Config.DROUGHT_MULT_BASE + droughtVariation); return isCloudy; }
/** Generates weather for the night phase. */
function generateNightWeather(globalState) { const isConceptuallyCloudy = Math.random() >= Config.SUNNY_PROB; globalState.isRaining = isConceptuallyCloudy && (Math.random() < Config.RAIN_PROB_IF_CLOUDY); globalState.currentLightMultiplier = 0; globalState.currentDroughtFactor = Config.DROUGHT_MULT_BASE; }
/** Applies carbon allocation based on player's stored intentions. */
function applyAllocation(playerState) { const available = Math.floor(playerState.carbonStorage); if (available <= 0) return; const savingsPercent = Math.max(0, Math.min(100, playerState.lastSavingsPercent)); const growthRatioPercent = Math.max(0, Math.min(100, playerState.lastGrowthRatioPercent)); const carbonToSpend = Math.floor(available * (1 - savingsPercent / 100)); const actualCarbonForGrowth = Math.floor(carbonToSpend * (growthRatioPercent / 100)); const carbonForSeeds = carbonToSpend - actualCarbonForGrowth; const seedsToMake = Math.floor(carbonForSeeds / Config.SEED_COST); const actualCarbonForSeeds = seedsToMake * Config.SEED_COST; const totalSpent = actualCarbonForGrowth + actualCarbonForSeeds; if (totalSpent > available + 0.01 || totalSpent < 0) { console.error(`SIM ALLOC ERR for ${playerState.id}: Invalid spend (${totalSpent}) vs avail (${available}).`); return; } playerState.carbonStorage -= totalSpent; playerState.seedCount += seedsToMake; if (actualCarbonForGrowth > 0) { const currentTrunkVolume = (playerState.trunkWidth || 0.1) * (playerState.trunkDepth || 0.1) * (playerState.trunkHeight || 0.1); const currentBiomassEstimate = Math.max(1, playerState.currentLA + currentTrunkVolume); const biomassToAdd = actualCarbonForGrowth / Config.GROWTH_COST_PER_LA; const growthFactor = 1 + (biomassToAdd / currentBiomassEstimate); playerState.currentLA *= growthFactor; playerState.trunkHeight *= growthFactor; playerState.trunkWidth = Math.sqrt(playerState.currentLA * Config.k_TA_LA_RATIO); playerState.trunkDepth = playerState.trunkWidth; playerState.maxHydraulic = Config.BASE_HYDRAULIC + Config.HYDRAULIC_SCALE_PER_LA * playerState.currentLA; playerState.effectiveLA = playerState.currentLA * (1 - playerState.damagedLAPercentage); } }

--- FILE: .gitignore ---
dirgrab.txt
server/node_modules
package-lock.json

--- FILE: client/sceneSetup.js ---
// client/sceneSetup.js
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import * as Config from './config.js';
import { createStars, createRainSystem } from './environment.js';

export let scene;
export let camera;
export let renderer;
export let controls;
export let sunLight;
export let ambientLight;

export function initScene(canvas) {
    // Scene setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // Initial color, environment.js will update

    // Fog setup - Use client config values if available, otherwise provide defaults
    // Note: Config constants FOG_DAY_NEAR/FAR are commented out in client/config.js, so provide defaults here.
    const fogNear = Config.FOG_DAY_NEAR !== undefined ? Config.FOG_DAY_NEAR : 50;
    const fogFar = Config.FOG_DAY_FAR !== undefined ? Config.FOG_DAY_FAR : 150;
    scene.fog = new THREE.Fog(0x87ceeb, fogNear, fogFar); // environment.js will update color and distances

    // Camera setup
    const aspectRatio = window.innerWidth / window.innerHeight;
    camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000); // Far plane at 1000
    camera.position.set(15, 15, 15);

    // Renderer setup
    renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // Lighting setup
    ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Initial intensity
    scene.add(ambientLight);

    sunLight = new THREE.DirectionalLight(0xffffff, 1.5); // Initial intensity
    sunLight.position.set(30, 50, 20);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 150;
    // Use client config for shadow camera size calculation
    const shadowCamSize = (Config.ISLAND_RADIUS || 50) * 1.5; // Use fallback if config missing
    sunLight.shadow.camera.left = -shadowCamSize;
    sunLight.shadow.camera.right = shadowCamSize;
    sunLight.shadow.camera.top = shadowCamSize;
    sunLight.shadow.camera.bottom = -shadowCamSize;
    scene.add(sunLight);
    scene.add(sunLight.target); // Target is needed for directional light shadows

    // Controls setup
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    // Use client config for initial target height
    controls.target.set(0, (Config.INITIAL_TRUNK_HEIGHT || 2) / 2, 0); // Use fallback
    controls.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent looking straight down/up too far
    controls.minDistance = 5;  // Prevent zooming too close
    controls.maxDistance = 100; // Prevent zooming too far out

    // Static Environment Meshes (Island, Water)
    createEnvironment(); // <<< This function creates the island

    // Initialize Dynamic Environment Effects (Stars, Rain)
    createStars();
    createRainSystem();

    // Window Resize Listener
    window.addEventListener('resize', onWindowResize);

    console.log("Scene initialized (including stars and rain system placeholder)");
}

// Creates static meshes like island and water
function createEnvironment() {
    // Use client config values with fallbacks for safety
    const islandRadius = Config.ISLAND_RADIUS || 50;
    const islandLevel = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
    const waterLevel = Config.WATER_LEVEL !== undefined ? Config.WATER_LEVEL : 0;

    // Island
    const islandGeometry = new THREE.CylinderGeometry(islandRadius, islandRadius, islandLevel * 2, 32);
    const islandMaterial = new THREE.MeshStandardMaterial({ color: 0x967969 }); // Brownish color
    const islandMesh = new THREE.Mesh(islandGeometry, islandMaterial);
    islandMesh.position.y = islandLevel / 2; // Center it vertically around islandLevel
    islandMesh.receiveShadow = true;
    // +++ Assign the name property +++
    islandMesh.name = 'island'; // <<< ENSURE THIS LINE IS PRESENT
    // ++++++++++++++++++++++++++++++++
    scene.add(islandMesh);
    console.log(`SCENESETUP: Island mesh created and added with name: ${islandMesh.name}`); // Add log

    // Water
    console.log(`SCENESETUP: Creating water with radius factor based on ISLAND_RADIUS: ${islandRadius}`);
    const waterGeometry = new THREE.PlaneGeometry(islandRadius * 4, islandRadius * 4); // Large plane
    const waterMaterial = new THREE.MeshStandardMaterial({
        color: 0x4682B4, // Steel blue
        transparent: true,
        opacity: 0.8,
        roughness: 0.2,
        metalness: 0.1,
    });
    const waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
    waterMesh.rotation.x = -Math.PI / 2; // Rotate flat
    waterMesh.position.y = waterLevel;   // Position at water level
    console.log(`SCENESETUP: Water mesh Y position: ${waterMesh.position.y}`);
    waterMesh.receiveShadow = true; // Water can receive shadows (e.g., from trees)
    scene.add(waterMesh);
}

// Handles window resize events
function onWindowResize() {
    if (camera && renderer) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
}

--- FILE: server/network/stateBroadcaster.js ---
// server/network/stateBroadcaster.js

function getSimplifiedGameStateSnapshot(players, globalState) {
    const playersSnapshot = {};
    Object.values(players).forEach(p => {
        playersSnapshot[p.id] = {
            id: p.id,
            playerName: p.playerName,
            isAlive: p.isAlive,
            hasChosenSpawn: p.hasChosenSpawn,
            isSpectator: p.isSpectator, // <<< Include spectator status
            // Resources
            carbonStorage: p.carbonStorage, hydraulicSafety: p.hydraulicSafety, maxHydraulic: p.maxHydraulic,
            // Visual state
            currentLA: p.currentLA, trunkHeight: p.trunkHeight, damagedLAPercentage: p.damagedLAPercentage,
            // Score & Position
            seedCount: p.seedCount, spawnPoint: p.spawnPoint
        };
    });

    return {
        // Global environment
        day: globalState.day, timeInCycle: globalState.timeInCycle, currentPeriodIndex: globalState.currentPeriodIndex,
        isNight: globalState.isNight, currentLightMultiplier: globalState.currentLightMultiplier, currentDroughtFactor: globalState.currentDroughtFactor,
        isRaining: globalState.isRaining,
        // Game Phase & Countdown
        gamePhase: globalState.gamePhase, countdownTimer: globalState.countdownTimer,
        // Player states
        players: playersSnapshot,
        serverTime: Date.now()
    };
}

export function getFullGameStateSnapshot(players, globalState) {
    return getSimplifiedGameStateSnapshot(players, globalState);
}

export function broadcastGameState(io, players, globalState) {
    const snapshot = getSimplifiedGameStateSnapshot(players, globalState);
    io.emit('gameStateUpdate', snapshot);
}


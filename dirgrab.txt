---
DIRECTORY STRUCTURE
---
- .gitignore
- README.md
- client/
  - admin.html
  - admin.js
  - config.js
  - environment.js
  - game.html
  - gameState.js
  - index.html
  - index.js
  - main.js
  - sceneSetup.js
  - settings.html
  - settings.js
  - style.css
  - tree.js
  - ui/
    - controlsHandlers.js
    - elements.js
    - gameOver.js
    - leaderboard.js
    - messageHandler.js
    - setupListeners.js
    - update.js
    - updateAdmin.js
- server/
  - config.js
  - game/
    - GameInstance.js
    - GameInstanceManager.js
    - GameState.js
    - gameLogic.js
    - simulation.js
  - network/
    - connection.js
    - stateBroadcaster.js
  - package.json
  - server.js

---
FILE CONTENTS
---

--- FILE: server/game/GameInstance.js ---
// server/game/GameInstance.js
import { v4 as uuidv4 } from 'uuid';
import * as Config from '../config.js'; // Import the config

// *** Use local constants with defaults if Config properties are missing ***
const TICK_RATE = Config.TICK_RATE !== undefined ? Config.TICK_RATE : 20;
const COUNTDOWN_DURATION = Config.COUNTDOWN_DURATION !== undefined ? Config.COUNTDOWN_DURATION : 5;
const ISLAND_LEVEL = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
const INITIAL_LEAF_AREA = Config.INITIAL_LEAF_AREA !== undefined ? Config.INITIAL_LEAF_AREA : 5;
const BASE_HYDRAULIC = Config.BASE_HYDRAULIC !== undefined ? Config.BASE_HYDRAULIC : 50;
const HYDRAULIC_SCALE_PER_LA = Config.HYDRAULIC_SCALE_PER_LA !== undefined ? Config.HYDRAULIC_SCALE_PER_LA : 10;
const INITIAL_CARBON = Config.INITIAL_CARBON !== undefined ? Config.INITIAL_CARBON : 100;
const INITIAL_HYDRAULICS = Config.INITIAL_HYDRAULICS !== undefined ? Config.INITIAL_HYDRAULICS : 100;
const INITIAL_TRUNK_HEIGHT = Config.INITIAL_TRUNK_HEIGHT !== undefined ? Config.INITIAL_TRUNK_HEIGHT : 2;
const k_TA_LA_RATIO = Config.k_TA_LA_RATIO !== undefined ? Config.k_TA_LA_RATIO : 0.01;
const MAX_CARBON = Config.MAX_CARBON !== undefined ? Config.MAX_CARBON : 200;
const PHOTOSYNTHESIS_RATE_PER_LA = Config.PHOTOSYNTHESIS_RATE_PER_LA !== undefined ? Config.PHOTOSYNTHESIS_RATE_PER_LA : 0.5;
const RESPIRATION_RATE_PER_LA = Config.RESPIRATION_RATE_PER_LA !== undefined ? Config.RESPIRATION_RATE_PER_LA : 0.02;
const RESPIRATION_RATE_PER_TRUNK_VOL = Config.RESPIRATION_RATE_PER_TRUNK_VOL !== undefined ? Config.RESPIRATION_RATE_PER_TRUNK_VOL : 0.01;
const TRANSPIRATION_RATE_PER_LA = Config.TRANSPIRATION_RATE_PER_LA !== undefined ? Config.TRANSPIRATION_RATE_PER_LA : 0.4;
const HYDRAULIC_RECOVERY_RATE = Config.HYDRAULIC_RECOVERY_RATE !== undefined ? Config.HYDRAULIC_RECOVERY_RATE : 2;
const RAIN_RECOVERY_BONUS_MULT = Config.RAIN_RECOVERY_BONUS_MULT !== undefined ? Config.RAIN_RECOVERY_BONUS_MULT : 3.0;
const HYDRAULIC_DAMAGE_THRESHOLD = Config.HYDRAULIC_DAMAGE_THRESHOLD !== undefined ? Config.HYDRAULIC_DAMAGE_THRESHOLD : 20;
const CROWN_DIEBACK_RATE = Config.CROWN_DIEBACK_RATE !== undefined ? Config.CROWN_DIEBACK_RATE : 0.05;
const NIGHT_RAIN_HYDRAULIC_BOOST = Config.NIGHT_RAIN_HYDRAULIC_BOOST !== undefined ? Config.NIGHT_RAIN_HYDRAULIC_BOOST : 20.0;
const GROWTH_OFFSET_NIGHT = Config.GROWTH_OFFSET_NIGHT !== undefined ? Config.GROWTH_OFFSET_NIGHT : 1.5;
const SEED_COST = Config.SEED_COST !== undefined ? Config.SEED_COST : 1;
const GROWTH_COST_PER_LA = Config.GROWTH_COST_PER_LA !== undefined ? Config.GROWTH_COST_PER_LA : 5;
const TOTAL_CYCLE_DURATION = Config.TOTAL_CYCLE_DURATION !== undefined ? Config.TOTAL_CYCLE_DURATION : 24.0; // Example default
const DAY_TOTAL_DURATION = Config.DAY_TOTAL_DURATION !== undefined ? Config.DAY_TOTAL_DURATION : 21.0; // Example default
const PERIOD_DURATION = Config.PERIOD_DURATION !== undefined ? Config.PERIOD_DURATION : 7.0; // Example default
const SUNNY_PROB = Config.SUNNY_PROB !== undefined ? Config.SUNNY_PROB : 2.0/3.0;
const RAIN_PROB_IF_CLOUDY = Config.RAIN_PROB_IF_CLOUDY !== undefined ? Config.RAIN_PROB_IF_CLOUDY : 0.5;
const LIGHT_MULT_SUNNY = Config.LIGHT_MULT_SUNNY !== undefined ? Config.LIGHT_MULT_SUNNY : 1.0;
const LIGHT_MULT_CLOUDY = Config.LIGHT_MULT_CLOUDY !== undefined ? Config.LIGHT_MULT_CLOUDY : 0.4;
const DROUGHT_MULT_BASE = Config.DROUGHT_MULT_BASE !== undefined ? Config.DROUGHT_MULT_BASE : 1.0;
const DROUGHT_VARIATION = Config.DROUGHT_VARIATION !== undefined ? Config.DROUGHT_VARIATION : 0.4;


// Function to create initial state for a player within an instance
function createInitialPlayerState(socketId) { /* ... as before ... */
    const initialLA = INITIAL_LEAF_AREA; const baseHeight = ISLAND_LEVEL; const maxHydraulic = BASE_HYDRAULIC + HYDRAULIC_SCALE_PER_LA * initialLA;
    return { id: socketId, playerName: `Player_${socketId.substring(0, 4)}`, leafColor: '#228B22', trunkColor: '#8B4513', spawnPoint: { x: 0, y: baseHeight, z: 0 }, isAlive: false, hasChosenSpawn: false, isSpectator: false, isAI: false, carbonStorage: INITIAL_CARBON, hydraulicSafety: Math.min(INITIAL_HYDRAULICS, maxHydraulic), maxHydraulic: maxHydraulic, currentLA: initialLA, effectiveLA: initialLA, trunkHeight: INITIAL_TRUNK_HEIGHT, trunkWidth: Math.sqrt(initialLA * k_TA_LA_RATIO), trunkDepth: Math.sqrt(initialLA * k_TA_LA_RATIO), seedCount: 0, damagedLAPercentage: 0, stomatalConductance: 0.5, lastSavingsPercent: 50, lastGrowthRatioPercent: 50, foliarUptakeAppliedThisNight: false, growthAppliedThisCycle: false, };
}

// Initial state structure for the instance
function createInitialInstanceState() { /* ... as before ... */
   return { instanceId: uuidv4(), roomId: null, mode: 'none', simulationIntervalId: null, countdownIntervalId: null, lastTickTime: Date.now(), day: 1, timeInCycle: 0.0, currentPeriodIndex: -1, isNight: false, currentLightMultiplier: LIGHT_MULT_SUNNY, currentDroughtFactor: DROUGHT_MULT_BASE, isRaining: false, gamePhase: 'lobby', countdownTimer: null, allowPlayerCountdownStart: true, players: new Map(), _previousPeriodIndexForWeather: -2, };
}


export class GameInstance {
   constructor(mode = 'multi', io) {
       this.state = createInitialInstanceState();
       this.state.mode = mode;
       this.state.roomId = this.state.instanceId;
       this.io = io;
       console.log(`GameInstance created: ID=${this.state.instanceId}, Mode=${this.state.mode}, Room=${this.state.roomId}`);
   }

   // --- Player Management (methods as before) ---
   addPlayer(socket) { if (!socket || this.state.players.has(socket.id)) { return null; } const playerState = createInitialPlayerState(socket.id); this.state.players.set(socket.id, playerState); socket.join(this.state.roomId); /* console.log(`GameInstance ${this.state.instanceId}: Added player ${socket.id}. Total: ${this.state.players.size}`); */ return playerState; } // Reduced log noise
   removePlayer(socketId) { if (this.state.players.has(socketId)) { this.state.players.delete(socketId); /* console.log(`GameInstance ${this.state.instanceId}: Removed player ${socketId}. Remaining: ${this.state.players.size}`); */ return true; } return false; } // Reduced log noise
   getPlayerState(socketId) { return this.state.players.get(socketId) || null; }
   getAllPlayers() { return this.state.players; }
   getNonSpectatorPlayers() { return Array.from(this.state.players.values()).filter(p => !p.isSpectator); }

   // --- State Access/Modification (methods as before) ---
   getSnapshot() { /* ... as before ... */ const playersSnapshot = {}; this.state.players.forEach((playerData, playerId) => { playersSnapshot[playerId] = { id: playerData.id, playerName: playerData.playerName, isAlive: playerData.isAlive, hasChosenSpawn: playerData.hasChosenSpawn, isSpectator: playerData.isSpectator, carbonStorage: playerData.carbonStorage, hydraulicSafety: playerData.hydraulicSafety, maxHydraulic: playerData.maxHydraulic, currentLA: playerData.currentLA, trunkHeight: playerData.trunkHeight, damagedLAPercentage: playerData.damagedLAPercentage, seedCount: playerData.seedCount, spawnPoint: playerData.spawnPoint }; }); return { instanceId: this.state.instanceId, mode: this.state.mode, day: this.state.day, timeInCycle: this.state.timeInCycle, currentPeriodIndex: this.state.currentPeriodIndex, isNight: this.state.isNight, currentLightMultiplier: this.state.currentLightMultiplier, currentDroughtFactor: this.state.currentDroughtFactor, isRaining: this.state.isRaining, gamePhase: this.state.gamePhase, countdownTimer: this.state.countdownTimer, allowPlayerCountdownStart: this.state.allowPlayerCountdownStart, players: playersSnapshot, serverTime: Date.now() }; }
   setGamePhase(phase) { /* ... as before ... */ if (['lobby', 'countdown', 'playing', 'ended'].includes(phase)) { if (this.state.gamePhase !== phase) { console.log(`GameInstance ${this.state.instanceId}: Changing phase from ${this.state.gamePhase} to ${phase}`); this.state.gamePhase = phase; if (phase !== 'countdown') this.state.countdownTimer = null; if (phase !== 'countdown' && this.state.countdownIntervalId) { this.stopCountdown(); } } } else { console.error(`GameInstance ${this.state.instanceId}: Invalid phase: ${phase}`); } }
   updateStateProperty(key, value) { /* ... as before ... */ if (key in this.state) { this.state[key] = value; } else { console.warn(`GameInstance ${this.state.instanceId}: Tried to update unknown property ${key}`); } }

   // --- Simulation Loop Control (methods as before) ---
   startSimulationLoop() { /* ... as before ... */ if (this.state.simulationIntervalId) { return; } console.log(`GameInstance ${this.state.instanceId}: Starting simulation loop.`); this.state.lastTickTime = Date.now(); this.state.simulationIntervalId = setInterval(() => this.runTick(), 1000 / TICK_RATE); }
   stopSimulationLoop() { /* ... as before ... */ if (this.state.simulationIntervalId) { console.log(`GameInstance ${this.state.instanceId}: Stopping simulation loop.`); clearInterval(this.state.simulationIntervalId); this.state.simulationIntervalId = null; } }

   // --- Core Game Logic ---
   runTick() {
       const now = Date.now();
       const deltaTime = Math.min((now - this.state.lastTickTime) / 1000.0, 1.0 / TICK_RATE * 5);
       this.state.lastTickTime = now;

       // +++ Log Entry +++
       // console.log(`Instance ${this.state.instanceId}: runTick START - Phase: ${this.state.gamePhase}, Delta: ${deltaTime.toFixed(3)}`);

       if (this.state.gamePhase !== 'playing') {
           console.warn(`Instance ${this.state.instanceId}: runTick called while not playing. Stopping sim.`);
           this.stopSimulationLoop();
           return;
       }

       // --- 1. Update Global Time ---
       const oldTimeInCycle = this.state.timeInCycle;
       this.state.timeInCycle += deltaTime;
       // +++ Log Time Update +++
       // console.log(`Instance ${this.state.instanceId}: Time updated from ${oldTimeInCycle.toFixed(2)} to ${this.state.timeInCycle.toFixed(2)}`);

       // --- 2. Handle Cycle Transitions & Weather ---
       this.updateTimeAndWeather(); // Contains its own logs now

       // --- 3. Update Each Player's State ---
       let playersAliveThisTick = 0;
       this.state.players.forEach(playerState => {
           if (!playerState.isAlive) return;
           this._updatePlayerPhysiology(playerState, deltaTime);
           if ((playerState.carbonStorage <= 0 || playerState.hydraulicSafety <= 0)) {
                // console.log(`Instance ${this.state.instanceId}: Player ${playerState.id} died in tick.`); // Log death check
                playerState.isAlive = false;
           } else {
               playersAliveThisTick++;
           }
       });

       // --- 4. Check for Game End Condition ---
       const activePlayersCount = this.getNonSpectatorPlayers().length;
       if (playersAliveThisTick === 0 && activePlayersCount > 0) {
            console.log(`Instance ${this.state.instanceId} Tick: All active players dead condition met. Ending game.`);
            this.endGame("All trees have perished!");
            return; // endGame stops loop, sets phase etc.
       }

       // --- 5. Broadcast State ---
       this.broadcastState();
       // console.log(`Instance ${this.state.instanceId}: runTick END`); // Log Exit
   }


   updateTimeAndWeather() {
       let enteringNewDay = false;
       // +++ Log Entry and Current Time +++
       // console.log(`Instance ${this.state.instanceId}: updateTimeAndWeather START - TimeInCycle: ${this.state.timeInCycle.toFixed(2)}, Day: ${this.state.day}`);

       if (this.state.timeInCycle >= TOTAL_CYCLE_DURATION) {
           enteringNewDay = true;
           this.state.day++;
           this.state.timeInCycle -= TOTAL_CYCLE_DURATION;
           this.state.currentPeriodIndex = 0; // Start at first day period
           this.state.isNight = false;
           this.state.players.forEach(p => { p.growthAppliedThisCycle = false; });
            this.state._previousPeriodIndexForWeather = -1; // Reset internal weather tracker for new day
            // +++ Log New Day +++
            console.log(`--- Instance ${this.state.instanceId}: NEW DAY ${this.state.day} Started ---`);
       }

       let calculatedPeriodIndex;
       if (this.state.timeInCycle < DAY_TOTAL_DURATION) {
           calculatedPeriodIndex = Math.floor(this.state.timeInCycle / PERIOD_DURATION);
           this.state.isNight = false;
       } else {
           calculatedPeriodIndex = -1; // Night
           this.state.isNight = true;
       }

       // +++ Log Calculated Index +++
       // console.log(`Instance ${this.state.instanceId}: Calculated Period Index: ${calculatedPeriodIndex}, Previous: ${this.state._previousPeriodIndexForWeather}`);

       const periodChanged = calculatedPeriodIndex !== this.state._previousPeriodIndexForWeather;

       if (periodChanged) {
            // +++ Log Period Change Detected +++
            console.log(`--- Instance ${this.state.instanceId}: Period Changed! New Index: ${calculatedPeriodIndex} (was ${this.state._previousPeriodIndexForWeather}) ---`);

           const oldPeriodIndex = this.state._previousPeriodIndexForWeather;
           this.state._previousPeriodIndexForWeather = calculatedPeriodIndex; // Update tracker

           if (!this.state.isNight) {
               const isCloudy = this._generatePeriodWeather(); // Updates state internally
                this.state.isRaining = isCloudy && (Math.random() < RAIN_PROB_IF_CLOUDY);
                console.log(`Instance ${this.state.instanceId}: Day ${this.state.day}, Period ${calculatedPeriodIndex+1} Weather - Cloudy: ${isCloudy}, Raining: ${this.state.isRaining}, Light: ${this.state.currentLightMultiplier.toFixed(2)}, Drought: ${this.state.currentDroughtFactor.toFixed(2)}`);
           } else {
                if (oldPeriodIndex !== -1) { // Only generate night weather ONCE when transitioning into night
                   this._generateNightWeather(); // Updates state internally
                   this.state.players.forEach(p => { p.foliarUptakeAppliedThisNight = false; }); // Reset flag for night rain boost
                   console.log(`Instance ${this.state.instanceId}: Entering Night Weather - Raining: ${this.state.isRaining}`);
                } else {
                     // console.log(`Instance ${this.state.instanceId}: Still Night, weather unchanged.`); // Optional log
                }
           }
           this.state.currentPeriodIndex = calculatedPeriodIndex; // Update official state index AFTER weather gen
       }
       // console.log(`Instance ${this.state.instanceId}: updateTimeAndWeather END - isNight: ${this.state.isNight}, PeriodIndex: ${this.state.currentPeriodIndex}`);
   }

   // --- Physiology, Weather Gen, Allocation (Internal Helpers, unchanged) ---
   _updatePlayerPhysiology(playerState, deltaTime) { /* ... as before ... */
       const stomata = playerState.stomatalConductance; const effLA = Math.max(0, playerState.effectiveLA); const currentLA = Math.max(0, playerState.currentLA); const trunkVolume = Math.max(0, playerState.trunkWidth * playerState.trunkDepth * playerState.trunkHeight); let potentialCarbonGain = 0; if (!this.state.isNight) { potentialCarbonGain = PHOTOSYNTHESIS_RATE_PER_LA * effLA * stomata * this.state.currentLightMultiplier; } const respirationLoss = (RESPIRATION_RATE_PER_LA * currentLA + RESPIRATION_RATE_PER_TRUNK_VOL * trunkVolume); const waterLoss = TRANSPIRATION_RATE_PER_LA * effLA * stomata * this.state.currentDroughtFactor; let currentRecoveryRate = HYDRAULIC_RECOVERY_RATE; if (this.state.isRaining) { currentRecoveryRate *= RAIN_RECOVERY_BONUS_MULT; } const hydraulicChange = (currentRecoveryRate * (1 - stomata)) - waterLoss; playerState.hydraulicSafety += hydraulicChange * deltaTime; const potentialGainThisStep = potentialCarbonGain * deltaTime; const respirationLossThisStep = respirationLoss * deltaTime; const currentStorage = playerState.carbonStorage; const maxPossibleGain = Math.max(0, MAX_CARBON - currentStorage); const actualGain = Math.min(potentialGainThisStep, maxPossibleGain); playerState.carbonStorage = currentStorage + actualGain - respirationLossThisStep; playerState.carbonStorage = Math.max(0, playerState.carbonStorage); playerState.hydraulicSafety = Math.max(0, Math.min(playerState.maxHydraulic, playerState.hydraulicSafety)); if (playerState.hydraulicSafety < HYDRAULIC_DAMAGE_THRESHOLD) { const damageIncrease = CROWN_DIEBACK_RATE * deltaTime; playerState.damagedLAPercentage = Math.min(1, playerState.damagedLAPercentage + damageIncrease); playerState.effectiveLA = playerState.currentLA * (1 - playerState.damagedLAPercentage); } if (this.state.isNight) { if (this.state.isRaining && !playerState.foliarUptakeAppliedThisNight) { const boostAmount = NIGHT_RAIN_HYDRAULIC_BOOST; playerState.hydraulicSafety = Math.min(playerState.hydraulicSafety + boostAmount, playerState.maxHydraulic); playerState.foliarUptakeAppliedThisNight = true; } const timeIntoNight = this.state.timeInCycle - DAY_TOTAL_DURATION; if (timeIntoNight >= GROWTH_OFFSET_NIGHT && !playerState.growthAppliedThisCycle) { this._applyAllocation(playerState); playerState.growthAppliedThisCycle = true; } }
    }
   _generatePeriodWeather() { /* ... as before ... */ const isSunny = Math.random() < SUNNY_PROB; const isCloudy = !isSunny; this.state.currentLightMultiplier = isCloudy ? LIGHT_MULT_CLOUDY : LIGHT_MULT_SUNNY; const droughtVariation = (Math.random() * 2 - 1) * DROUGHT_VARIATION; this.state.currentDroughtFactor = Math.max(0.1, DROUGHT_MULT_BASE + droughtVariation); return isCloudy; }
   _generateNightWeather() { /* ... as before ... */ const isConceptuallyCloudy = Math.random() >= SUNNY_PROB; this.state.isRaining = isConceptuallyCloudy && (Math.random() < RAIN_PROB_IF_CLOUDY); this.state.currentLightMultiplier = 0; this.state.currentDroughtFactor = DROUGHT_MULT_BASE; }
   _applyAllocation(playerState) { /* ... as before ... */
       const available = Math.floor(playerState.carbonStorage); if (available <= 0) return; const savingsPercent = Math.max(0, Math.min(100, playerState.lastSavingsPercent)); const growthRatioPercent = Math.max(0, Math.min(100, playerState.lastGrowthRatioPercent)); const carbonToSpend = Math.floor(available * (1 - savingsPercent / 100)); if (carbonToSpend <= 0) return; const actualCarbonForGrowth = Math.floor(carbonToSpend * (growthRatioPercent / 100)); const carbonForSeeds = carbonToSpend - actualCarbonForGrowth; const seedsToMake = Math.floor(carbonForSeeds / SEED_COST); const actualCarbonForSeeds = seedsToMake * Config.SEED_COST; const totalSpent = actualCarbonForGrowth + actualCarbonForSeeds; if (totalSpent > available + 0.01 || totalSpent < 0) { return; } playerState.carbonStorage -= totalSpent; playerState.seedCount += seedsToMake; if (actualCarbonForGrowth > 0) { const currentTrunkVolume = (playerState.trunkWidth || 0.1) * (playerState.trunkDepth || 0.1) * (playerState.trunkHeight || 0.1); const currentBiomassEstimate = Math.max(1, playerState.currentLA + currentTrunkVolume); const biomassToAdd = actualCarbonForGrowth / GROWTH_COST_PER_LA; const growthFactor = 1 + (biomassToAdd / currentBiomassEstimate); playerState.currentLA *= growthFactor; playerState.trunkHeight *= growthFactor; playerState.trunkWidth = Math.sqrt(playerState.currentLA * k_TA_LA_RATIO); playerState.trunkDepth = playerState.trunkWidth; playerState.maxHydraulic = BASE_HYDRAULIC + HYDRAULIC_SCALE_PER_LA * playerState.currentLA; playerState.effectiveLA = playerState.currentLA * (1 - playerState.damagedLAPercentage); }
    }

   // --- Countdown Logic (methods as before) ---
   startCountdown() { /* ... as before ... */ if (this.state.gamePhase !== 'lobby' || this.state.countdownIntervalId) { return; } if (this.state.mode !== 'multi') { return; } const activePlayerCount = this.getNonSpectatorPlayers().length; if (activePlayerCount === 0) { return; } console.log(`GameInstance ${this.state.instanceId}: Starting ${COUNTDOWN_DURATION}s countdown...`); this.setGamePhase('countdown'); this.state.countdownTimer = COUNTDOWN_DURATION; this.broadcastState(); this.state.countdownIntervalId = setInterval(() => { if (this.state.gamePhase !== 'countdown' || this.state.countdownTimer === null) { this.stopCountdown(); return; } const currentActivePlayers = this.getNonSpectatorPlayers().length; if (currentActivePlayers === 0) { this.stopCountdown(); this.setGamePhase('lobby'); this.broadcastState(); return; } const newTime = this.state.countdownTimer - 1; this.state.countdownTimer = newTime; this.broadcastState(); if (newTime <= 0) { this.stopCountdown(); this._prepareAndStartGame(); } }, 1000); }
   stopCountdown() { /* ... as before ... */ if (this.state.countdownIntervalId) { clearInterval(this.state.countdownIntervalId); this.state.countdownIntervalId = null; } }

   // --- Start Game Helper (methods as before) ---
   _prepareAndStartGame() { /* ... as before ... */ this.stopCountdown(); if (this.state.gamePhase === 'playing') { this.startSimulationLoop(); return; } console.log(`GameInstance ${this.state.instanceId}: Preparing players and starting game...`); this.setGamePhase('playing'); let playersMarkedAliveCount = 0; this.state.players.forEach(playerState => { if (playerState.isSpectator || playerState.isAI) { playerState.isAlive = false; return; } if (!playerState.hasChosenSpawn) { this._assignDefaultSpawn(playerState); } else if (!playerState.spawnPoint) { this._assignDefaultSpawn(playerState); } if (!playerState.isAlive) { playerState.isAlive = true; playersMarkedAliveCount++; } else { playersMarkedAliveCount++; } playerState.growthAppliedThisCycle = false; playerState.foliarUptakeAppliedThisNight = false; }); if (playersMarkedAliveCount === 0 && this.state.players.size > 0) { this.resetGame(); this.broadcastState(); return; } console.log(`GameInstance ${this.state.instanceId}: Marked ${playersMarkedAliveCount} players alive.`); this.broadcastState(); this.startSimulationLoop(); }
   _assignDefaultSpawn(playerState) { /* ... as before ... */ const nonSpectatorPlayers = this.getNonSpectatorPlayers(); const index = nonSpectatorPlayers.findIndex(ap => ap.id === playerState.id); const activePlayerCount = nonSpectatorPlayers.length || 1; const angle = (index / activePlayerCount) * Math.PI * 2 + Math.random()*0.1; const radius = 5 + Math.random() * 5; const baseHeight = ISLAND_LEVEL; playerState.spawnPoint = { x: radius * Math.cos(angle), y: baseHeight, z: radius * Math.sin(angle) }; playerState.hasChosenSpawn = true; }

   // --- Reset & End Game (methods as before) ---
   resetGame() { /* ... as before ... */ console.log(`GameInstance ${this.state.instanceId}: Resetting game...`); this.stopSimulationLoop(); this.stopCountdown(); Object.assign(this.state, { day: 1, timeInCycle: 0.0, currentPeriodIndex: -1, isNight: false, currentLightMultiplier: LIGHT_MULT_SUNNY, currentDroughtFactor: DROUGHT_MULT_BASE, isRaining: false, gamePhase: 'lobby', countdownTimer: null, allowPlayerCountdownStart: true }); this.state.players.forEach(p => { const initialLA = INITIAL_LEAF_AREA; const maxHydraulic = BASE_HYDRAULIC + HYDRAULIC_SCALE_PER_LA * initialLA; p.isAlive = false; p.hasChosenSpawn = false; p.spawnPoint = { x: 0, y: ISLAND_LEVEL, z: 0 }; p.carbonStorage = INITIAL_CARBON; p.hydraulicSafety = Math.min(INITIAL_HYDRAULICS, maxHydraulic); p.maxHydraulic = maxHydraulic; p.currentLA = initialLA; p.effectiveLA = initialLA; p.trunkHeight = INITIAL_TRUNK_HEIGHT; p.trunkWidth = Math.sqrt(initialLA * k_TA_LA_RATIO); p.trunkDepth = p.trunkWidth; p.seedCount = 0; p.damagedLAPercentage = 0; p.stomatalConductance = 0.5; p.lastSavingsPercent = 50; p.lastGrowthRatioPercent = 50; p.foliarUptakeAppliedThisNight = false; p.growthAppliedThisCycle = false; }); console.log(`GameInstance ${this.state.instanceId}: Reset complete. Phase: ${this.state.gamePhase}`); }
   endGame(reason = "Game ended.") { /* ... as before ... */ console.log(`GameInstance ${this.state.instanceId}: endGame called. Reason: ${reason}`); this.stopSimulationLoop(); this.stopCountdown(); this.setGamePhase('ended'); let winnerId = null; let maxSeeds = -1; this.state.players.forEach(p => { if (!p.isSpectator && p.seedCount > maxSeeds) { maxSeeds = p.seedCount; winnerId = p.id; } }); console.log(`GameInstance ${this.state.instanceId}: Winner: ${winnerId || 'None'} with ${maxSeeds} seeds.`); this.io.to(this.state.roomId).emit('gameOver', { reason: reason, winnerId: winnerId }); this.broadcastState(); setTimeout(() => { this.resetGame(); this.broadcastState(); }, 2000); }

   // --- Broadcasting (method as before) ---
   broadcastState() { const snapshot = this.getSnapshot(); this.io.to(this.state.roomId).emit('gameStateUpdate', snapshot); }

   // --- Utility (method as before) ---
   findSocket(socketId) { const socket = this.io.sockets.sockets.get(socketId); return socket; }
}

--- FILE: client/environment.js ---
// environment.js
// Manages visual aspects of the game environment (lighting, sky, effects)

import * as THREE from 'three';
import { scene, sunLight, ambientLight, camera } from './sceneSetup.js';
import { gameState } from './gameState.js'; // Import gameState to read server state

// --- Configuration (Keep as before) ---
const skyColors = { day_sunny: new THREE.Color(0x87CEEB), day_cloudy: new THREE.Color(0xB0C4DE), night: new THREE.Color(0x000020) };
const fogColors = { day_sunny: new THREE.Color(0x87CEEB), day_cloudy: new THREE.Color(0xA9A9A9), night: new THREE.Color(0x000010) };
const FOG_DAY_NEAR = 50; const FOG_DAY_FAR = 150;
const FOG_NIGHT_NEAR = 9999; const FOG_NIGHT_FAR = 10000;
const ambientIntensity = { day_sunny: 0.6, day_cloudy: 0.4, night: 0.1 };
const sunIntensity = { day_sunny: 1.5, day_cloudy: 0.5, night: 0.0 };
const starCount = 7000;
const SMOOTHING_SPEED = 1.5;
const RAIN_COUNT = 7000; const RAIN_AREA_SIZE = 60; const RAIN_HEIGHT = 50; const RAIN_SPEED = 80; const RAIN_COLOR = 0xAAAAFF;

// --- Module State for Lerping (Keep as before) ---
let stars = null;
let currentAmbientIntensity = ambientIntensity.day_sunny; // Initial default
let currentSunIntensity = sunIntensity.day_sunny;
let currentSkyColor = skyColors.day_sunny.clone();
let currentFogColor = fogColors.day_sunny.clone();
let currentFogNear = FOG_DAY_NEAR;
let currentFogFar = FOG_DAY_FAR;

let targetAmbientIntensity = currentAmbientIntensity;
let targetSunIntensity = currentSunIntensity;
let targetSkyColor = currentSkyColor.clone();
let targetFogColor = currentFogColor.clone();
let targetFogNear = currentFogNear;
let targetFogFar = currentFogFar;
let targetStarsVisible = false;

// Rain State
let rainParticles = null;
let rainGeometry = null;
let rainMaterial = null;
let rainPositions = null;
let rainVelocities = null;

// --- Initialization Functions (Keep createStars, createRainSystem as before) ---
export function createStars() {
    if (stars) { /* cleanup */ if(stars.geometry) stars.geometry.dispose(); if(stars.material) stars.material.dispose(); if(scene) scene.remove(stars); stars = null; }
    const starGeometry = new THREE.BufferGeometry(); const starVertices = [];
    const starMaterial = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 0.4, sizeAttenuation: true, transparent: true, opacity: 0.9, depthWrite: false, blending: THREE.AdditiveBlending });
    const radius = 500;
    for (let i = 0; i < starCount; i++) { const phi = Math.acos(-1 + (2 * Math.random())); const theta = Math.random() * Math.PI * 2; const x = radius * Math.sin(phi) * Math.cos(theta); const y = radius * Math.cos(phi); const z = radius * Math.sin(phi) * Math.sin(theta); if (y > -radius * 0.05) starVertices.push(x, y, z); }
    starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3)); stars = new THREE.Points(starGeometry, starMaterial); stars.name = "stars"; stars.visible = false; stars.renderOrder = 1; if (scene) scene.add(stars);
    console.log("Stars created (Additive White) and added to scene.");
}
export function createRainSystem() {
    if (rainParticles) return; rainGeometry = new THREE.BufferGeometry();
    rainMaterial = new THREE.PointsMaterial({ color: RAIN_COLOR, size: 0.08, sizeAttenuation: true, transparent: true, opacity: 0.6, blending: THREE.NormalBlending, depthWrite: false });
    rainPositions = new Float32Array(RAIN_COUNT * 3); rainVelocities = new Array(RAIN_COUNT); const halfArea = RAIN_AREA_SIZE / 2;
    for (let i = 0; i < RAIN_COUNT; i++) { const i3 = i * 3; rainPositions[i3 + 0] = Math.random() * RAIN_AREA_SIZE - halfArea; rainPositions[i3 + 1] = Math.random() * RAIN_HEIGHT; rainPositions[i3 + 2] = Math.random() * RAIN_AREA_SIZE - halfArea; rainVelocities[i] = -RAIN_SPEED * (0.8 + Math.random() * 0.4); }
    rainGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3)); rainParticles = new THREE.Points(rainGeometry, rainMaterial); rainParticles.name = "rain"; rainParticles.visible = false; if (scene) { scene.add(rainParticles); console.log("Rain particle system created."); } else { console.error("Scene not available for adding rain system."); }
}


// --- Update Functions ---

/**
 * Sets the TARGET visual state based on conditions read from gameState.
 * Now takes arguments derived from gameState in main.js.
 * @param {boolean} isNight
 * @param {boolean} isCloudy - True if light multiplier indicates cloudy
 * @param {boolean} isRaining
 */
export function setWeatherTargets(isNight, isCloudy, isRaining) {
    if (isNight) {
        targetAmbientIntensity = ambientIntensity.night; targetSunIntensity = sunIntensity.night;
        targetSkyColor = skyColors.night; targetFogColor = fogColors.night;
        targetFogNear = FOG_NIGHT_NEAR; targetFogFar = FOG_NIGHT_FAR;
        targetStarsVisible = !isRaining; // Stars visible only if night and not raining
    } else { // Daytime
        targetAmbientIntensity = isCloudy ? ambientIntensity.day_cloudy : ambientIntensity.day_sunny;
        targetSunIntensity = isCloudy ? sunIntensity.day_cloudy : sunIntensity.day_sunny;
        targetSkyColor = isCloudy ? skyColors.day_cloudy : skyColors.day_sunny;
        targetFogColor = isCloudy ? fogColors.day_cloudy : fogColors.day_sunny;
        targetFogNear = FOG_DAY_NEAR; targetFogFar = FOG_DAY_FAR;
        targetStarsVisible = false; // No stars during day
    }
    // console.log(`ENV: Targets set - Night:${isNight}, Cloudy:${isCloudy}, Raining:${isRaining}, StarsTarget:${targetStarsVisible}`);
}

// Updates the actual visual environment state via lerping towards targets
// Reads targets directly, no need to read gameState here.
export function updateEnvironmentVisuals(deltaTime) {
    if (!scene || !scene.fog || !ambientLight || !sunLight) return; // Ensure scene objects exist

    const lerpFactor = Math.min(1.0, deltaTime * SMOOTHING_SPEED);

    // Lerp intensities
    currentAmbientIntensity = THREE.MathUtils.lerp(currentAmbientIntensity, targetAmbientIntensity, lerpFactor);
    currentSunIntensity = THREE.MathUtils.lerp(currentSunIntensity, targetSunIntensity, lerpFactor);

    // Lerp colors
    currentSkyColor.lerp(targetSkyColor, lerpFactor);
    currentFogColor.lerp(targetFogColor, lerpFactor);

    // Lerp fog distances
    currentFogNear = THREE.MathUtils.lerp(currentFogNear, targetFogNear, lerpFactor);
    currentFogFar = THREE.MathUtils.lerp(currentFogFar, targetFogFar, lerpFactor);

    // Apply current values
    ambientLight.intensity = currentAmbientIntensity;
    sunLight.intensity = currentSunIntensity;
    scene.background = currentSkyColor;
    scene.fog.color = currentFogColor;
    scene.fog.near = currentFogNear;
    scene.fog.far = currentFogFar;

    // Update star visibility (instant change is fine)
    if (stars && stars.visible !== targetStarsVisible) {
        stars.visible = targetStarsVisible;
        // console.log(`ENV: Stars visibility set to ${targetStarsVisible}`);
    }
}

// Makes rain visible
export function startRain() {
    if (rainParticles && !rainParticles.visible) { // Only change if not already visible
        rainParticles.visible = true;
        console.log("ENV: Starting rain effect.");
    }
}

// Makes rain invisible
export function stopRain() {
     if (rainParticles && rainParticles.visible) { // Only change if visible
        rainParticles.visible = false;
        console.log("ENV: Stopping rain effect.");
    }
}

// Animates the raindrops (Keep as before)
export function updateRain(deltaTime) {
    if (!rainParticles || !rainParticles.visible || !rainPositions || !rainVelocities) return;
    const positions = rainParticles.geometry.attributes.position.array; const halfArea = RAIN_AREA_SIZE / 2;
    for (let i = 0; i < RAIN_COUNT; i++) { const i3 = i * 3; positions[i3 + 1] += rainVelocities[i] * deltaTime; if (positions[i3 + 1] < 0) { positions[i3 + 0] = Math.random() * RAIN_AREA_SIZE - halfArea; positions[i3 + 1] = RAIN_HEIGHT + Math.random() * 5; positions[i3 + 2] = Math.random() * RAIN_AREA_SIZE - halfArea; } }
    rainParticles.geometry.attributes.position.needsUpdate = true;
}

--- FILE: server/game/simulation.js ---
// server/game/simulation.js
// Core simulation logic has been moved into the GameInstance class (server/game/GameInstance.js)
// This file is kept temporarily for reference or can be deleted.

console.log("server/game/simulation.js loaded (logic moved to GameInstance)");

// export function updateSimulationTick(deltaTime, io) { ... } // REMOVED
// function updatePlayerPhysiology(playerState, globalState, deltaTime) { ... } // REMOVED
// function generatePeriodWeather(globalState) { ... } // REMOVED
// function generateNightWeather(globalState) { ... } // REMOVED
// function applyAllocation(playerState) { ... } // REMOVED

--- FILE: server/game/GameState.js ---
// server/game/GameState.js
import * as Config from '../config.js'; // Use server config

// --- Core State Variables ---
let globalGameState = {
    day: 1,
    timeInCycle: 0.0,
    currentPeriodIndex: -1, // -1: Initial/Night, 0-2: Day periods
    isNight: false,
    currentLightMultiplier: Config.LIGHT_MULT_SUNNY, // Initial assumption
    currentDroughtFactor: Config.DROUGHT_MULT_BASE,
    isRaining: false,
    gamePhase: 'lobby', // 'lobby', 'countdown', 'playing', 'ended'
    countdownTimer: null, // Holds remaining countdown seconds, or null
};
let players = {}; // { socketId: playerData }

// --- State Management Functions ---

/** Creates initial state for a new player. */
function initializePlayerState(socketId) {
    const initialLA = Config.INITIAL_LEAF_AREA;
    const baseHeight = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
    const maxHydraulic = Config.BASE_HYDRAULIC + Config.HYDRAULIC_SCALE_PER_LA * initialLA;
    return {
        id: socketId,
        // --- Attributes ---
        playerName: `Player_${socketId.substring(0, 4)}`,
        leafColor: '#228B22', trunkColor: '#8B4513',
        spawnPoint: { x: 0, y: baseHeight, z: 0 }, // Default, updated later
        isAlive: false, // Starts not alive
        hasChosenSpawn: false,
        isSpectator: false, // Defaults to false
        // --- Resources ---
        carbonStorage: Config.INITIAL_CARBON, hydraulicSafety: Math.min(Config.INITIAL_HYDRAULICS, maxHydraulic), maxHydraulic: maxHydraulic,
        // --- Size & Structure ---
        currentLA: initialLA, effectiveLA: initialLA, trunkHeight: Config.INITIAL_TRUNK_HEIGHT,
        trunkWidth: Math.sqrt(initialLA * Config.k_TA_LA_RATIO), trunkDepth: Math.sqrt(initialLA * Config.k_TA_LA_RATIO),
        // --- Status & Output ---
        seedCount: 0, damagedLAPercentage: 0,
        // --- Inputs (Server authoritative) ---
        stomatalConductance: 0.5, lastSavingsPercent: 50, lastGrowthRatioPercent: 50,
        // --- Internal Sim State ---
        foliarUptakeAppliedThisNight: false, growthAppliedThisCycle: false,
    };
}

/** Adds a new player to the state. */
export function addPlayer(socketId) {
    if (!players[socketId]) {
        players[socketId] = initializePlayerState(socketId);
        console.log(`GameState: Added player ${socketId}. Total: ${Object.keys(players).length}`);
    } else {
        console.warn(`GameState: Player ${socketId} already exists.`);
    }
}

/** Removes a player from the state. */
export function removePlayer(socketId) {
    if (players[socketId]) {
        delete players[socketId];
        console.log(`GameState: Removed player ${socketId}. Remaining: ${Object.keys(players).length}`);
        return true;
    }
    return false;
}

/** Retrieves state for a specific player. */
export function getPlayerState(socketId) {
    return players[socketId] || null;
}

/** Retrieves the entire players object. */
export function getAllPlayers() {
    return players;
}

/** Retrieves the global game state object. */
export function getGlobalState() {
    return globalGameState;
}

/** Updates specific properties of the global state. */
export function updateGlobalState(updates) {
     Object.assign(globalGameState, updates);
}

/** Sets the current game phase. */
export function setGamePhase(phase) {
    if (['lobby', 'countdown', 'playing', 'ended'].includes(phase)) {
        if (globalGameState.gamePhase !== phase) {
             console.log(`GameState: Changing phase from ${globalGameState.gamePhase} to ${phase}`);
             globalGameState.gamePhase = phase;
             if (phase !== 'countdown') globalGameState.countdownTimer = null; // Reset timer unless entering countdown
        }
    } else { console.error(`GameState: Invalid phase: ${phase}`); }
}

/** Resets global state variables to defaults. */
export function resetGlobalStateValues() {
     console.log("GameState: Resetting global values...");
     Object.assign(globalGameState, {
        day: 1, timeInCycle: 0.0, currentPeriodIndex: -1, isNight: false,
        currentLightMultiplier: Config.LIGHT_MULT_SUNNY, currentDroughtFactor: Config.DROUGHT_MULT_BASE,
        isRaining: false, gamePhase: 'lobby', countdownTimer: null
     });
}

--- FILE: README.md ---
# FOREST ROYALE: A Plant Ecophysiology Game

## 1. Overview

**Forest Royale** (formerly Island Canopy Sim) is an interactive web-based simulation game designed to teach fundamental concepts of plant ecophysiology, specifically focusing on tree "decision-making" under environmental constraints. Developed as part of PhD research in plant ecophysiology, this project uses trees as a model system for studying resource allocation and survival strategies in sessile organisms facing dynamic environmental conditions.

The primary goal is to create an engaging, accessible (playable on web/mobile), and scientifically grounded experience. The game aims to translate complex physiological processes and trade-offs into intuitive game mechanics.

We approach trees not just as passive responders, but as agents making strategic "decisions" (e.g., stomatal aperture, carbon allocation) to maximize lifetime fitness (represented by reproductive output) within the bounds of physical and chemical laws governing water transport and photosynthesis, under a changing environment. The game now includes a client-server architecture to support multiplayer gameplay.

## 2. Core Concept

Players control an individual tree on a simulated island, competing against others (in multiplayer) or playing solo. The objective is to survive environmental challenges (dynamic light, drought, rain) and maximize lifetime seed production. This requires balancing competing demands:

*   **Growth:** Investing carbon into increasing height and leaf area can improve light capture but increases water demand and respiration costs.
*   **Reproduction:** Allocating carbon to seeds directly contributes to the player's score but detracts from growth and reserves.
*   **Survival (Savings & Safety):** Maintaining sufficient carbon reserves and hydraulic safety is essential to survive periods of stress (e.g., drought, low light, cloudy periods) and nightly respiration costs.

Players make real-time decisions (stomatal aperture) and periodic strategic decisions (carbon allocation) to navigate these trade-offs in response to fluctuating weather conditions, broadcast uniformly from a central server.

## 3. Scientific Principles Demonstrated

This simulation aims to illustrate key concepts in plant ecophysiology:

*   **Resource Allocation Trade-offs:** The fundamental conflict between allocating limited resources (carbon) towards growth, reproduction, storage (savings), and defense (implicit via survival).
*   **Photosynthesis-Transpiration Compromise:** The need to open stomata for CO2 uptake (photosynthesis) inevitably leads to water loss (transpiration), requiring players to manage stomatal aperture based on water availability (hydraulic safety) and carbon demand, influenced by current weather.
*   **Hydraulic Limits & Dynamics:** Demonstrating that exceeding the water transport capacity (represented by low `hydraulicSafety`) leads to physiological damage (canopy dieback) and potentially death. Hydraulic safety is dynamic, influenced by transpiration (affected by drought factor) and recovery (boosted by rain, potential night uptake). The maximum hydraulic buffer scales with tree size.
*   **Carbon Balance:** The dynamic interplay between carbon gain (photosynthesis, affected by light levels) and carbon loss (respiration, growth, reproduction), requiring players to manage reserves (capped at `MAX_CARBON`) to avoid starvation.
*   **Environmental Response:** How changing conditions (light intensity, drought factor, rain) broadcast by the server affect physiological processes and strategic decisions for all players simultaneously.
*   **Within-Generation Plasticity:** How a tree's "strategy" (control inputs) can change over its lifetime based on its state and environment.
*   **(Future) Competition:** How interactions with neighbors (e.g., shading) influence resource capture and survival.

## 4. Current Features & Architecture (As of this README update)

*   **Client-Server Architecture:**
    *   **Node.js Backend:** Uses Express for basic routing and Socket.IO for real-time WebSocket communication.
    *   **Authoritative Server:** The server manages the core game state (all players' resources, positions, time, weather), runs the simulation loop, and broadcasts state updates to all clients.
    *   **Client-Side Rendering:** The client receives state updates and renders the 3D scene (Three.js), updates UI, and sends user input back to the server.
*   **Game Modes & Flow:**
    *   **Single Player:** Accessed via dedicated button. Server detects single connection, bypasses lobby/countdown, and starts the game immediately.
    *   **Multiplayer (Lobby):** Accessed via dedicated button. Players join a shared lobby.
        *   **Spawn Selection:** Players click on the 3D island model during the lobby phase to select a starting location. Visual markers indicate chosen spots. Server validates positions (bounds, proximity to others). Players who don't choose are assigned a random offset position near the center at game start.
        *   **Countdown:** Any player in the lobby can initiate a short (e.g., 5s) countdown.
        *   **Game Start:** Game begins for all connected players after the countdown.
*   **Shared Environment:** All players experience the same synchronized day/night cycle and dynamic weather conditions (Sunny/Cloudy, Drought Factor, Rain) generated and broadcast by the server.
*   **Visuals & Effects:**
    *   3D island environment (Three.js).
    *   Synchronized sky color, fog, and lighting transitions.
    *   Rain particle effect during rainy periods.
    *   Starfield effect on clear nights.
*   **Core Tree Model:**
    *   Represents multiple player trees visually.
    *   Handles growth (trunk/canopy scaling) based on server state.
    *   Tiled canopy visually degrades based on `damagedLAPercentage` from server.
    *   Trees positioned according to chosen or assigned spawn points.
*   **Player Controls & State:**
    *   Real-time stomatal aperture slider input sent to server.
    *   Nightly allocation strategy (Savings %, Growth/Seed Ratio %) sliders' input sent to server.
    *   Server uses player inputs for its simulation calculations.
    *   Client UI displays player-specific resource bars (Carbon, Hydraulics) and seed count based on server data.
*   **Real-time Leaderboard:** UI panel displays all connected players, sorted by seed count (during game/end) or name (in lobby), indicating alive/dead status.
*   **Game Over:**
    *   Server detects when all players are dead (`isAlive=false`).
    *   Server determines winner (player with highest seed count).
    *   Server broadcasts `gameOver` event with reason and winner ID.
    *   Client displays a modal with results. "Play Again" button reloads client, returning to landing page. Server resets game state upon last player disconnect.
*   **Refactored Code Structure:**
    *   Client-side code moved into a `client/` directory.
    *   Server-side code moved into a `server/` directory, further modularized into `game/` (state, simulation, logic) and `network/` (connection, broadcast) sub-directories.
    *   Client and Server maintain separate `config.js` files for their respective needs.

## 5. Technology Stack

*   **Backend:** Node.js, Express, Socket.IO
*   **Frontend:** HTML5, CSS3, JavaScript (ES6 Modules)
*   **3D Rendering:** Three.js
*   **Camera Controls:** `OrbitControls`

## 6. Project Structure (Current)

```
.
├── .gitignore
├── README.md
├── client/
│   ├── config.js             # Client-specific configuration
│   ├── environment.js
│   ├── game.html
│   ├── gameState.js          # Client-side state cache
│   ├── index.html            # Landing page
│   ├── index.js              # Landing page script
│   ├── main.js               # Client entry point, game loop
│   ├── sceneSetup.js
│   ├── settings.html
│   ├── settings.js
│   ├── style.css
│   ├── tree.js               # Handles tree visuals
│   └── ui/                   # UI modules
│       ├── controlsHandlers.js
│       ├── elements.js
│       ├── gameOver.js
│       ├── leaderboard.js    # (Empty)
│       ├── messageHandler.js
│       ├── setupListeners.js
│       └── update.js
└── server/
    ├── config.js             # Server-specific configuration
    ├── game/
    │   ├── GameState.js      # Manages server game state
    │   ├── gameLogic.js      # High-level logic (start/end game, countdown)
    │   └── simulation.js     # Core physiological simulation tick
    ├── network/
    │   ├── connection.js     # Handles socket connections, disconnections, events
    │   └── stateBroadcaster.js # Creates and sends state snapshots
    ├── node_modules/
    ├── package-lock.json
    ├── package.json
    └── server.js             # Server entry point, Express/SocketIO setup, main loop interval
```

## 7. Getting Started / Running the Project

1.  **Clone Repository:** Get the project files.
2.  **Install Server Dependencies:** Navigate to the `server/` directory and run `npm install`.
3.  **Run the Server:** From the `server/` directory, run `node server.js`.
4.  **Open in Browser:** Navigate to `http://localhost:3000`.
5.  **Play:** Choose "Single Player" or "Multiplayer" (open multiple tabs/browsers for multiplayer testing).

## 8. Gameplay Mechanics (Multiplayer Focus)

*   **Objective:** Be the player with the most seeds when the game ends (currently when all players die).
*   **Lobby:** When joining multiplayer, you enter a lobby. Click on the island to choose your start location (green marker confirms your spot, orange markers show others'). Anyone can click "Start Game Countdown".
*   **Gameplay:** Once started, control your tree's stomata and allocation strategy. Monitor resources. All players experience the same weather. See other players' trees grow/die in real-time.
*   **Leaderboard:** Tracks seed counts and player status live.
*   **Game End:** Game ends when all trees are dead. A modal shows the winner.

## 9. Key Learnings & Decisions During Multiplayer Implementation

*   **Client-Server Split:** Clearly separated simulation logic (server) from rendering/input handling (client).
*   **Authoritative Server:** Server dictates all game state; client is a "dumb" renderer of that state.
*   **State Synchronization:** Using Socket.IO to broadcast regular state snapshots (`gameStateUpdate`). Key challenge is balancing data volume with update frequency.
*   **Input Handling:** Client immediately sends input (slider changes, button clicks) to server; server validates and updates its state, which is then reflected back in the next broadcast.
*   **Game Flow Management:** Server manages transitions between phases (lobby, countdown, playing, ended). Connection/disconnection logic needs careful handling to maintain correct state and trigger resets.
*   **Refactoring:** Moved server logic into modules (`game/`, `network/`) and client code into `client/` directory for better organization as complexity increased.
*   **Configuration:** Separated client (`client/config.js`) and server (`server/config.js`) configurations.
*   **Spawn Selection:** Implemented via raycasting on the client, validation and state update on the server, feedback via markers and state broadcasts. Default server-side assignment handles non-choosers.

## 10. Immediate Next Steps (Current Focus)

1.  **Spectator Mode:**
    *   Add "Spectate" button/intent.
    *   Server identifies spectators, excludes from gameplay logic.
    *   Client UI adjusts for spectators (hides controls/status).
2.  **Admin Panel:**
    *   Password-protected `/admin` route.
    *   Admin client page (`admin.html`, `admin.js`) with game view + control buttons.
    *   Server authentication for admin sockets.
    *   Server listeners for admin commands (Force Start/End, Reset Countdown) executing `gameLogic` functions.
3.  **Refine Spawn Markers:** Improve visual appearance/feedback for spawn markers.
4.  **Deployment:** Deploy the application to a suitable host (targeting PaaS like Render/Fly.io initially).

## 11. Future Directions / Longer Term Roadmap

*   **Environment Polish:** Improve visuals (rain, clouds, wind effects), add sound.
*   **Gameplay Balancing:** Tune rates, costs, weather probabilities based on playtesting.
*   **Player Interaction:** Implement shading effects between player trees.
*   **Climate Catastrophes:** Add rare server-triggered events.
*   **Persistence:** Leaderboards across multiple game rounds, potentially player accounts.
*   **Robustness:** Improve server stability, error handling, reconnection logic.
*   **Enhanced Scientific Accuracy:** More complex physiology models (water potential, nutrients).
*   **Educational Context:** In-game tooltips, links to concepts.
*   **(Maybe) Different Game Modes:** E.g., timed rounds, specific objectives.

## 12. Contributing

[Optional: Add guidelines if you plan for others to contribute]

## 13. License

[Optional: Add a license]

## 14. Contact

Developed by [Your Name/Alias], PhD Student in Plant Ecophysiology.
[Optional: Add contact email or link]

--- FILE: client/index.js ---
// client/index.js (Landing Page Logic)

document.addEventListener('DOMContentLoaded', () => {
    const singlePlayerButton = document.getElementById('start-single-player');
    const multiPlayerButton = document.getElementById('start-multi-player');
    const spectateButton = document.getElementById('spectate-game');
    const settingsButton = document.getElementById('open-settings');
    const adminButton = document.getElementById('admin-panel-button'); // Get admin button

    // Function to set mode and navigate to game page
    function startGame(mode) {
        console.log(`Index: Setting mode to ${mode} and navigating to /game`);
        sessionStorage.setItem('gameModeIntent', mode); // Store intent
        window.location.href = '/game'; // Navigate to the game page
    }

    if (singlePlayerButton) {
        singlePlayerButton.addEventListener('click', () => {
            startGame('single');
        });
    }

    if (multiPlayerButton) {
        multiPlayerButton.disabled = false; // Ensure enabled
        multiPlayerButton.textContent = 'Multiplayer';
        multiPlayerButton.addEventListener('click', () => {
             startGame('multi');
        });
    }

    if (spectateButton) {
         spectateButton.addEventListener('click', () => {
             startGame('spectate');
         });
    }

    if (settingsButton) {
        settingsButton.addEventListener('click', () => {
            console.log("Navigating to Settings...");
            window.location.href = '/settings';
        });
    }

    // +++ Add listener for Admin Panel button +++
    if (adminButton) {
        adminButton.addEventListener('click', () => {
            console.log("Admin Panel button clicked.");
            // Use prompt() for simple password input
            const password = prompt("Enter Admin Password:", "");

            // Check if the user entered a password (prompt wasn't cancelled or left empty)
            if (password !== null && password !== "") {
                 console.log("Password entered, navigating to Admin Panel...");
                 // Navigate to the admin route with the password as a query parameter
                 window.location.href = `/admin?pw=${encodeURIComponent(password)}`;
            } else {
                 console.log("Admin password prompt cancelled or empty.");
                 // Optionally show a message or just do nothing
                 if (password === "") {
                     alert("Password cannot be empty.");
                 }
            }
        });
    }
});

--- FILE: client/style.css ---
/* client/style.css */

/* === Global & Base Styles === */
body, html {
    margin: 0;
    padding: 0;
    overflow: hidden; /* Prevent scrollbars on the page */
    font-family: sans-serif;
    background-color: #333; /* Fallback background */
    color: #eee;       /* Default text color */
}

#game-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0; /* Ensure canvas is behind UI panels */
}

#game-canvas {
    display: block;
    width: 100%;
    height: 100%;
}

/* === General UI Panel Styling === */
.ui-panel {
    position: absolute; /* Position panels absolutely relative to body/viewport */
    background-color: rgba(0, 0, 0, 0.65); /* Slightly darker background for panels */
    border: 1px solid #444;
    border-radius: 6px;
    padding: 10px;
    box-sizing: border-box; /* Include padding and border in element's total width and height */
    color: #eee;
    z-index: 10; /* Ensure panels are above the canvas */
    pointer-events: auto; /* Allow interaction with panels */
    font-size: 14px; /* Base font size for panels */
}

.ui-panel h3, .ui-panel h4 { /* General headings for panels */
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 1.0em; /* Relative to panel base font size */
    color: #ddd;
    border-bottom: 1px solid #555;
    padding-bottom: 5px;
}

.ui-panel p, .ui-panel div, .ui-panel label, .ui-panel span, .ui-panel li {
    font-size: 0.9em; /* Consistent font size within panels */
    line-height: 1.4; /* Improve readability */
}

/* === Specific Panel Positioning === */

/* --- Top Left Info Panel --- */
#top-left-info {
    top: 10px;
    left: 10px;
    min-width: 180px; /* Ensure some minimum width */
}
#top-left-info p {
    margin: 4px 0; /* Tighter spacing */
}
#top-left-info span {
    font-weight: bold;
    color: #ffc107; /* Amber highlight for values */
}
.message { /* Message Log styling */
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px dashed #555;
    color: #ffcc00;
    font-weight: bold;
    min-height: 1.2em;
    font-size: 0.85em; /* Smaller message text */
}
.message.info { color: #ffcc00; } /* Default/Info */
.message.success { color: #4CAF50; } /* Green */
.message.warning { color: #ff9800; } /* Orange */
.message.error { color: #f44336; } /* Red */


/* --- Top Right Leaderboard --- */
#top-right-leaderboard {
    top: 10px;
    right: 10px;
    min-width: 200px;
    max-width: 280px; /* Limit width */
    background-color: rgba(0, 0, 0, 0.5); /* More translucent */
}
#top-right-leaderboard h4 {
    font-size: 0.9em;
    text-align: center;
    border: none; /* Remove border for header */
    padding-bottom: 0;
    margin-bottom: 5px;
}
#top-right-leaderboard ul {
    list-style: none;
    padding: 0;
    margin: 0;
    max-height: 200px; /* Limit height and allow scroll if needed */
    overflow-y: auto;
    font-size: 0.85em;
}
#top-right-leaderboard li {
    padding: 3px 5px; /* Add slight horizontal padding */
    border-bottom: 1px dotted #444;
    white-space: nowrap; /* Prevent wrapping */
    overflow: hidden; /* Hide overflow */
    text-overflow: ellipsis; /* Add ellipsis if name is too long */
}
#top-right-leaderboard li:last-child {
    border-bottom: none;
}


/* --- Bottom Left Status Panel --- */
#bottom-left-status {
    bottom: 10px;
    left: 10px;
    width: 220px; /* Fixed width */
}
#bottom-left-status .status-bar-container {
    margin-bottom: 10px;
    position: relative; /* For positioning the value text */
}
#bottom-left-status label {
    display: block;
    margin-bottom: 2px;
    font-size: 0.85em;
    color: #ccc;
}
.bar-outer {
    background-color: #555;
    border-radius: 3px;
    height: 15px;
    width: 100%;
    overflow: hidden;
    border: 1px solid #333; /* Subtle border */
}
.bar-inner {
    height: 100%;
    border-radius: 2px; /* Slightly smaller radius */
    transition: width 0.2s ease-in-out;
}
.carbon { background: linear-gradient(to right, #4CAF50, #8BC34A); } /* Green gradient */
.hydraulic { background: linear-gradient(to right, #2196F3, #03A9F4); } /* Blue gradient */

#bottom-left-status span#carbon-value,
#bottom-left-status span#hydraulic-value {
    position: absolute; /* Position inside the container */
    right: 5px;      /* Align to the right */
    top: 18px;       /* Position below the label */
    font-size: 0.75em;
    line-height: 15px; /* Align vertically with bar */
    color: #ccc;
    text-shadow: 1px 1px 1px #000; /* Improve readability */
}
#bottom-left-status p { /* Seed count display */
    margin: 8px 0 0 0;
    clear: both;
    font-weight: bold;
}
#bottom-left-status p span#seed-counter {
     color: #ffc107;
}


/* --- Bottom Right Control Panel --- */
#control-panel-right {
    bottom: 10px;
    right: 10px;
    width: 220px; /* Slightly wider */
    display: flex;
    flex-direction: column; /* Stack controls vertically */
    gap: 15px; /* Space between control rows */
    padding: 15px 12px; /* Adjust padding */
}

/* Styling for rows within the vertical panel */
.control-row {
    display: grid;
    grid-template-columns: auto 1fr; /* Label | Slider/Value Area */
    grid-template-rows: auto auto; /* Row 1 for Label/Value, Row 2 for Slider */
    gap: 2px 8px;
    align-items: center;
    width: 100%;
}
.control-row label {
    grid-column: 1 / 2; grid-row: 1 / 2;
    white-space: nowrap; color: #ccc; font-size: 0.85em; justify-self: start;
}
.control-row input[type="range"] {
    grid-column: 1 / 3; grid-row: 2 / 3;
    width: 100%; cursor: pointer; margin-top: 2px;
    /* Improved slider appearance */
    -webkit-appearance: none;
    appearance: none;
    height: 8px;
    background: #555;
    outline: none;
    border-radius: 4px;
}
.control-row input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none;
    width: 16px; height: 16px; background: #ccc; cursor: pointer; border-radius: 50%;
}
.control-row input[type="range"]::-moz-range-thumb {
    width: 16px; height: 16px; background: #ccc; cursor: pointer; border-radius: 50%; border: none;
}

.control-row span { /* Percentage displays */
    grid-column: 2 / 3; grid-row: 1 / 2;
    font-size: 0.85em; font-weight: bold; color: #ccc; text-align: right; white-space: nowrap; justify-self: end;
}

/* === Back Button Styling === */
.back-button {
    position: absolute;
    top: 10px;
    /* Place it near the leaderboard but not overlapping */
    /* Adjust based on final leaderboard width if needed */
    right: 230px; /* Example positioning */
    z-index: 20; /* Above other panels */
    padding: 6px 12px;
    font-size: 0.85em;
    background-color: rgba(80, 80, 80, 0.7);
    color: #eee;
    border: 1px solid #666;
    border-radius: 4px;
    cursor: pointer;
    pointer-events: auto; /* Ensure clickable */
    transition: background-color 0.2s;
    text-decoration: none; /* Remove underline if using <a> */
    font-family: sans-serif; /* Match other UI */
}
.back-button:hover {
    background-color: rgba(110, 110, 110, 0.8);
    border-color: #888;
}


/* === General Interactive Element Styling === */
button {
    pointer-events: auto; /* Ensure clickable */
}
input[type="range"], input[type="color"], input[type="number"] {
     pointer-events: auto; /* Ensure these are always interactive */
}
input[type="color"] {
    min-width: 40px; height: 25px; border: 1px solid #555;
    cursor: pointer; padding: 0; vertical-align: middle;
    background-color: #444; /* Match other inputs */
    border-radius: 3px;
}

/* === Game Over Modal Styling === */
.modal {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background-color: rgba(40, 40, 40, 0.9); padding: 30px; border: 1px solid #666;
    border-radius: 10px; z-index: 100; min-width: 300px; max-width: 90%; /* Responsive */
    text-align: center;
    pointer-events: auto; color: #eee; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
}
.modal.hidden { display: none; }
.modal h2 { margin-top: 0; color: #eee; margin-bottom: 15px; }
.modal p { color: #eee; margin: 10px 0; line-height: 1.4; }
.modal p span { font-weight: bold; color: #ffc107; }
#game-over-reason { font-style: italic; color: #ffdddd; margin-bottom: 20px !important; }
.modal button {
     padding: 10px 20px; margin-top: 20px; cursor: pointer;
     background-color: #556b2f; /* Match landing page buttons */
     border: none; color: #eee; border-radius: 5px; font-size: 1em;
     transition: background-color 0.2s;
}
.modal button:hover { background-color: #6b8e23; }
/* Style admin close button differently if needed */
#admin-close-modal { background-color: #8b4513; }
#admin-close-modal:hover { background-color: #a0522d; }

--- FILE: server/config.js ---
// server/config.js
// Game Constants & Configuration
// (Content copied from root config.js)

export const k_TA_LA_RATIO = 0.01; // Trunk cross-section area / Leaf Area ratio
export const INITIAL_LEAF_AREA = 5;
export const INITIAL_TRUNK_HEIGHT = 2;
export const INITIAL_CARBON = 100;
export const INITIAL_HYDRAULICS = 100; // Starting hydraulic safety value

export const MAX_CARBON = 200; // Maximum carbon storage capacity

// Hydraulic Buffer Configuration
export const BASE_HYDRAULIC = 50; // Base hydraulic safety buffer independent of size
export const HYDRAULIC_SCALE_PER_LA = 10; // Additional buffer capacity per unit of currentLA

export const PHOTOSYNTHESIS_RATE_PER_LA = 0.5; // Carbon gain per LA per second at max light & stomata=1
export const RESPIRATION_RATE_PER_LA = 0.02;   // Carbon loss per LA per second
export const RESPIRATION_RATE_PER_TRUNK_VOL = 0.01; // Carbon loss per trunk volume per second
export const TRANSPIRATION_RATE_PER_LA = 0.4; // Water loss rate per LA per sec at stomata=1, normal drought
export const HYDRAULIC_RECOVERY_RATE = 2;   // Base safety gain per second if stomata closed & water available
export const HYDRAULIC_DAMAGE_THRESHOLD = 20; // Below this, start taking damage
export const CROWN_DIEBACK_RATE = 0.05;      // Proportion of canopy LA potentially lost per second below threshold

export const GROWTH_COST_PER_LA = 5;        // Carbon cost to add 1 unit of LA (includes implicit trunk cost)
export const SEED_COST = 1;                 // Carbon cost per seed

// Time Structure Constants
export const PERIOD_DURATION = 7.0;         // Duration of each daytime weather period (seconds)
export const NUM_DAY_PERIODS = 3;           // Number of weather periods per day
export const DAY_TOTAL_DURATION = PERIOD_DURATION * NUM_DAY_PERIODS; // Total duration of all day periods
export const NIGHT_DURATION = 3.0;          // Duration of nighttime (seconds)
export const TOTAL_CYCLE_DURATION = DAY_TOTAL_DURATION + NIGHT_DURATION; // Full day-night cycle length
export const GROWTH_OFFSET_NIGHT = 1.5;     // Time into night when growth allocation occurs (seconds)

// Weather Probabilities & Effects
export const SUNNY_PROB = 2.0 / 3.0;        // Probability of a period being sunny (vs cloudy)
export const RAIN_PROB_IF_CLOUDY = 0.5;     // Probability of rain if a period is cloudy

export const LIGHT_MULT_SUNNY = 1.0;        // Photosynthesis multiplier for sunny weather
export const LIGHT_MULT_CLOUDY = 0.4;       // Photosynthesis multiplier for cloudy weather

export const DROUGHT_MULT_BASE = 1.0;       // Base drought factor (normal conditions)
export const DROUGHT_VARIATION = 0.4;       // Max +/- variation around the base for random drought factor

export const RAIN_RECOVERY_BONUS_MULT = 3.0; // Multiplier for HYDRAULIC_RECOVERY_RATE during rain
export const NIGHT_RAIN_HYDRAULIC_BOOST = 20.0; // Absolute hydraulic units added during rainy night (foliar uptake)

// Canopy Tile Configuration (Client might still need this, but server sim doesn't directly)
// export const CANOPY_TILE_GRID_SIZE = 10;
// export const CANOPY_TILE_THICKNESS = 0.1;

// Island Configuration (Client primarily needs this, server might for spawn validation)
// export const ISLAND_RADIUS = 50;
// export const WATER_LEVEL = 0;
// export const ISLAND_LEVEL = 0.1;

// Default Colors (Client only)
// export const DEFAULT_LEAF_COLOR = '#228B22';
// export const DEFAULT_TRUNK_COLOR = '#8B4513';

// Fog constants (Client only)
// export const FOG_DAY_NEAR = 50;
// export const FOG_DAY_FAR = 150;
// export const FOG_NIGHT_NEAR = 9999;
// export const FOG_NIGHT_FAR = 10000;

--- FILE: client/ui/setupListeners.js ---
// client/ui/setupListeners.js
import { uiElements } from './elements.js';
import { handleStomataChange, handleAllocationSliderChange } from './controlsHandlers.js';
import { handleRestart, socket } from '../main.js'; // Import socket

/**
 * Attaches event listeners to the interactive UI elements.
 */
export function setupUIListeners() {
    console.log("UI: Setting up listeners...");

    // Check required elements using optional chaining for safety
    // Ensure all elements used below are checked here
    if (!uiElements.stomataSlider ||
        !uiElements.savingsSlider ||
        !uiElements.growthRatioSlider ||
        !uiElements.restartButton ||
        !uiElements.startCountdownButton) // Added check
    {
        console.error("Cannot set up UI listeners - one or more essential controls missing!");
        if (!uiElements.stomataSlider) console.error("- Stomata slider missing");
        if (!uiElements.savingsSlider) console.error("- Savings slider missing");
        if (!uiElements.growthRatioSlider) console.error("- Growth ratio slider missing");
        if (!uiElements.restartButton) console.error("- Restart button missing");
        if (!uiElements.startCountdownButton) console.error("- Start Countdown button missing");
        return;
    }


    // Control Sliders
    uiElements.stomataSlider.addEventListener('input', handleStomataChange);
    uiElements.savingsSlider.addEventListener('input', handleAllocationSliderChange);
    uiElements.growthRatioSlider.addEventListener('input', handleAllocationSliderChange);

    // Restart Button
    uiElements.restartButton.addEventListener('click', handleRestart);

    // Start Countdown Button
    uiElements.startCountdownButton.addEventListener('click', () => {
        console.log("UI: Start Countdown button clicked."); // <<< Log 1
        if (socket && socket.connected) {
             // +++ Add more detailed log before emitting +++
             console.log(`UI: Emitting 'requestStartCountdown' via socket ${socket.id}. Connected: ${socket.connected}`); // <<< Log 2
             socket.emit('requestStartCountdown'); // Send event to server
        } else {
            // +++ Log the socket object for inspection +++
            console.error("UI: Cannot start countdown, socket invalid or not connected.", { socket_exists: !!socket, connected: socket?.connected }); // <<< Log 3 (with more info)
            // Maybe show an error message to the user
            alert("Error: Not connected to server. Cannot start countdown.");
        }
    });

    console.log("UI: Listeners set up.");
}

--- FILE: server/game/GameInstanceManager.js ---
// server/game/GameInstanceManager.js
import { GameInstance } from './GameInstance.js';
import * as Config from '../config.js'; // Import Config here

class GameInstanceManager {
    constructor(io) {
        this.io = io; // Socket.IO server instance
        this.instances = new Map(); // Map<instanceId, GameInstance>
        this.multiplayerInstanceId = null; // Track the ID of the single multiplayer game instance
        this.playerInstanceMap = new Map(); // Map<socketId, instanceId> - To quickly find which instance a player belongs to
        console.log("GameInstanceManager initialized.");
    }

    // --- Instance Creation ---

    createSinglePlayerInstance(socket) {
        console.log(`InstanceMgr: Creating new single-player instance for ${socket.id}`);
        const instance = new GameInstance('single', this.io);
        this.instances.set(instance.state.instanceId, instance);
        // Don't map player yet, routePlayer will do it after adding
        console.log(`InstanceMgr: Added instance ${instance.state.instanceId} to manager. Total instances: ${this.instances.size}`);
        return instance;
    }

    getOrCreateMultiplayerInstance() {
        if (this.multiplayerInstanceId && this.instances.has(this.multiplayerInstanceId)) {
            return this.instances.get(this.multiplayerInstanceId);
        } else {
            console.log("InstanceMgr: Creating new (and only) multiplayer instance.");
            const instance = new GameInstance('multi', this.io);
            this.instances.set(instance.state.instanceId, instance);
            this.multiplayerInstanceId = instance.state.instanceId; // Store its ID
            console.log(`InstanceMgr: Added multiplayer instance ${instance.state.instanceId}. Total instances: ${this.instances.size}`);
            return instance;
        }
    }

    // --- Instance Management ---

    getInstance(instanceId) {
        return this.instances.get(instanceId) || null;
    }

    removeInstance(instanceId) {
        const instance = this.instances.get(instanceId);
        if (instance) {
            console.log(`InstanceMgr: Removing instance ${instanceId} (Mode: ${instance.state.mode}).`);
            instance.stopSimulationLoop(); // Ensure loops are stopped
            instance.stopCountdown();

            // Remove players from the map and potentially the socket rooms
            instance.getAllPlayers().forEach((playerData, socketId) => {
                 this.playerInstanceMap.delete(socketId);
                 const socket = instance.findSocket(socketId); // Attempt to find socket
                 if (socket) {
                      socket.leave(instance.state.roomId);
                 }
            });

            this.instances.delete(instanceId);
            if (this.multiplayerInstanceId === instanceId) {
                console.log(`InstanceMgr: Removed multiplayer instance. It needs to be recreated.`);
                this.multiplayerInstanceId = null; // Allow recreation
            }
            console.log(`InstanceMgr: Instance ${instanceId} removed. Remaining instances: ${this.instances.size}`);
            return true;
        }
         console.warn(`InstanceMgr: Tried to remove non-existent instance ${instanceId}`);
        return false;
    }

    // --- Player Routing & Management ---

    routePlayer(socket, intent, isAdmin) {
        console.log(`InstanceMgr: Routing player ${socket.id} with intent: ${intent}, isAdmin: ${isAdmin}`);
        let targetInstance = null;

        if (isAdmin || intent === 'spectate') {
            console.log(`InstanceMgr: Routing admin/spectator ${socket.id} to multiplayer instance.`);
            targetInstance = this.getOrCreateMultiplayerInstance();
            const playerState = targetInstance.addPlayer(socket); // Adds to instance.state.players Map
            if (playerState) {
                // *** Explicitly set spectator status ***
                playerState.isSpectator = true;
                playerState.isAlive = false;
                if (isAdmin) playerState.playerName = `ADMIN_${socket.id.substring(0, 4)}`;

                // +++ Add Log Confirmation +++
                console.log(`InstanceMgr: Player state for ${socket.id} SET: isSpectator=${playerState.isSpectator}, isAlive=${playerState.isAlive}`);

                this.playerInstanceMap.set(socket.id, targetInstance.state.instanceId); // Map player to instance AFTER adding to instance state

                 // Send current state of the multiplayer instance
                 console.log(`InstanceMgr: Sending initial state snapshot to admin/spectator ${socket.id}`);
                 socket.emit('gameStateUpdate', targetInstance.getSnapshot());
                 targetInstance.broadcastState(); // Inform others in the room
            } else {
                 console.error(`InstanceMgr: Failed to add admin/spectator ${socket.id} to multiplayer instance.`);
                 socket.disconnect(true);
                 return null; // Explicitly return null on failure
            }
        }
        else if (intent === 'single') {
            targetInstance = this.createSinglePlayerInstance(socket);
            const playerState = targetInstance.addPlayer(socket);
             if (playerState) {
                 playerState.isSpectator = false; // Explicitly NOT spectator
                 playerState.isAlive = true; // Start single player alive
                 // *** Use Config here for default spawn height ***
                 const baseHeight = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
                 playerState.spawnPoint = { x: 0, y: baseHeight, z: 0 };
                 playerState.hasChosenSpawn = true;
                 targetInstance.setGamePhase('playing');
                 targetInstance.startSimulationLoop();
                 this.playerInstanceMap.set(socket.id, targetInstance.state.instanceId); // Map player to instance
                 console.log(`InstanceMgr: Sending initial state snapshot to single player ${socket.id}`);
                 socket.emit('gameStateUpdate', targetInstance.getSnapshot());
             } else {
                  console.error(`InstanceMgr: Failed to add player ${socket.id} to new single-player instance.`);
                  // Instance was added to map in createSinglePlayerInstance, remove it now.
                  if (targetInstance) this.removeInstance(targetInstance.state.instanceId);
                  socket.disconnect(true);
                  return null; // Explicitly return null on failure
             }
        }
        else if (intent === 'multi') {
            targetInstance = this.getOrCreateMultiplayerInstance();
            const currentPhase = targetInstance.state.gamePhase;
            const playerState = targetInstance.addPlayer(socket); // Add player first

            if(!playerState){
                 console.error(`InstanceMgr: Failed to add multiplayer player ${socket.id}.`);
                 socket.disconnect(true);
                 return null; // Explicitly return null on failure
            }

             // Now set status based on phase
             playerState.isSpectator = false; // Default for multi intent
             playerState.isAlive = false;

            if (currentPhase === 'playing' || currentPhase === 'countdown') {
                console.warn(`InstanceMgr: Player ${socket.id} joining active multiplayer game (Phase: ${currentPhase}). Forcing Spectator.`);
                playerState.isSpectator = true; // Force spectator
                socket.emit('serverMessage', { text: 'Game in progress, joining as spectator.', type: 'warning'});
            } else { // Joining lobby/ended multiplayer game
                 console.log(`InstanceMgr: Player ${socket.id} joining multiplayer lobby (Phase: ${currentPhase}).`);
                 // isSpectator = false, isAlive = false (already set)
            }

            this.playerInstanceMap.set(socket.id, targetInstance.state.instanceId); // Map player to instance
            console.log(`InstanceMgr: Sending initial state snapshot to multiplayer player ${socket.id}`);
            socket.emit('gameStateUpdate', targetInstance.getSnapshot());
            targetInstance.broadcastState(); // Inform others
        }
        else {
            console.error(`InstanceMgr: Unknown intent '${intent}' for player ${socket.id}. Disconnecting.`);
            socket.disconnect(true);
            return null; // Explicitly return null on failure
        }

        // Return the instance the player was routed to (or null if failed)
        return targetInstance;
    }


    getInstanceIdForPlayer(socketId) {
        return this.playerInstanceMap.get(socketId) || null;
    }

    removePlayerFromInstance(socketId) {
        const instanceId = this.getInstanceIdForPlayer(socketId);
        if (instanceId) {
            const instance = this.getInstance(instanceId);
            if (instance) {
                 const wasRemoved = instance.removePlayer(socketId);
                 if (wasRemoved) {
                      this.playerInstanceMap.delete(socketId);
                      console.log(`InstanceMgr: Removed player ${socketId} from instance map.`);

                      // Check if instance should be removed
                      if (instance.state.mode === 'single' && instance.getAllPlayers().size === 0) {
                           console.log(`InstanceMgr: Last player left single-player instance ${instanceId}. Removing instance.`);
                           this.removeInstance(instanceId);
                      }
                      // Auto-remove multiplayer instance if empty? Maybe not, allow it to persist in lobby state.
                      // else if (instance.state.mode === 'multi' && instance.getAllPlayers().size === 0) {
                      //      console.log(`InstanceMgr: Last player left multiplayer instance ${instanceId}. Removing instance.`);
                      //      this.removeInstance(instanceId);
                      // }
                      else if (instance.getAllPlayers().size > 0) { // Only broadcast if players remain
                          // If not removing instance, broadcast updated state within the instance
                          instance.broadcastState();
                      }
                      return true; // Successfully removed
                 }
            } else {
                 console.error(`InstanceMgr: Instance ${instanceId} not found for player ${socketId} during removal.`);
                 this.playerInstanceMap.delete(socketId); // Clean up map anyway
            }
        } else {
             console.warn(`InstanceMgr: Cannot remove player ${socketId}, instance ID not found in map.`);
        }
        return false; // Removal failed or player not found
    }
}

export { GameInstanceManager }; // Export the class

--- FILE: server/network/stateBroadcaster.js ---
// server/network/stateBroadcaster.js

function getSimplifiedGameStateSnapshot(players, globalState) {
    const playersSnapshot = {};
    Object.values(players).forEach(p => {
        playersSnapshot[p.id] = {
            id: p.id,
            playerName: p.playerName,
            isAlive: p.isAlive,
            hasChosenSpawn: p.hasChosenSpawn,
            isSpectator: p.isSpectator, // <<< Include spectator status
            // Resources
            carbonStorage: p.carbonStorage, hydraulicSafety: p.hydraulicSafety, maxHydraulic: p.maxHydraulic,
            // Visual state
            currentLA: p.currentLA, trunkHeight: p.trunkHeight, damagedLAPercentage: p.damagedLAPercentage,
            // Score & Position
            seedCount: p.seedCount, spawnPoint: p.spawnPoint
        };
    });

    return {
        // Global environment
        day: globalState.day, timeInCycle: globalState.timeInCycle, currentPeriodIndex: globalState.currentPeriodIndex,
        isNight: globalState.isNight, currentLightMultiplier: globalState.currentLightMultiplier, currentDroughtFactor: globalState.currentDroughtFactor,
        isRaining: globalState.isRaining,
        // Game Phase & Countdown
        gamePhase: globalState.gamePhase, countdownTimer: globalState.countdownTimer,
        // Player states
        players: playersSnapshot,
        serverTime: Date.now()
    };
}

export function getFullGameStateSnapshot(players, globalState) {
    return getSimplifiedGameStateSnapshot(players, globalState);
}

export function broadcastGameState(io, players, globalState) {
    const snapshot = getSimplifiedGameStateSnapshot(players, globalState);
    io.emit('gameStateUpdate', snapshot);
}

--- FILE: client/admin.js ---
// client/admin.js - Logic for the Admin Panel

import * as THREE from 'three';
// Import necessary modules (paths relative to client/)
import { gameState } from './gameState.js'; // Use gameState for caching server state
import * as Config from './config.js';
import { initScene, renderer, camera, controls, scene } from './sceneSetup.js'; // Reuse scene setup
import { createOrUpdateTree, removeTree, disposeAllTrees } from './tree.js'; // Reuse tree rendering
import { uiElements, cacheDOMElements } from './ui/elements.js'; // Cache admin page UI elements & uiElements ref
import { updateUI as updateAdminUI } from './ui/updateAdmin.js'; // Use a SEPARATE admin UI update function
import { showMessage, clearMessage, attachServerMessageListener } from './ui/messageHandler.js'; // Use message handler
import { hideGameOverModal } from './ui/gameOver.js'; // Import hide function
import { updateEnvironmentVisuals, updateRain, setWeatherTargets, startRain, stopRain } from './environment.js';

// --- Global Variables ---
let clock = new THREE.Clock();
let animationFrameId = null;
let socket = null;
let adminPassword = null; // Store password retrieved from URL
let isAdminAuthenticated = false; // Track websocket auth status

// --- Initialization Function ---
function initializeAdminApp() {
    console.log("Initializing Admin Panel Client...");

    // --- Get Admin Password from URL ---
    const urlParams = new URLSearchParams(window.location.search);
    adminPassword = urlParams.get('pw');
    if (!adminPassword) {
        console.error("Admin Password missing from URL (?pw=...).");
        document.body.innerHTML = '<h1>Access Denied: Admin password missing from URL (?pw=...)</h1>';
        return; // Stop execution if no password
    }
    // Attempt to remove password from URL bar history for basic security
    try { history.replaceState(null, '', window.location.pathname); } catch (e) { console.warn("Could not clear URL history."); }


    // --- Basic Setup ---
    gameState.isSpectator = true; // Admin is always a spectator type
    cacheDOMElements(); // Cache elements defined in admin.html, including back button
    const canvas = uiElements.canvas; // Use cached canvas
    if (!canvas) { console.error("Admin Canvas element #game-canvas not found!"); return; }

    initScene(canvas); // Setup Three.js scene

     // +++ Add Back Button Listener +++
    if (uiElements.backButton) {
        uiElements.backButton.addEventListener('click', () => {
            console.log("Admin: Back to Menu button clicked.");
            if (socket && socket.connected) {
                socket.disconnect(); // Disconnect before navigating
            }
            window.location.href = '/'; // Navigate to main menu
        });
         console.log("Admin: Back button listener added.");
    } else {
         console.warn("Admin: Back button UI element not found during init.");
    }

    console.log("Admin: Attempting to connect to server...");
    socket = io({
         reconnection: true,
         reconnectionAttempts: 3, // Less aggressive for admin?
         reconnectionDelay: 2000,
    }); // Define socket
    setupAdminSocketListeners(); // Setup listeners AFTER socket defined
    setupAdminButtonListeners(); // Setup listeners for admin buttons
    updateAdminUI(); // Initial UI render
    clearMessage();
    console.log("Admin Client Initialization complete. Waiting for server connection...");
}

// --- Socket Event Listener Setup ---
function setupAdminSocketListeners() {
    socket.on('connect', () => {
        gameState.myId = socket.id; // Store socket ID
        console.log(`Admin: Connected to server with ID: ${gameState.myId}`);
        showMessage(`Admin connected. Authenticating...`, 'info');

        // --- Send authentication event ---
        if (adminPassword) {
             console.log("Admin: Sending authentication request...");
             socket.emit('adminAuthenticate', { password: adminPassword });
        } else {
             console.error("Admin: Password was lost before authentication could be sent.");
              showMessage(`Authentication Error! Refresh.`, 'error');
              socket.disconnect();
        }
        // Clear password variable immediately after sending
        adminPassword = null;
    });

    // Listen for authentication confirmation/rejection
    socket.on('adminAuthResult', (result) => {
        if (result.success) {
            isAdminAuthenticated = true;
            console.log("Admin: WebSocket Authentication successful.");
            showMessage(`Admin Authenticated`, 'success');
             if (uiElements.adminControls) { // Show controls on successful auth
                 uiElements.adminControls.style.display = 'flex';
             } else {
                  console.warn("Admin controls panel not found after auth success.");
             }
             // Attach server message listener now that socket is ready
             attachServerMessageListener(); // Call the exported function

        } else {
            isAdminAuthenticated = false;
            console.error("Admin: WebSocket Authentication Failed!", result.reason);
            showMessage(`Admin Auth Failed: ${result.reason || 'Invalid Password'}`, 'error');
             if (uiElements.adminControls) { // Hide controls on failed auth
                 uiElements.adminControls.style.display = 'none';
             }
            // Disconnect on failed auth
            if(socket) socket.disconnect();
        }
    });

    socket.on('disconnect', (reason) => {
         console.log(`Admin: Disconnected: ${reason}`); showMessage("Disconnected!", "error");
         isAdminAuthenticated = false; gameState.myId = null; gameState.initialStateReceived = false;
         if (animationFrameId !== null) cancelAnimationFrame(animationFrameId); animationFrameId = null;
         if (uiElements.adminControls) uiElements.adminControls.style.display = 'none'; // Hide controls
         disposeAllTrees();
    });
    socket.on('connect_error', (error) => { console.error('Admin Conn Error:', error); showMessage("Connection failed!", "error"); });

    // --- Game State Update Handler (Spectator View) ---
    socket.on('gameStateUpdate', (serverState) => {
         const previousPhase = gameState.gamePhase;
         const playersFromServer = serverState.players || {}; // Ensure players object exists
         const myServerData = playersFromServer[gameState.myId]; // Get data for this admin client

         // +++ Log Received Spectator Status +++
         console.log(`Admin GS Update: Received state. My server data:`, myServerData);
         if (myServerData) {
             console.log(`Admin GS Update: My isSpectator status from server = ${myServerData.isSpectator}`);
         } else if (gameState.myId) {
              console.warn(`Admin GS Update: Did not find own ID (${gameState.myId}) in received players object.`);
         }

         // Update core state properties
         Object.assign(gameState, {
             day: serverState.day, timeInCycle: serverState.timeInCycle, currentPeriodIndex: serverState.currentPeriodIndex,
             isNight: serverState.isNight, currentLightMultiplier: serverState.currentLightMultiplier, currentDroughtFactor: serverState.currentDroughtFactor,
             isRaining: serverState.isRaining, gamePhase: serverState.gamePhase, countdownTimer: serverState.countdownTimer,
             serverTime: serverState.serverTime,
             players: playersFromServer, // Update player cache
             allowPlayerCountdownStart: serverState.allowPlayerCountdownStart,
         });

         // +++ Force local spectator status based on received data or default to true +++
         // Ensure admin client always considers itself a spectator locally
         gameState.isSpectator = true; // Keep this definitively true for admin client
         console.log(`Admin GS Update: Local gameState.isSpectator forced to = ${gameState.isSpectator}`);
         // We still log the server status above for debugging, but the admin client UI/logic should rely on its forced spectator status.

         // --- First time setup ---
         if (!gameState.initialStateReceived && gameState.myId /*&& myServerData - Don't require server data for first admin setup*/) {
             console.log("Admin: First gameStateUpdate processed (or initial connection established).");
             if(controls) { controls.target.set(0, 5, 0); controls.update(); } // General island view
             setWeatherTargets(gameState.isNight, gameState.currentLightMultiplier < Config.LIGHT_MULT_SUNNY - 0.1, gameState.isRaining);
             updateEnvironmentVisuals(1000); if(gameState.isRaining) startRain(); else stopRain();
             gameState.initialStateReceived = true; startGameLoop();
             setTimeout(() => showMessage(`Game state: ${gameState.gamePhase}`, 'info'), 100);
         }
         // --- Phase change updates ---
         else if (gameState.gamePhase !== previousPhase) {
             console.log(`Admin phase updated to: ${gameState.gamePhase}`);
             showMessage(`Game state: ${gameState.gamePhase}`, 'info');
             if(gameState.gamePhase !== 'ended' && uiElements.gameOverModal && !uiElements.gameOverModal.classList.contains('hidden')) { hideGameOverModal(); }
         }

         /* Update Environment */ const wasRaining = scene?.getObjectByName("rain")?.visible ?? false; setWeatherTargets(gameState.isNight, gameState.currentLightMultiplier < Config.LIGHT_MULT_SUNNY - 0.1, gameState.isRaining); if (gameState.isRaining && !wasRaining) startRain(); else if (!gameState.isRaining && wasRaining) stopRain();

         /* Update Trees */
         const receivedPlayerIds = new Set(Object.keys(playersFromServer));
         for (const playerId in playersFromServer) {
             const playerData = playersFromServer[playerId];
             // *** Use the player's spectator flag from the received data ***
             if (playerData.isSpectator) {
                 removeTree(playerId); // Remove tree for ANY spectator
             } else {
                 createOrUpdateTree(playerId, playerData); // Render non-spectators
             }
         }
         // Remove trees for players no longer in the state
         gameState.playerTrees.forEach((_, playerId) => {
             if (!receivedPlayerIds.has(playerId)) removeTree(playerId);
         });

         /* Update Camera Target */ if (controls) controls.target.lerp(new THREE.Vector3(0, 5, 0), 0.05); // Keep overview

     }); // End gameStateUpdate

    socket.on('playerDisconnected', (playerId) => { console.log(`Admin View: Player ${playerId} disconnected.`); removeTree(playerId); });

    // Use simplified game over display for admin
    socket.on('gameOver', (data) => {
         console.log("Admin View: Game Over event received:", data);
         gameState.gameOver = true; // Set local flag
         gameState.gameOverReason = data.reason || "Game Ended";
         gameState.winnerId = data.winnerId;

         // Show modal, but maybe don't stop loop?
         if (uiElements.gameOverModal && uiElements.adminCloseModalButton) { // Check modal and button exist
            if(uiElements.gameOverReasonUI) uiElements.gameOverReasonUI.textContent = `Game Ended: ${gameState.gameOverReason}`;
            if(uiElements.finalDayUI && uiElements.finalDayUI.parentElement) uiElements.finalDayUI.parentElement.style.display = 'none';
            if(uiElements.finalSeedsUI && uiElements.finalSeedsUI.parentElement) uiElements.finalSeedsUI.parentElement.style.display = 'none';
            if(uiElements.restartButton) uiElements.restartButton.style.display = 'none';
            uiElements.adminCloseModalButton.style.display = 'inline-block'; // Ensure admin close is visible
            uiElements.gameOverModal.classList.remove('hidden');
         } else { console.warn("Cannot show admin game over modal - elements missing."); }
    });

     // Listen for server messages (e.g., admin command confirmations)
     socket.on('serverMessage', (data) => {
         console.log("Admin received server message:", data);
         showMessage(data.text, data.type || 'info');
     });

} // End of setupSocketListeners


// --- Setup Listeners for Admin Buttons ---
function setupAdminButtonListeners() {
    console.log("Admin: Setting up button listeners...");
    const forceStartBtn = document.getElementById('admin-force-start');
    const forceEndBtn = document.getElementById('admin-force-end');
    const resetCountdownBtn = document.getElementById('admin-reset-countdown');
    const closeModalBtn = uiElements.adminCloseModalButton; // Use cached element

    if (uiElements.adminControls) uiElements.adminControls.style.display = 'none';

    function emitAdminCommand(command) {
        if (socket && socket.connected && isAdminAuthenticated) {
            console.log(`Admin: Emitting command: ${command}`);
            socket.emit(command);
        } else { console.error(`Admin: Cannot send command '${command}', socket not connected or not authenticated.`); showMessage("Cannot send command: Not authenticated.", "error"); }
    }

    if (forceStartBtn) forceStartBtn.addEventListener('click', () => emitAdminCommand('adminForceStart')); else console.warn("Admin button 'admin-force-start' not found.");
    if (forceEndBtn) forceEndBtn.addEventListener('click', () => emitAdminCommand('adminForceEnd')); else console.warn("Admin button 'admin-force-end' not found.");
    if (resetCountdownBtn) resetCountdownBtn.addEventListener('click', () => emitAdminCommand('adminResetCountdown')); else console.warn("Admin button 'admin-reset-countdown' not found.");
    if (closeModalBtn) { closeModalBtn.removeEventListener('click', hideGameOverModal); closeModalBtn.addEventListener('click', hideGameOverModal); } else { console.warn("Admin close modal button 'admin-close-modal' not found."); }
}

// --- Admin Rendering Loop ---
function gameLoop() { animationFrameId = requestAnimationFrame(gameLoop); const deltaTime = clock.getDelta(); updateEnvironmentVisuals(deltaTime); updateRain(deltaTime); updateAdminUI(); if (controls) controls.update(); if (renderer && scene && camera) renderer.render(scene, camera); else { console.error("Admin Render components missing!"); stopGameLoop(); } }
function startGameLoop() { if (animationFrameId !== null) return; console.log("Admin: Starting render loop."); clock = new THREE.Clock(); gameLoop(); }
function stopGameLoop() { if (animationFrameId !== null) { cancelAnimationFrame(animationFrameId); animationFrameId = null; console.log("Admin: Stopped render loop."); } }

// --- Start Admin Application ---
document.addEventListener('DOMContentLoaded', initializeAdminApp);

--- FILE: client/ui/update.js ---
// client/ui/update.js
import { gameState, getMyPlayerState } from '../gameState.js';
import * as Config from '../config.js';
import { uiElements } from './elements.js';

/** Updates all relevant UI elements based on the current gameState. */
export function updateUI() {
    // Allow update even before initial state for basic loading display
    if (!uiElements.dayCounterUI) { // Check only one essential element that should always exist on game page
        // console.warn("UpdateUI: Waiting for essential UI elements.");
        return;
    }

    const myState = getMyPlayerState();
    const phase = gameState.gamePhase;
    const allConnections = gameState.players || {}; // Use empty object if players doesn't exist yet
    const isSpectator = gameState.isSpectator; // Use the flag from client gameState

    // +++ Consistent Player/Spectator Filtering +++
    const allPlayerArray = Object.values(allConnections);
    // Filter for actual players (non-spectators)
    const activePlayers = allPlayerArray.filter(p => p && !p.isSpectator);
    // Count total connections (including spectators/admins)
    const totalConnectionsCount = allPlayerArray.length;
    // Count active players
    const activePlayerCount = activePlayers.length;
    // Count alive among active players
    const alivePlayerCount = activePlayers.filter(p => p.isAlive).length;


    // --- Update Status Bars (Bottom Left) ---
    if (uiElements.bottomLeftStatus) { // Check element exists before accessing style
        uiElements.bottomLeftStatus.style.display = isSpectator ? 'none' : 'block';
    }
    if (!isSpectator && gameState.initialStateReceived && myState) { // Ensure myState exists too
        const carbon = myState.carbonStorage ?? 0; const maxCarbon = Config.MAX_CARBON;
        const hydraulics = myState.hydraulicSafety ?? 0; const maxHydraulics = myState.maxHydraulic ?? Config.BASE_HYDRAULIC;
        const seeds = myState.seedCount ?? 0;
        if (uiElements.carbonBar) uiElements.carbonBar.style.width = `${(carbon / maxCarbon) * 100}%`;
        if (uiElements.hydraulicBar) uiElements.hydraulicBar.style.width = maxHydraulics > 0 ? `${(hydraulics / maxHydraulics) * 100}%` : '0%';
        if (uiElements.carbonValueUI) uiElements.carbonValueUI.textContent = Math.floor(carbon);
        if (uiElements.hydraulicValueUI) uiElements.hydraulicValueUI.textContent = Math.floor(hydraulics);
        if (uiElements.seedCounterUI) uiElements.seedCounterUI.textContent = seeds;
    } else if (!isSpectator && uiElements.bottomLeftStatus) { // Only reset if panel exists
         // Show default '--' if not spectator but state not ready
        if (uiElements.carbonValueUI) uiElements.carbonValueUI.textContent = '--';
        if (uiElements.hydraulicValueUI) uiElements.hydraulicValueUI.textContent = '--';
        if (uiElements.seedCounterUI) uiElements.seedCounterUI.textContent = '0';
        if (uiElements.carbonBar) uiElements.carbonBar.style.width = '0%';
        if (uiElements.hydraulicBar) uiElements.hydraulicBar.style.width = '0%';
    }

    // --- Update Info (Top Left) ---
    if (uiElements.dayCounterUI) uiElements.dayCounterUI.textContent = (phase !== 'loading') ? gameState.day : '-';
    if (uiElements.timeOfDayUI) {
        let timeText = '';
        if (phase === 'lobby' || phase === 'loading' || phase === 'ended') timeText = phase.charAt(0).toUpperCase() + phase.slice(1);
        else if (phase === 'countdown') timeText = 'Starting Soon!';
        else if (phase === 'playing') { if (gameState.isNight) timeText = 'Night'; else if (gameState.currentPeriodIndex >= 0) timeText = `Day Period ${gameState.currentPeriodIndex + 1}`; else timeText = 'Starting...'; }
        else timeText = 'Unknown Phase';
        uiElements.timeOfDayUI.textContent = timeText;
     }
    if (uiElements.cycleTimerUI) {
        let timeLeft = 0; if (phase === 'playing') { if (gameState.isNight) { const timeIntoNight = gameState.timeInCycle - Config.DAY_TOTAL_DURATION; timeLeft = Config.NIGHT_DURATION - timeIntoNight; } else if (gameState.currentPeriodIndex >= 0) { const timeIntoPeriod = gameState.timeInCycle - (gameState.currentPeriodIndex * Config.PERIOD_DURATION); timeLeft = Config.PERIOD_DURATION - timeIntoPeriod; } else { timeLeft = Config.PERIOD_DURATION - gameState.timeInCycle; } uiElements.cycleTimerUI.textContent = Math.max(0, Math.floor(timeLeft)); } else { uiElements.cycleTimerUI.textContent = '--'; }
     }
    if (uiElements.weatherStatusUI) {
        let weatherText = ''; if(phase === 'lobby' || phase === 'loading' || phase === 'ended' || phase === 'countdown') weatherText = '--'; else if (phase === 'playing') { if (gameState.isNight) weatherText = 'Night'; else weatherText = (gameState.currentLightMultiplier === Config.LIGHT_MULT_SUNNY) ? 'Sunny' : 'Cloudy'; if (gameState.isRaining) weatherText += ', Raining'; if (gameState.currentDroughtFactor > Config.DROUGHT_MULT_BASE + Config.DROUGHT_VARIATION * 0.6) weatherText += ' (Dry)'; else if (gameState.currentDroughtFactor < Config.DROUGHT_MULT_BASE - Config.DROUGHT_VARIATION * 0.6) weatherText += ' (Wet)'; } else weatherText = 'Initializing...'; uiElements.weatherStatusUI.textContent = weatherText;
     }

    // --- Update Lobby/Countdown UI (Top Left) ---
    if (uiElements.lobbyInfoPanel) {
        // Show lobby panel only if NOT spectator AND in lobby/countdown
        const showLobbyPanel = !isSpectator && (phase === 'lobby' || phase === 'countdown');
        uiElements.lobbyInfoPanel.style.display = showLobbyPanel ? 'block' : 'none';

        if (showLobbyPanel) {
            // +++ Use totalConnectionsCount for Lobby Player Count +++
            if (uiElements.lobbyPlayerCountUI) uiElements.lobbyPlayerCountUI.textContent = totalConnectionsCount;

            // Control visibility of lobby instruction
            if (uiElements.lobbyInstructionUI) {
                uiElements.lobbyInstructionUI.style.display = (phase === 'lobby') ? 'block' : 'none'; // Show only in lobby
            }

            if (uiElements.startCountdownButton) { uiElements.startCountdownButton.disabled = (phase === 'countdown'); uiElements.startCountdownButton.textContent = (phase === 'countdown') ? 'Countdown...' : 'Start Countdown'; }

            // Countdown Timer Display
            if (uiElements.countdownTimerDisplayUI) {
                if (phase === 'countdown' && gameState.countdownTimer !== null && gameState.countdownTimer >= 0) { // Check >= 0
                    // console.log(`UI Update: Countdown phase, timer value: ${gameState.countdownTimer}`);
                    uiElements.countdownTimerDisplayUI.textContent = `Starting in: ${gameState.countdownTimer}s`;
                    uiElements.countdownTimerDisplayUI.style.display = 'block';
                } else {
                    uiElements.countdownTimerDisplayUI.style.display = 'none';
                }
            }
         }
    }


    // --- Update Controls (Bottom Right) ---
    if (uiElements.controlPanelRight) {
        // Show controls ONLY if playing, alive, and NOT spectator
        const showControls = phase === 'playing' && myState && myState.isAlive && !isSpectator && !gameState.gameOver;
        uiElements.controlPanelRight.style.display = showControls ? 'flex' : 'none';
    }

    // --- Update Leaderboard / Player List (Top Right) ---
    if (uiElements.leaderboardTitleUI) {
         // +++ Use totalConnectionsCount for Lobby title, use activePlayerCount for game title +++
         if (phase === 'lobby' || phase === 'countdown') uiElements.leaderboardTitleUI.textContent = `Lobby (${totalConnectionsCount})`;
         else uiElements.leaderboardTitleUI.textContent = `Leaderboard (${alivePlayerCount}/${activePlayerCount})`; // Show Alive/Total Active Players
     }
    if (uiElements.leaderboardListUI) {
        let listHTML = '';
        // +++ Use the pre-filtered activePlayers list +++
        const playersToDisplay = [...activePlayers]; // Create a mutable copy for sorting

        // Sort the filtered players
        playersToDisplay.sort((a, b) => {
            if (phase === 'lobby' || phase === 'countdown') {
                 // Should not be sorting active players in lobby? This list should show spectators too in lobby?
                 // Let's adjust: Sort ALL connections for lobby/countdown display
                 const allSorted = [...allPlayerArray].sort((a, b) => (a?.playerName || '').localeCompare(b?.playerName || ''));
                 listHTML = ''; // Reset listHTML
                 allSorted.forEach(player => {
                    const isMe = player.id === gameState.myId;
                    let status = '';
                    if (player.isSpectator) {
                         status = player.playerName.startsWith('ADMIN_') ? ' (Admin)' : ' (Spectator)';
                    } else {
                         status = player.hasChosenSpawn ? ' (Placed)' : '';
                    }
                    const name = player.playerName || `Player ${player.id.substring(0,4)}`;
                    listHTML += `<li${isMe ? ' style="font-weight: bold;"' : ''}>${name}${status}</li>`;
                 });

            } else { // Playing or Ended phase - sort active players by seeds
                playersToDisplay.sort((a, b) => (b?.seedCount ?? 0) - (a?.seedCount ?? 0));
                // Generate HTML only for active players
                 playersToDisplay.forEach(player => {
                    const isMe = player.id === gameState.myId;
                    let status = player.isAlive ? '' : ' (Dead)'; // Should always be active player here
                    const name = player.playerName || `Player ${player.id.substring(0,4)}`;
                    const seeds = `: ${player.seedCount} Seeds`;
                    listHTML += `<li${isMe ? ' style="font-weight: bold;"' : ''}>${name}${status}${seeds}</li>`;
                });
            }
            return; // Exit sort callback early if handled lobby case
        });


        // Handle empty list (only if not lobby/countdown where we build it differently)
        if (listHTML === '' && phase !== 'lobby' && phase !== 'countdown') {
             if (totalConnectionsCount > 0 && activePlayerCount === 0) { // Check if connections exist but no active players
                 listHTML = '<li>Only spectators connected...</li>';
             } else if (totalConnectionsCount === 0) { // Check if truly empty
                 listHTML = '<li>Waiting for players...</li>';
             }
        } else if (listHTML === '' && (phase === 'lobby' || phase === 'countdown')) {
             if (totalConnectionsCount === 0) {
                 listHTML = '<li>Waiting for players...</li>';
             }
             // If connections exist but list is empty, it means the allSorted loop failed (shouldn't happen)
        }


        uiElements.leaderboardListUI.innerHTML = listHTML;
     }
}

--- FILE: client/gameState.js ---
// client/gameState.js
import * as Config from './config.js';

export const gameState = {
    // --- Server Synced State ---
    day: 1, timeInCycle: 0.0, currentPeriodIndex: -1, isNight: false,
    currentLightMultiplier: 1.0, currentDroughtFactor: Config.DROUGHT_MULT_BASE,
    isRaining: false, gamePhase: 'loading', players: {}, serverTime: Date.now(),
    countdownTimer: null,

    // --- Client-Specific State ---
    myId: null,
    isSpectator: false, // <<< Ensure this exists, defaults to false
    gameOver: false, gameOverReason: '', winnerId: null,
    playerTrees: new Map(),
    initialStateReceived: false,
};

export function loadClientSettings() {
    console.log("Client settings loaded (placeholder).");
}
loadClientSettings();

export function getMyPlayerState() {
    if (!gameState.myId || !gameState.players[gameState.myId]) return null;
    return gameState.players[gameState.myId];
}

--- FILE: server/server.js ---
// server/server.js (Main Entry Point)

import express from 'express';
import http from 'http';
import { Server as SocketIOServer } from 'socket.io';
import path from 'path';
import { fileURLToPath } from 'url';

// Import Server Modules
import { handleConnection } from './network/connection.js';
// import { updateSimulationTick } from './game/simulation.js'; // Simulation logic now within GameInstance
// import { broadcastGameState, getFullGameStateSnapshot } from './network/stateBroadcaster.js'; // Broadcasting handled by GameInstance
// import { getGlobalState, getAllPlayers, setGamePhase, getPlayerState } from './game/GameState.js'; // State now managed by instances
// import { resetGame, cancelLobbyCountdown } from './game/gameLogic.js'; // Game logic now within GameInstance
import { GameInstanceManager } from './game/GameInstanceManager.js'; // <<< Import the Manager
import * as Config from './config.js';

// --- Configuration & Setup ---
const PORT = process.env.PORT || 3000;
const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || "defaultAdminPass123";
// const TICK_RATE = 20; // Tick rate is now a Config property used by GameInstance
// const TICK_INTERVAL_MS = 1000 / TICK_RATE; // Calculated within GameInstance

// ES Module path setup
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const clientPath = path.join(__dirname, '..', 'client');

// Express and HTTP Server
const app = express();
const httpServer = http.createServer(app);

// Socket.IO Server
const io = new SocketIOServer(httpServer);

// --- Simulation Loop State ---
// let simulationInterval = null; // <<< REMOVED - Handled by GameInstance(s)
// let lastTickTime = Date.now(); // <<< REMOVED - Handled by GameInstance(s)

// --- Instantiate Game Instance Manager ---
const gameInstanceManager = new GameInstanceManager(io); // <<< Create the manager instance

// --- Admin Tracking ---
// This might still be useful globally or move into the manager? Keep global for now.
export const adminSockets = new Set();

// --- Express Routes & Static Files ---
console.log(`Serving static files from: ${clientPath}`);
app.use(express.static(clientPath));

app.get('/', (req, res) => { res.sendFile(path.join(clientPath, 'index.html')); });
app.get('/game', (req, res) => { res.sendFile(path.join(clientPath, 'game.html')); });
app.get('/settings', (req, res) => { res.sendFile(path.join(clientPath, 'settings.html')); });

app.get('/admin', (req, res) => {
    const providedPassword = req.query.pw;
    if (providedPassword && providedPassword === ADMIN_PASSWORD) {
        console.log("Admin access granted via HTTP route.");
        res.sendFile(path.join(clientPath, 'admin.html'));
    } else {
        console.log("Admin access denied. Incorrect or missing password.");
        res.status(403).send('Forbidden: Incorrect Admin Password');
    }
});

// --- Socket.IO Setup ---
io.on('connection', (socket) => {
    // Pass the instance manager to the connection handler
    handleConnection(socket, io, gameInstanceManager); // <<< Pass manager instance
});

// --- Main Simulation Loop Function ---
// function runGameTick() { ... } // <<< REMOVED - Logic moved to GameInstance.runTick()

// --- Simulation Control Functions ---
// These might become helper functions or move entirely into GameInstance/Manager
// For now, remove the export as they are not called globally anymore.
// export function startGame() { ... } // <<< REMOVED (or commented out)
// export function stopSimulation() { ... } // <<< REMOVED (or commented out)


// --- Start HTTP Server ---
httpServer.listen(PORT, () => {
    console.log(`Server listening on port ${PORT}`);
    console.log(`Admin access requires query param: ?pw=${ADMIN_PASSWORD}`);
    // No global reset needed here, manager handles instance creation/state
    // resetGame(); // <<< REMOVED
});

--- FILE: client/sceneSetup.js ---
// client/sceneSetup.js
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import * as Config from './config.js';
import { createStars, createRainSystem } from './environment.js';

export let scene;
export let camera;
export let renderer;
export let controls;
export let sunLight;
export let ambientLight;

export function initScene(canvas) {
    // Scene setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // Initial color, environment.js will update

    // Fog setup - Use client config values if available, otherwise provide defaults
    // Note: Config constants FOG_DAY_NEAR/FAR are commented out in client/config.js, so provide defaults here.
    const fogNear = Config.FOG_DAY_NEAR !== undefined ? Config.FOG_DAY_NEAR : 50;
    const fogFar = Config.FOG_DAY_FAR !== undefined ? Config.FOG_DAY_FAR : 150;
    scene.fog = new THREE.Fog(0x87ceeb, fogNear, fogFar); // environment.js will update color and distances

    // Camera setup
    const aspectRatio = window.innerWidth / window.innerHeight;
    camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000); // Far plane at 1000
    camera.position.set(15, 15, 15);

    // Renderer setup
    renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // Lighting setup
    ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Initial intensity
    scene.add(ambientLight);

    sunLight = new THREE.DirectionalLight(0xffffff, 1.5); // Initial intensity
    sunLight.position.set(30, 50, 20);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 150;
    // Use client config for shadow camera size calculation
    const shadowCamSize = (Config.ISLAND_RADIUS || 50) * 1.5; // Use fallback if config missing
    sunLight.shadow.camera.left = -shadowCamSize;
    sunLight.shadow.camera.right = shadowCamSize;
    sunLight.shadow.camera.top = shadowCamSize;
    sunLight.shadow.camera.bottom = -shadowCamSize;
    scene.add(sunLight);
    scene.add(sunLight.target); // Target is needed for directional light shadows

    // Controls setup
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    // Use client config for initial target height
    controls.target.set(0, (Config.INITIAL_TRUNK_HEIGHT || 2) / 2, 0); // Use fallback
    controls.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent looking straight down/up too far
    controls.minDistance = 5;  // Prevent zooming too close
    controls.maxDistance = 100; // Prevent zooming too far out

    // Static Environment Meshes (Island, Water)
    createEnvironment(); // <<< This function creates the island

    // Initialize Dynamic Environment Effects (Stars, Rain)
    createStars();
    createRainSystem();

    // Window Resize Listener
    window.addEventListener('resize', onWindowResize);

    console.log("Scene initialized (including stars and rain system placeholder)");
}

// Creates static meshes like island and water
function createEnvironment() {
    // Use client config values with fallbacks for safety
    const islandRadius = Config.ISLAND_RADIUS || 50;
    const islandLevel = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
    const waterLevel = Config.WATER_LEVEL !== undefined ? Config.WATER_LEVEL : 0;

    // Island
    const islandGeometry = new THREE.CylinderGeometry(islandRadius, islandRadius, islandLevel * 2, 32);
    const islandMaterial = new THREE.MeshStandardMaterial({ color: 0x967969 }); // Brownish color
    const islandMesh = new THREE.Mesh(islandGeometry, islandMaterial);
    islandMesh.position.y = islandLevel / 2; // Center it vertically around islandLevel
    islandMesh.receiveShadow = true;
    // +++ Assign the name property +++
    islandMesh.name = 'island'; // <<< ENSURE THIS LINE IS PRESENT
    // ++++++++++++++++++++++++++++++++
    scene.add(islandMesh);
    console.log(`SCENESETUP: Island mesh created and added with name: ${islandMesh.name}`); // Add log

    // Water
    console.log(`SCENESETUP: Creating water with radius factor based on ISLAND_RADIUS: ${islandRadius}`);
    const waterGeometry = new THREE.PlaneGeometry(islandRadius * 4, islandRadius * 4); // Large plane
    const waterMaterial = new THREE.MeshStandardMaterial({
        color: 0x4682B4, // Steel blue
        transparent: true,
        opacity: 0.8,
        roughness: 0.2,
        metalness: 0.1,
    });
    const waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
    waterMesh.rotation.x = -Math.PI / 2; // Rotate flat
    waterMesh.position.y = waterLevel;   // Position at water level
    console.log(`SCENESETUP: Water mesh Y position: ${waterMesh.position.y}`);
    waterMesh.receiveShadow = true; // Water can receive shadows (e.g., from trees)
    scene.add(waterMesh);
}

// Handles window resize events
function onWindowResize() {
    if (camera && renderer) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
}

--- FILE: client/ui/controlsHandlers.js ---
// client/ui/controlsHandlers.js
import { uiElements } from './elements.js';
// Import the socket instance from main.js
import { socket } from '../main.js';
// We no longer directly modify gameState here
// import { gameState } from '../gameState.js';

/**
 * Handles changes to the Stomata Slider input.
 * Updates the UI display and sends the new value to the server.
 * @param {Event} e - The input event object.
 */
export function handleStomataChange(e) {
    const newValue = parseFloat(e.target.value);

    // Update UI display immediately for responsiveness
    if (uiElements.stomataValueUI) {
        uiElements.stomataValueUI.textContent = `${Math.round(newValue * 100)}%`;
    }

    // --- Send update to server ---
    if (socket && socket.connected) {
        // console.log(`UI->Server: Emitting updateStomata: ${newValue}`); // Debug log
        socket.emit('updateStomata', { value: newValue });
    } else {
        console.warn("Socket not connected, cannot send stomata update.");
    }

    // --- REMOVE direct gameState modification ---
    // gameState.stomatalConductance = newValue;
}

/**
 * Handles changes to EITHER the Savings or Growth Ratio sliders.
 * Updates the UI display and sends the new allocation intent to the server.
 */
export function handleAllocationSliderChange() {
    // Check required elements exist
    if (!uiElements.savingsSlider || !uiElements.growthRatioSlider ||
        !uiElements.savingsPercentageUI || !uiElements.growthRatioPercentageUI) {
            console.warn("Allocation slider UI elements missing in handler.");
            return;
        }

    // Read current values from both sliders
    const savingsPercent = parseInt(uiElements.savingsSlider.value) || 0;
    const growthRatioPercent = parseInt(uiElements.growthRatioSlider.value) || 0;

    // Update percentage displays immediately
    uiElements.savingsPercentageUI.textContent = `${savingsPercent}%`;
    const seedRatioPercent = 100 - growthRatioPercent;
    uiElements.growthRatioPercentageUI.textContent = `${growthRatioPercent}%/${seedRatioPercent}%`;

    // --- Send update to server ---
    if (socket && socket.connected) {
         // console.log(`UI->Server: Emitting updateAllocation: Savings=${savingsPercent}, GrowthRatio=${growthRatioPercent}`); // Debug log
         socket.emit('updateAllocation', {
             savings: savingsPercent,
             growthRatio: growthRatioPercent
         });
    } else {
         console.warn("Socket not connected, cannot send allocation update.");
    }

    // --- REMOVE direct gameState modification ---
    // gameState.lastSavingsPercent = savingsPercent;
    // gameState.lastGrowthRatioPercent = growthRatioPercent;
}

--- FILE: client/ui/elements.js ---
// client/ui/elements.js
export let uiElements = {};
export function cacheDOMElements() {
    console.log("UI: Caching DOM elements...");
    uiElements = {
        gameContainer: document.getElementById('game-container'),
        canvas: document.getElementById('game-canvas'),

        // +++ Add Back Button +++
        backButton: document.getElementById('back-to-menu-button'),

        // Top Left Elements
        dayCounterUI: document.getElementById('day-counter'),
        timeOfDayUI: document.getElementById('time-of-day'),
        weatherStatusUI: document.getElementById('weather-status'),
        cycleTimerUI: document.getElementById('cycle-timer'),
        messageLogUI: document.getElementById('message-log'),
        // Lobby Elements
        lobbyInfoPanel: document.getElementById('lobby-info'), // Container
        lobbyPlayerCountUI: document.getElementById('lobby-player-count'),
        lobbyInstructionUI: document.getElementById('lobby-instruction'), // Added previously
        countdownTimerDisplayUI: document.getElementById('countdown-timer-display'),
        startCountdownButton: document.getElementById('start-countdown-button'),

        // Top Right Elements
        leaderboardTitleUI: document.getElementById('leaderboard-title'),
        leaderboardListUI: document.getElementById('leaderboard-list'),

        // Bottom Left Elements
        bottomLeftStatus: document.getElementById('bottom-left-status'),
        carbonBar: document.getElementById('carbon-bar'),
        hydraulicBar: document.getElementById('hydraulic-bar'),
        carbonValueUI: document.getElementById('carbon-value'),
        hydraulicValueUI: document.getElementById('hydraulic-value'),
        seedCounterUI: document.getElementById('seed-counter'),

        // Bottom Right Controls
        controlPanelRight: document.getElementById('control-panel-right'),
        stomataSlider: document.getElementById('stomata-slider'),
        stomataValueUI: document.getElementById('stomata-value'),
        savingsSlider: document.getElementById('savings-slider'),
        savingsPercentageUI: document.getElementById('savings-percentage'),
        growthRatioSlider: document.getElementById('growth-ratio-slider'),
        growthRatioPercentageUI: document.getElementById('growth-ratio-percentage'),

        // Game Over Elements
        gameOverModal: document.getElementById('game-over-modal'),
        gameOverReasonUI: document.getElementById('game-over-reason'),
        finalDayUI: document.getElementById('final-day'),
        finalSeedsUI: document.getElementById('final-seeds'),
        restartButton: document.getElementById('restart-button'),

        // Admin specific elements (might be null on game page)
        adminControls: document.getElementById('admin-controls'),
        adminCloseModalButton: document.getElementById('admin-close-modal'),
    };

     // Verification log
     let foundCount = 0; let missing = [];
     const isGamePage = !!document.getElementById('start-countdown-button');
     const isAdminPage = !!document.getElementById('admin-controls');

     for (const key in uiElements) {
         if (uiElements[key]) {
             foundCount++;
         } else {
             // Refined checks to reduce noise based on page context
             const isOptionalOnGame = ['adminControls', 'adminCloseModalButton'].includes(key);
             const isOptionalOnAdmin = [
                'lobbyInstructionUI', 'startCountdownButton', 'bottomLeftStatus', 'carbonBar', 'hydraulicBar',
                'carbonValueUI', 'hydraulicValueUI', 'seedCounterUI', 'controlPanelRight', 'stomataSlider',
                'stomataValueUI', 'savingsSlider', 'savingsPercentageUI', 'growthRatioSlider',
                'growthRatioPercentageUI', 'finalDayUI', 'finalSeedsUI', 'restartButton'
             ].includes(key);

             if (isGamePage && !isOptionalOnGame && !uiElements[key]) {
                 console.warn(`UI element not found (Game Page): ${key}`); missing.push(key);
             } else if (isAdminPage && !isOptionalOnAdmin && !uiElements[key]) {
                  console.warn(`UI element not found (Admin Page): ${key}`); missing.push(key);
             } else if (!isGamePage && !isAdminPage && key !== 'gameContainer' && key !== 'canvas'){
                 // Ignore missing elements on other pages (like index, settings)
             }
         }
     }
      if (isGamePage || isAdminPage) {
          console.log(`UI: Cached ${foundCount} DOM elements. Missing: ${missing.length > 0 ? missing.join(', ') : 'None'}`);
      } else {
          console.log(`UI: Cached ${foundCount} DOM elements (non-game/admin page).`);
      }
}

--- FILE: server/game/gameLogic.js ---
// server/game/gameLogic.js
// Core game logic (start/stop countdown, end game, reset)
// has been moved into the GameInstance class (server/game/GameInstance.js)
// This file is kept temporarily for reference or can be deleted.

console.log("server/game/gameLogic.js loaded (logic moved to GameInstance)");

// export function startLobbyCountdown(io) { ... } // REMOVED
// export function cancelLobbyCountdown() { ... } // REMOVED
// export function endGame(io, players, globalState, reason = "All trees have perished!") { ... } // REMOVED
// export function resetGame() { ... } // REMOVED

--- FILE: .gitignore ---
dirgrab.txt
server/node_modules
package-lock.json

--- FILE: client/config.js ---
// config.js (Project Root - Client-Side Config)

// --- UI & Display Constants ---
export const MAX_CARBON = 200; // Used for UI bar calculation
export const BASE_HYDRAULIC = 50; // Fallback for UI bar if player state not ready

// --- Rendering & Visual Defaults ---
export const INITIAL_TRUNK_HEIGHT = 2; // Used as fallback for camera target
export const ISLAND_RADIUS = 50; // <<-- Ensure this is present and correct
export const WATER_LEVEL = 0; // <<-- Ensure this is present and correct
export const ISLAND_LEVEL = 0.1; // Needed for positioning trees? Check tree.js usage.
export const DEFAULT_LEAF_COLOR = '#228B22'; // Forest Green - Used if server doesn't send color? Or for material fallback.
export const DEFAULT_TRUNK_COLOR = '#8B4513'; // Saddle Brown - Used if server doesn't send color? Or for material fallback.

// --- Canopy Tile Configuration (Client needs for rendering) ---
export const CANOPY_TILE_GRID_SIZE = 10;
export const CANOPY_TILE_THICKNESS = 0.1;

// --- Tree Structure Ratio (Client needs for rendering calculations) ---
export const k_TA_LA_RATIO = 0.01; // Trunk cross-section area / Leaf Area ratio
export const INITIAL_LEAF_AREA = 5; // Used in tree.js for calculating initial tile size

// --- Environment Visuals (Client needs for environment.js defaults/calcs) ---
export const PERIOD_DURATION = 7.0;
export const NUM_DAY_PERIODS = 3;
export const DAY_TOTAL_DURATION = PERIOD_DURATION * NUM_DAY_PERIODS;
export const NIGHT_DURATION = 3.0;
export const TOTAL_CYCLE_DURATION = DAY_TOTAL_DURATION + NIGHT_DURATION;
export const LIGHT_MULT_SUNNY = 1.0;
export const LIGHT_MULT_CLOUDY = 0.4;
export const DROUGHT_MULT_BASE = 1.0;
export const DROUGHT_VARIATION = 0.4;


// NOTE: Simulation rates, costs, probabilities, etc., are now primarily server-side
// in server/config.js and should NOT be duplicated here unless specifically
// needed for some client-side prediction or display logic (which we currently don't have).

--- FILE: client/tree.js ---
// client/tree.js
import * as THREE from 'three';
import * as Config from './config.js';
import { scene } from './sceneSetup.js';
import { gameState } from './gameState.js';

// Shared Materials
let sharedTrunkMaterial = null;
let sharedCanopyMaterial = null;
function ensureSharedMaterials() {
    const leafColor = Config.DEFAULT_LEAF_COLOR;
    const trunkColor = Config.DEFAULT_TRUNK_COLOR;
    if (!sharedTrunkMaterial) sharedTrunkMaterial = new THREE.MeshStandardMaterial({ color: trunkColor, name: 'sharedTrunkMaterial' });
    if (!sharedCanopyMaterial) sharedCanopyMaterial = new THREE.MeshStandardMaterial({ color: leafColor, name: 'sharedCanopyMaterial' });
}

// Helper Functions
function shuffleArray(array) { for (let i=array.length-1; i>0; i--) { const j=Math.floor(Math.random()*(i+1)); [array[i],array[j]]=[array[j],array[i]]; } }
function calculateDimensions(playerData) {
    const currentLA = (playerData.currentLA > 0) ? playerData.currentLA : 0.0001;
    const trunkHeight = (playerData.trunkHeight > 0) ? playerData.trunkHeight : Config.INITIAL_TRUNK_HEIGHT;
    const canopyWidth = Math.sqrt(currentLA);
    const trunkArea = currentLA * (Config.k_TA_LA_RATIO !== undefined ? Config.k_TA_LA_RATIO : 0.01); // Use default if needed
    const trunkWidth = Math.sqrt(trunkArea);
    return { canopyWidth: canopyWidth, canopyDepth: canopyWidth, trunkWidth: Math.max(0.1, trunkWidth), trunkDepth: Math.max(0.1, trunkWidth), trunkHeight: trunkHeight };
}

// --- Tree Creation/Update ---
export function createOrUpdateTree(playerId, playerData) {

    // +++ CRITICAL CHECK: Do not create/update trees for spectators +++
    if (!playerData || playerData.isSpectator) { // Check if playerData exists and if spectator
        if (gameState.playerTrees.has(playerId)) {
             console.log(`TREE: Player ${playerId} is spectator or data invalid, removing existing tree.`);
             removeTree(playerId);
        }
        return; // Stop processing
    }

    // Player is NOT a spectator, proceed
    ensureSharedMaterials();

    let treeMeshGroup = gameState.playerTrees.get(playerId);
    const dimensions = calculateDimensions(playerData);
    const baseHeight = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
    const targetPosition = new THREE.Vector3(playerData.spawnPoint?.x ?? 0, baseHeight, playerData.spawnPoint?.z ?? 0);

    if (!treeMeshGroup) {
        // Create New Tree
        treeMeshGroup = new THREE.Group(); treeMeshGroup.name = `playerTree_${playerId}`;
        const trunkGeometry = new THREE.BoxGeometry(dimensions.trunkWidth, dimensions.trunkHeight, dimensions.trunkDepth);
        const trunkMat = sharedTrunkMaterial.clone(); // Clone for customization
        trunkMat.color.set(playerData.trunkColor || Config.DEFAULT_TRUNK_COLOR); // Set initial color
        const trunkMesh = new THREE.Mesh(trunkGeometry, trunkMat);
        trunkMesh.name = "trunk"; trunkMesh.position.y = (dimensions.trunkHeight / 2); trunkMesh.castShadow = true; trunkMesh.receiveShadow = true; treeMeshGroup.add(trunkMesh);

        const canopyGroup = new THREE.Group(); canopyGroup.name = "canopyGroup"; const tiles = [];
        const gridSize = Config.CANOPY_TILE_GRID_SIZE !== undefined ? Config.CANOPY_TILE_GRID_SIZE : 10; // Use default if needed
        const tileWidth = dimensions.canopyWidth / gridSize; const tileDepth = dimensions.canopyDepth / gridSize; const tileThickness = Config.CANOPY_TILE_THICKNESS !== undefined ? Config.CANOPY_TILE_THICKNESS : 0.1; // Use default if needed
        const tileGeometry = new THREE.BoxGeometry(tileWidth, tileThickness, tileDepth);
        const leafMatBase = sharedCanopyMaterial.clone(); // Clone base material
        leafMatBase.color.set(playerData.leafColor || Config.DEFAULT_LEAF_COLOR); // Set initial color

        for (let i = 0; i < gridSize; i++) { for (let j = 0; j < gridSize; j++) {
            // Assign the same cloned & colored material instance to all tiles initially
            const tileMesh = new THREE.Mesh(tileGeometry, leafMatBase);
            const xPos = (i-(gridSize-1)/2)*tileWidth; const zPos = (j-(gridSize-1)/2)*tileDepth;
            tileMesh.position.set(xPos, 0, zPos); tileMesh.castShadow=true; tileMesh.receiveShadow=true; tileMesh.name = `canopyTile_${i}_${j}`; canopyGroup.add(tileMesh); tiles.push(tileMesh); } }
        shuffleArray(tiles); canopyGroup.userData.tiles = tiles; canopyGroup.userData.creationWidth = dimensions.canopyWidth;
        treeMeshGroup.add(canopyGroup);
        treeMeshGroup.position.copy(targetPosition);
        if (scene) scene.add(treeMeshGroup); else console.error("Scene not found for tree");
        gameState.playerTrees.set(playerId, treeMeshGroup);
    }

    // Update Existing Tree (geometry, scale, visibility, colors)
    if (!treeMeshGroup.position.equals(targetPosition)) { treeMeshGroup.position.copy(targetPosition); }
    updateTreeGeometry(treeMeshGroup, playerData, dimensions);
    updateCanopyTiles(treeMeshGroup, playerData); // Handles damage and color updates
    treeMeshGroup.visible = playerData.isAlive; // Visibility based on alive status only (spectator check above)
}

// --- Update Helpers ---
function updateTreeGeometry(treeMeshGroup, playerData, dimensions) { if (!treeMeshGroup) return; const trunkMesh = treeMeshGroup.getObjectByName("trunk"); const canopyGroup = treeMeshGroup.getObjectByName("canopyGroup"); if (trunkMesh && trunkMesh.geometry) { const params = trunkMesh.geometry.parameters; if (Math.abs(params.width - dimensions.trunkWidth) > 0.01 || Math.abs(params.height - dimensions.trunkHeight) > 0.01 || Math.abs(params.depth - dimensions.trunkDepth) > 0.01) { trunkMesh.geometry.dispose(); trunkMesh.geometry = new THREE.BoxGeometry(dimensions.trunkWidth, dimensions.trunkHeight, dimensions.trunkDepth); } trunkMesh.position.y = dimensions.trunkHeight / 2; } if (canopyGroup) { const tileThickness = Config.CANOPY_TILE_THICKNESS !== undefined ? Config.CANOPY_TILE_THICKNESS : 0.1; canopyGroup.position.y = dimensions.trunkHeight + (tileThickness / 2); const creationWidth = canopyGroup.userData.creationWidth || dimensions.canopyWidth; const currentWidth = dimensions.canopyWidth; const scaleFactor = (creationWidth > 0.01) ? (currentWidth / creationWidth) : 0.01; if (Math.abs(canopyGroup.scale.x - scaleFactor) > 0.001) { canopyGroup.scale.set(scaleFactor, 1, scaleFactor); } } }

function updateCanopyTiles(treeMeshGroup, playerData) {
    if (!treeMeshGroup) return;
    const canopyGroup = treeMeshGroup.getObjectByName("canopyGroup");
    if (!canopyGroup || !canopyGroup.userData.tiles) return;
    const tiles = canopyGroup.userData.tiles; const totalTiles = tiles.length; if (totalTiles === 0) return;

    // Update Tile Visibility (Damage)
    const damagePercent = playerData.damagedLAPercentage || 0;
    const hiddenTilesCount = Math.floor(totalTiles * damagePercent);
    for (let i = 0; i < totalTiles; i++) { tiles[i].visible = (i >= hiddenTilesCount); }

    // Update Tile Color (Uses the material instance shared by tiles in this group)
    const leafColor = playerData.leafColor || Config.DEFAULT_LEAF_COLOR;
    if (tiles[0] && tiles[0].material && tiles[0].material.color) { // Check material of first tile
        if (!tiles[0].material.color.equals(new THREE.Color(leafColor))) {
            tiles[0].material.color.set(leafColor); // Update color on the shared material instance
        }
    }

    // Update Trunk Color
    const trunkMesh = treeMeshGroup.getObjectByName("trunk");
    const trunkColor = playerData.trunkColor || Config.DEFAULT_TRUNK_COLOR;
    if (trunkMesh && trunkMesh.material && trunkMesh.material.color) {
         if (!trunkMesh.material.color.equals(new THREE.Color(trunkColor))) {
            trunkMesh.material.color.set(trunkColor);
         }
    }
}


// --- Removal & Disposal ---
export function removeTree(playerId) { const treeMeshGroup = gameState.playerTrees.get(playerId); if (treeMeshGroup) { disposeTreeGroup(treeMeshGroup); if (scene && treeMeshGroup.parent) scene.remove(treeMeshGroup); gameState.playerTrees.delete(playerId); } }
function disposeTreeGroup(group) { if (!group) return; group.traverse((obj) => { if (obj.isMesh) { if (obj.geometry) obj.geometry.dispose(); if (obj.material) { if (Array.isArray(obj.material)) { obj.material.forEach(material => material.dispose()); } else { obj.material.dispose(); } } } }); }
export function disposeAllTrees() { gameState.playerTrees.forEach(treeGroup => { disposeTreeGroup(treeGroup); if(scene && treeGroup.parent) scene.remove(treeGroup); }); gameState.playerTrees.clear(); disposeSharedTreeMaterials(); console.log("Disposed all player trees and shared materials."); }
export function disposeSharedTreeMaterials() { if (sharedTrunkMaterial) { sharedTrunkMaterial.dispose(); sharedTrunkMaterial = null; } if (sharedCanopyMaterial) { sharedCanopyMaterial.dispose(); sharedCanopyMaterial = null; } }

--- FILE: client/admin.html ---
--- FILE: client/admin.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Forest Royale - Admin Panel</title>
    <!-- Link to shared stylesheet -->
    <link rel="stylesheet" href="/style.css">
    <style>
        /* Admin specific styles */
        #admin-controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(150, 0, 0, 0.7);
            border: 1px solid #ff0000;
            padding: 15px;
            border-radius: 8px;
            z-index: 20; /* Above other UI panels */
            display: flex; /* Changed from none to flex, JS will hide/show */
            gap: 10px;
        }
        #admin-controls button {
            background-color: #a00;
            color: white;
            border: 1px solid #f00;
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 4px;
        }
         #admin-controls button:hover {
             background-color: #d00;
         }
         /* Ensure game container takes full space */
         #game-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
         #game-canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <!-- Game View Container -->
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
    </div>

    <!-- ================================== -->
    <!-- +++ Back to Menu Button +++ -->
    <!-- ================================== -->
    <!-- Use same ID and class as game.html for consistency -->
    <button id="back-to-menu-button" class="back-button">Back to Menu</button>

    <!-- Informational UI Panels (Similar to game.html, but no player status/controls) -->
    <div id="top-left-info" class="ui-panel">
         <p>Day: <span id="day-counter">1</span></p>
         <p>Time: <span id="time-of-day">Loading...</span></p>
         <p>Weather: <span id="weather-status">--</span></p>
         <p>Cycle Left: <span id="cycle-timer">--</span>s</p>
         <div id="message-log" class="message">ADMIN VIEW</div> <!-- Indicate admin view -->
         <!-- Lobby/Countdown Info -->
         <div id="lobby-info" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #555;">
             <h4>Lobby</h4>
             <p>Players (<span id="lobby-player-count">0</span>)</p>
             <p id="countdown-timer-display" style="font-weight: bold; color: #ffc107;"></p>
             <!-- No start button needed here -->
             <!-- No lobby instruction needed here -->
         </div>
    </div>

    <div id="top-right-leaderboard" class="ui-panel leaderboard">
         <h4 id="leaderboard-title">Leaderboard (-/-)</h4>
         <ul id="leaderboard-list">
             <li>Waiting for state...</li>
         </ul>
    </div>

    <!-- Admin Controls Panel (JS controls initial visibility based on auth) -->
    <div id="admin-controls" class="ui-panel" style="display: none;">
        <button id="admin-force-start">Force Start</button>
        <button id="admin-force-end">Force End</button>
        <button id="admin-reset-countdown">Reset Countdown</button>
        <!-- Add more controls later if needed -->
    </div>


    <!-- Game Over Modal (reuse from game.html structure) -->
     <div id="game-over-modal" class="modal hidden">
         <h2>Game Over!</h2>
        <p id="game-over-reason"></p>
        <p>Game ended by admin or naturally.</p> <!-- Generic message -->
        <!-- No Play Again button needed for admin? Or maybe a 'Reset Server State' button? -->
        <button id="admin-close-modal">Close</button>
    </div>


    <!-- Imports -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="/socket.io/socket.io.js"></script>
    <!-- Link to NEW Admin JS file -->
    <script type="module" src="/admin.js"></script>
</body>
</html>

--- FILE: client/main.js ---
// client/main.js

import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; // Keep if OrbitControls is used here
import { gameState, loadClientSettings, getMyPlayerState } from './gameState.js';
import * as Config from './config.js';
import { initScene, renderer, camera, controls, scene } from './sceneSetup.js';
import { createOrUpdateTree, removeTree, disposeAllTrees } from './tree.js';
import { uiElements, cacheDOMElements } from './ui/elements.js'; // Import uiElements
import { setupUIListeners } from './ui/setupListeners.js';
import { updateUI } from './ui/update.js';
import { showMessage, clearMessage, attachServerMessageListener } from './ui/messageHandler.js';
import { hideGameOverModal, showGameOverUI } from './ui/gameOver.js';
import { updateEnvironmentVisuals, updateRain, setWeatherTargets, startRain, stopRain } from './environment.js';

// --- Global Variables ---
let clock = new THREE.Clock(); let animationFrameId = null; let socket = null;
let raycaster = new THREE.Raycaster(); let mouse = new THREE.Vector2();
let islandMesh = null; let spawnMarkers = new Map(); let tempSpawnMarker = null;

// --- Initialization Function ---
function initializeApp() {

    console.error("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
    console.error("!!! ERROR: main.js initializeApp Running !!!");
    console.error("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");

    console.log("Initializing Island Canopy Sim Client...");
    const intent = sessionStorage.getItem('gameModeIntent') || 'single'; // Default to single if nothing stored
    gameState.isSpectator = (intent === 'spectate');
    console.log(`Client: Detected intent: ${intent}, Is Spectator: ${gameState.isSpectator}`);

    loadClientSettings(); cacheDOMElements(); // Cache elements including the new button

    const canvas = uiElements.canvas; // Use cached element
    if (!canvas) { console.error("Canvas element #game-canvas not found!"); return; }
    initScene(canvas);

    islandMesh = scene.getObjectByName('island');
    if (!islandMesh) console.error("Spawn Error: Island mesh 'island' not found in scene!");
    // Only add spawn click listener if not spectator
    if (!gameState.isSpectator && canvas) {
        canvas.addEventListener('pointerup', handleSpawnClick, false);
        console.log("Spawn click listener added.");
    } else {
         console.log("Spectator mode: Spawn click listener skipped.");
    }


    // +++ Add Back Button Listener +++
    if (uiElements.backButton) {
        uiElements.backButton.addEventListener('click', () => {
            console.log("Client: Back to Menu button clicked.");
            if (socket && socket.connected) {
                socket.disconnect(); // Gracefully disconnect before navigating
            }
            window.location.href = '/'; // Navigate to main menu
        });
        console.log("Back button listener added.");
    } else {
         console.warn("Back button UI element not found during init.");
    }

    console.log("Attempting to connect to server...");
    socket = io({
         reconnection: true, // Enable default reconnection
         reconnectionAttempts: 5,
         reconnectionDelay: 1000,
    });
    setupSocketListeners(intent);
    setupUIListeners(); // Sets up listeners for game controls etc.
    updateUI(); clearMessage();
    console.log("Client Initialization complete. Waiting for server connection...");
}

// --- Spawn Selection Click Handler ---
function handleSpawnClick(event) {
    const myState = getMyPlayerState();
    // Check all conditions: lobby phase, not spectator, player state exists, hasn't chosen, island exists, not pointer locked
    if (gameState.gamePhase !== 'lobby' || gameState.isSpectator || !myState || myState.hasChosenSpawn || !islandMesh || document.pointerLockElement === renderer.domElement) {
        // console.log("Spawn click ignored:", gameState.gamePhase, gameState.isSpectator, !!myState, myState?.hasChosenSpawn); // Debug log
        return;
    }
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(islandMesh);
    if (intersects.length > 0) {
        const intersectionPoint = intersects[0].point;
        const islandRadius = Config.ISLAND_RADIUS || 50;
        // Check bounds relative to island center (0,0)
        if (intersectionPoint.x**2 + intersectionPoint.z**2 > islandRadius*islandRadius) {
            showMessage("Cannot spawn outside island!", "warning");
            return;
        }
        showTemporaryMarker(intersectionPoint);
        if (socket && socket.connected) {
            console.log(`Client: Emitting selectSpawnPoint: { x: ${intersectionPoint.x.toFixed(2)}, z: ${intersectionPoint.z.toFixed(2)} }`);
            socket.emit('selectSpawnPoint', { x: intersectionPoint.x, z: intersectionPoint.z });
        } else {
            showMessage("Not connected!", "error");
            removeTemporaryMarker();
        }
    }
}

// --- Spawn Marker Visuals ---
const markerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 16);
const tempMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.7 });
const confirmedMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
const otherPlayerMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500 });

function showTemporaryMarker(position) {
     removeTemporaryMarker();
     if (!tempSpawnMarker) {
         tempSpawnMarker = new THREE.Mesh(markerGeometry, tempMarkerMaterial);
         tempSpawnMarker.name = "tempSpawnMarker";
     }
     const baseLevel = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
     tempSpawnMarker.position.set(position.x, baseLevel + 0.1, position.z); // Position just above island level
     if (!tempSpawnMarker.parent) scene.add(tempSpawnMarker);
}
function removeTemporaryMarker() { if (tempSpawnMarker && tempSpawnMarker.parent) scene.remove(tempSpawnMarker); }

function addOrUpdateSpawnMarker(playerId, spawnPoint, isConfirmed) {
    if (!spawnPoint) return; // Guard against missing spawn point data
    let marker = spawnMarkers.get(playerId);
    if (!marker && isConfirmed) {
        const material = (playerId === gameState.myId && !gameState.isSpectator) ? confirmedMarkerMaterial.clone() : otherPlayerMarkerMaterial.clone();
        marker = new THREE.Mesh(markerGeometry.clone(), material);
        marker.name = `spawnMarker_${playerId}`;
        scene.add(marker);
        spawnMarkers.set(playerId, marker);
    }
    if (marker) {
         const baseLevel = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
        marker.position.set(spawnPoint.x, baseLevel + 0.1, spawnPoint.z);
        marker.visible = isConfirmed; // Only show confirmed markers
    }
}

function removeSpawnMarker(playerId) {
    const marker = spawnMarkers.get(playerId);
    if (marker) {
        if(marker.parent) scene.remove(marker);
        marker.geometry.dispose();
        if(marker.material) marker.material.dispose(); // Dispose material
        spawnMarkers.delete(playerId);
    }
}
function removeAllSpawnMarkers() {
    spawnMarkers.forEach((marker, playerId) => { removeSpawnMarker(playerId); }); // Use removeSpawnMarker for proper disposal
    spawnMarkers.clear();
    removeTemporaryMarker();
}

// --- Socket Event Listener Setup ---
function setupSocketListeners(intent) {
    socket.on('connect', () => {
        gameState.myId = socket.id;
        console.log(`Connected to server with ID: ${gameState.myId}`);
        showMessage(`Connected! Joining as ${intent}...`, 'info');
        // Retrieve settings to send with join request
        const playerName = localStorage.getItem('playerName') || `Tree_${socket.id.substring(0, 4)}`;
        const leafColor = localStorage.getItem('leafColor') || Config.DEFAULT_LEAF_COLOR;
        const trunkColor = localStorage.getItem('trunkColor') || Config.DEFAULT_TRUNK_COLOR;

        socket.emit('playerJoinRequest', {
            intent: intent,
            playerName: playerName,
            leafColor: leafColor,
            trunkColor: trunkColor
         });
        sessionStorage.removeItem('gameModeIntent'); // Clean up intent storage

        attachServerMessageListener(); // Moved here previously

    });

    socket.on('disconnect', (reason) => {
        console.log(`Disconnected: ${reason}`);
        showMessage("Disconnected!", "error");
        gameState.myId = null;
        gameState.initialStateReceived = false;
        gameState.isSpectator = false; // Reset spectator status on disconnect
        gameState.gameOver = false; // Reset game over state
        gameState.players = {}; // Clear player cache
        if (animationFrameId !== null) cancelAnimationFrame(animationFrameId); animationFrameId = null;
        disposeAllTrees();
        removeAllSpawnMarkers();
        updateUI(); // Update UI to reflect disconnected state
    });
    socket.on('connect_error', (error) => {
        console.error('Connection Error:', error);
        showMessage("Connection failed!", "error");
    });

    // --- Game State Update Handler ---
    socket.on('gameStateUpdate', (serverState) => {
        // console.log("GS Update:", serverState.gamePhase, serverState.players); // Debug log
        const previousPhase = gameState.gamePhase;

        // Check if serverState.players exists before trying to access it
        const playersFromServer = serverState.players || {};
        const myServerData = playersFromServer[gameState.myId];

        // Update core state properties
        Object.assign(gameState, {
            day: serverState.day, timeInCycle: serverState.timeInCycle, currentPeriodIndex: serverState.currentPeriodIndex,
            isNight: serverState.isNight, currentLightMultiplier: serverState.currentLightMultiplier, currentDroughtFactor: serverState.currentDroughtFactor,
            isRaining: serverState.isRaining, gamePhase: serverState.gamePhase, countdownTimer: serverState.countdownTimer,
            serverTime: serverState.serverTime,
            players: playersFromServer, // Update player cache
            allowPlayerCountdownStart: serverState.allowPlayerCountdownStart, // Sync admin toggle
        });

        // Update spectator status based *only* on server data for this client
        gameState.isSpectator = myServerData?.isSpectator ?? gameState.isSpectator; // Keep current if server data missing

        // First time setup
        if (!gameState.initialStateReceived && gameState.myId && myServerData) {
             console.log("First gameStateUpdate processed.");
             const myInitialState = myServerData; // Use direct data
             if (myInitialState && controls) {
                 const initialHeight = myInitialState.trunkHeight || Config.INITIAL_TRUNK_HEIGHT;
                 const targetX = myInitialState.spawnPoint?.x ?? 0;
                 const targetZ = myInitialState.spawnPoint?.z ?? 0;
                 const baseLevel = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
                 if(gameState.isSpectator) { // Camera for spectator
                     controls.target.set(0, 5, 0); // Overview
                     camera.position.set(15, 20, 15); // Slightly higher overview
                 } else { // Camera for player
                      controls.target.set(targetX, initialHeight / 2 + baseLevel, targetZ);
                      camera.position.set(targetX + 8, initialHeight + 5, targetZ + 8); // Position near own tree
                 }
                 controls.update();
             }
             // Initial environment setup
             setWeatherTargets(gameState.isNight, gameState.currentLightMultiplier < Config.LIGHT_MULT_SUNNY - 0.1, gameState.isRaining);
             updateEnvironmentVisuals(1000); // Initial fast transition
             if(gameState.isRaining) startRain(); else stopRain();

             gameState.initialStateReceived = true;
             startGameLoop(); // Start render loop ONLY after first state
             setTimeout(() => showMessage(`Game state: ${gameState.gamePhase}`, 'info'), 100);
         } else if (gameState.gamePhase !== previousPhase) {
             console.log(`Client phase updated from ${previousPhase} to: ${gameState.gamePhase}`);
             showMessage(`Game state: ${gameState.gamePhase}`, 'info');
             // Clear spawn markers when leaving lobby/countdown
             if ((previousPhase === 'lobby' || previousPhase === 'countdown') && (gameState.gamePhase !== 'lobby' && gameState.gamePhase !== 'countdown')) {
                 removeAllSpawnMarkers();
             }
         }

         // --- Continuous Updates ---

         // Update Environment Visuals (Sky, Fog, Rain)
         const wasRaining = scene?.getObjectByName("rain")?.visible ?? false;
         setWeatherTargets(gameState.isNight, gameState.currentLightMultiplier < Config.LIGHT_MULT_SUNNY - 0.1, gameState.isRaining);
         if (gameState.isRaining && !wasRaining) startRain();
         else if (!gameState.isRaining && wasRaining) stopRain();

         // Update Trees & Spawn Markers
         const receivedPlayerIds = new Set(Object.keys(playersFromServer));
         for (const playerId in playersFromServer) {
             const playerData = playersFromServer[playerId];
             // Tree Rendering: Render if NOT spectator OR if spectator viewing others
             if (!playerData.isSpectator) {
                 createOrUpdateTree(playerId, playerData);
             } else {
                  // Ensure no tree is rendered for spectators themselves
                  removeTree(playerId);
             }
             // Spawn Marker Rendering: Only show in lobby/countdown phase
             if (gameState.gamePhase === 'lobby' || gameState.gamePhase === 'countdown') {
                 addOrUpdateSpawnMarker(playerId, playerData.spawnPoint, playerData.hasChosenSpawn);
             }
         }
         // Remove trees for players no longer in the state
         gameState.playerTrees.forEach((_, playerId) => {
             if (!receivedPlayerIds.has(playerId)) removeTree(playerId);
         });
         // Remove markers for players no longer in the state
         spawnMarkers.forEach((_, playerId) => {
              if (!receivedPlayerIds.has(playerId)) removeSpawnMarker(playerId);
         });
         // Clean up all markers if not in lobby/countdown
         if (gameState.gamePhase !== 'lobby' && gameState.gamePhase !== 'countdown' && spawnMarkers.size > 0) {
             removeAllSpawnMarkers();
         }

         // Update Camera Target (Player Follow / Spectator Overview)
         const myCurrentState = getMyPlayerState(); // Get potentially updated state
         if (myCurrentState && myCurrentState.isAlive && !gameState.isSpectator && controls && gameState.playerTrees.has(gameState.myId)) {
             const myTreeGroup = gameState.playerTrees.get(gameState.myId);
             if (myTreeGroup) { // Check tree exists
                 const baseLevel = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
                 const targetPos = new THREE.Vector3(myTreeGroup.position.x, myCurrentState.trunkHeight / 2 + baseLevel, myTreeGroup.position.z);
                 if (!controls.target.equals(targetPos)){ controls.target.lerp(targetPos, 0.1); } // Smooth follow
             }
         } else if (controls && (gameState.isSpectator || !myCurrentState?.isAlive) && gameState.gamePhase !== 'lobby') {
             // If spectator, or player is dead, or game not in lobby -> general overview
             controls.target.lerp(new THREE.Vector3(0, 5, 0), 0.05);
         }
         // No camera lerp in lobby - allow free look

     }); // End gameStateUpdate

    // --- Spawn Handlers ---
    socket.on('spawnPointConfirmed', (confirmedPoint) => {
        if(gameState.isSpectator) return;
        console.log("Client: Spawn Confirmed", confirmedPoint);
        removeTemporaryMarker();
        const myId = gameState.myId;
        if (myId) {
            addOrUpdateSpawnMarker(myId, confirmedPoint, true);
            const myState = getMyPlayerState();
            if(myState) myState.hasChosenSpawn = true; // Update local cache immediately
            showMessage("Spawn confirmed!", "success"); // Changed type
            updateUI(); // Update UI to show "(Placed)" status
        }
    });
    socket.on('spawnPointInvalid', (data) => {
        if(gameState.isSpectator) return;
        console.log("Client: Spawn Invalid", data);
        removeTemporaryMarker();
        showMessage(`Spawn invalid: ${data?.reason || 'Try again.'}`, "warning");
    });

    // --- Other handlers ---
    socket.on('playerDisconnected', (playerId) => {
        console.log(`Player ${playerId} disconnected.`);
        removeTree(playerId);
        removeSpawnMarker(playerId);
        // Player list UI will update on next gameStateUpdate
    });
    socket.on('gameOver', (data) => {
        console.log("Game Over received:", data);
        gameState.gameOver = true;
        gameState.gameOverReason = data.reason || "Game Ended!";
        gameState.winnerId = data.winnerId;
        removeAllSpawnMarkers();
        showGameOverUI(); // Update UI immediately
    });

     // Listen for server messages (e.g., join notifications)
     socket.on('serverMessage', (data) => {
         console.log("Received server message:", data);
         showMessage(data.text, data.type || 'info');
     });


} // End of setupSocketListeners

// --- Main Game Loop & Helpers ---
function gameLoop() {
    animationFrameId=requestAnimationFrame(gameLoop);
    const dt=clock.getDelta();
    updateEnvironmentVisuals(dt);
    updateRain(dt);
    updateUI(); // Update UI every frame
    if(controls) controls.update();
    if(renderer && scene && camera) renderer.render(scene, camera);
    else { console.error("Render components missing!"); stopGameLoop(); }
}
function startGameLoop() {
    if(animationFrameId!==null) return;
    console.log("MAIN: Starting client render loop.");
    clock = new THREE.Clock(); // Reset clock
    gameLoop();
}
function stopGameLoop() {
    if(animationFrameId!==null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        console.log("MAIN: Stopped client render loop.");
    }
}
// handleRestart is now primarily used by the GameOver modal 'Play Again' button
export function handleRestart() {
     console.log("Restart button clicked, navigating to /");
     if (socket && socket.connected) {
        socket.disconnect();
     }
     window.location.href = '/';
}

// --- Export socket for other modules ---
export { socket };

// --- Start Application ---
document.addEventListener('DOMContentLoaded', initializeApp);

--- FILE: client/settings.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Island Canopy Sim - Settings</title>
    <link rel="stylesheet" href="style.css"> <!-- Shared style or create settings.css -->
     <style>
        /* Basic Settings Page Specific Styles */
         body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #333;
            color: #f0f0f0;
            font-family: sans-serif;
        }
        .settings-container {
            background-color: rgba(0, 0, 0, 0.6);
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 500px; /* Limit max width */
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
         h2 {
            text-align: center;
            color: #ccc;
            margin-bottom: 25px;
        }
        .setting-item {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding-bottom: 15px;
            border-bottom: 1px solid #444;
        }
        .setting-item label {
            flex-basis: 120px; /* Fixed width for labels */
            flex-shrink: 0;
            font-weight: bold;
            color: #bbb;
        }
        .setting-item input[type="text"],
        .setting-item input[type="color"] {
             padding: 8px;
             border: 1px solid #555;
             background-color: #444;
             color: #eee;
             border-radius: 4px;
             flex-grow: 1; /* Allow input to take space */
        }
         .setting-item input[type="color"] {
            min-width: 50px; /* Ensure color picker is usable */
            height: 40px;
            padding: 2px;
            flex-grow: 0; /* Don't let color picker grow too much */
        }
        .placeholder { /* Style for future feature area */
            border: 1px dashed #555;
            padding: 15px;
            text-align: center;
            color: #777;
            font-style: italic;
            margin-top: 10px;
            width: 100%; /* Take full width */
        }
         .button-group {
            margin-top: 30px;
            text-align: center;
        }
         button {
             padding: 10px 20px;
             font-size: 1em;
             cursor: pointer;
             border: none;
             border-radius: 5px;
             background-color: #008080; /* Teal */
             color: #f0f0f0;
             transition: background-color 0.3s ease;
         }
         button:hover {
             background-color: #009999; /* Darker Teal */
         }
    </style>
</head>
<body>
    <div class="settings-container">
        <h2>Settings</h2>

        <div class="setting-item">
            <label for="player-name">Player Name:</label>
            <input type="text" id="player-name" maxlength="16" placeholder="Treebard">
        </div>

        <div class="setting-item">
            <label for="leaf-color">Leaf Color:</label>
            <input type="color" id="leaf-color" value="#228B22">
        </div>

        <div class="setting-item">
            <label for="trunk-color">Trunk Color:</label>
            <input type="color" id="trunk-color" value="#8B4513">
        </div>

         <div class="setting-item">
             <label>Canopy Style:</label>
             <div class="placeholder">
                 Advanced Customization (Paint / Image Upload) Coming Soon!
             </div>
         </div>


        <div class="button-group">
            <button id="save-settings">Save & Back</button>
        </div>

    </div>

    <script src="settings.js"></script>
</body>
</html>

--- FILE: client/ui/messageHandler.js ---
// client/ui/messageHandler.js
import { uiElements } from './elements.js';
// Import socket reference - it might be null initially
import { socket } from '../main.js';

let listenerAttached = false; // Module-level flag

/** Shows a message in the message log area. */
export function showMessage(text, type = 'info') {
     if (uiElements.messageLogUI) {
        uiElements.messageLogUI.textContent = text;
        uiElements.messageLogUI.className = `message ${type}`;
     } else {
         // console.warn(`Msg Log UI not found. (${type}): ${text}`); // Reduce noise
     }
}

/** Clears the message log area. */
export function clearMessage() {
    if (uiElements.messageLogUI) {
        uiElements.messageLogUI.textContent = '';
        uiElements.messageLogUI.className = 'message';
    }
}

/**
 * Attaches the listener for the 'serverMessage' event.
 * Should be called once the socket connection is established.
 */
export function attachServerMessageListener() {
    // Prevent attaching multiple times and ensure socket exists
    if (!socket || listenerAttached) {
        if(listenerAttached) console.log("Message Handler: Listener already attached.");
        if(!socket) console.warn("Message Handler: attach called but socket is not ready.");
        return;
    }

    socket.on('serverMessage', (data) => {
        console.log("Received server message:", data);
        showMessage(data.text, data.type || 'info');
    });

    listenerAttached = true;
    console.log("Message Handler: Server message listener attached.");
}

// --- DO NOT CALL setup automatically on load ---
// setupServerMessageListener(); // REMOVED - Call attachServerMessageListener from main.js instead

--- FILE: client/game.html ---
--- FILE: client/game.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Island Canopy Sim</title>
    <link rel="stylesheet" href="/style.css"> <!-- Use root-relative path -->
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
    </div>

    <!-- ================================== -->
    <!-- +++ Back to Menu Button +++ -->
    <!-- ================================== -->
    <button id="back-to-menu-button" class="back-button">Back to Menu</button>


    <!-- ================================== -->
    <!-- UI Structure -->
    <!-- ================================== -->

    <!-- Top Left Info Area -->
    <div id="top-left-info" class="ui-panel">
         <p>Day: <span id="day-counter">1</span></p>
         <p>Time: <span id="time-of-day">Loading...</span></p> <!-- Start with Loading -->
         <p>Weather: <span id="weather-status">--</span></p>
         <p>Cycle Left: <span id="cycle-timer">--</span>s</p>
         <div id="message-log" class="message"></div>

         <!-- Lobby/Countdown Specific UI (Initially Hidden) -->
         <div id="lobby-info" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid #555;">
             <h4>Lobby</h4>
             <p>Players (<span id="lobby-player-count">0</span>)</p>
             <!-- +++ Add instruction text here +++ -->
             <p id="lobby-instruction" style="font-style: italic; color: #cccccc; margin-bottom: 8px;">Click on the island to choose your starting location!</p>
             <p id="countdown-timer-display" style="font-weight: bold; color: #ffc107;"></p> <!-- Timer display -->
             <button id="start-countdown-button" style="margin-top: 5px;">Start Countdown</button> <!-- Text updated by JS -->
         </div>

    </div>

     <!-- Top Right Leaderboard Area -->
    <div id="top-right-leaderboard" class="ui-panel leaderboard">
         <!-- Title changes based on phase -->
         <h4 id="leaderboard-title">Leaderboard (-/-)</h4> <!-- Updated placeholder -->
         <ul id="leaderboard-list">
             <li>Waiting for state...</li>
         </ul>
    </div>

     <!-- Bottom Left Status Area -->
     <div id="bottom-left-status" class="ui-panel"> <!-- <<< Ensure this ID is present -->
          <div class="status-bar-container">
                <label>Carbon:</label>
                <div class="bar-outer"><div id="carbon-bar" class="bar-inner carbon" style="width: 0%;"></div></div> <!-- Start at 0% -->
                <span id="carbon-value">--</span>
            </div>
            <div class="status-bar-container">
                <label>Hydraulics:</label>
                <div class="bar-outer"><div id="hydraulic-bar" class="bar-inner hydraulic" style="width: 0%;"></div></div> <!-- Start at 0% -->
                 <span id="hydraulic-value">--</span>
            </div>
             <p>Seeds: <span id="seed-counter">0</span></p>
     </div>

     <!-- Control Panel Area (Bottom Right) -->
     <div id="control-panel-right" class="ui-panel" style="display: none;"> <!-- Start hidden -->
          <div class="control-row stomata">
             <label for="stomata-slider">Stomatal Openness:</label>
             <input type="range" id="stomata-slider" min="0" max="1" step="0.05" value="0.5">
             <span id="stomata-value">50%</span>
          </div>
          <div class="control-row allocation">
             <label for="savings-slider">Carbon Savings %:</label>
             <input type="range" id="savings-slider" min="0" max="100" step="1" value="50">
             <span class="slider-percentage" id="savings-percentage">50%</span>
          </div>
           <div class="control-row allocation">
             <label for="growth-ratio-slider"> Invest % Grow/Seeds:</label>
             <input type="range" id="growth-ratio-slider" min="0" max="100" step="1" value="50">
             <span class="slider-percentage" id="growth-ratio-percentage">50%/50%</span>
          </div>
     </div>
     <!-- End Control Panel Area -->

    <!-- Game Over Modal (Still separate) -->
    <div id="game-over-modal" class="modal hidden">
         <h2>Game Over!</h2>
        <p id="game-over-reason"></p>
        <p>You survived <span id="final-day">0</span> days and produced <span id="final-seeds">0</span> seeds.</p>
        <button id="restart-button">Play Again</button>
    </div>

    <!-- Imports -->
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } } </script>
    <script src="/socket.io/socket.io.js"></script>
    <script type="module" src="/main.js"></script> <!-- Use root-relative path -->
</body>
</html>

--- FILE: client/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forest Royale - Welcome</title> <!-- Changed title -->
    <link rel="stylesheet" href="/style.css"> <!-- Root relative path -->
    <style>
        /* Basic Landing Page Specific Styles */
        body {
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; background-color: #2b412b; color: #f0f0f0;
            font-family: sans-serif; text-align: center;
        }
        .landing-container {
            background-color: rgba(0, 0, 0, 0.5); padding: 40px;
            border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        h1 { color: #90ee90; margin-bottom: 30px; font-size: 2.5em; }
        .button-group { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; }
        button {
            padding: 12px 25px; font-size: 1.1em; cursor: pointer; border: none; border-radius: 5px;
            background-color: #556b2f; /* Dark Olive Green */
            color: #f0f0f0; transition: background-color 0.3s ease;
        }
        button:hover:not(:disabled) { background-color: #6b8e23; } /* Olive Drab */
        button:disabled { background-color: #4a4a4a; color: #888; cursor: not-allowed; }
        /* Style for admin button */
        #admin-panel-button {
            background-color: #8B4513; /* Saddle Brown - distinct color */
        }
        #admin-panel-button:hover {
            background-color: #A0522D; /* Sienna */
        }
    </style>
</head>
<body>
    <div class="landing-container">
        <h1>Forest Royale</h1>
        <p>Make Good Decisions!</p>

        <div class="button-group">
            <button id="start-single-player">Single Player</button>
            <button id="start-multi-player">Multiplayer</button>
            <button id="spectate-game">Spectate Game</button>
            <button id="open-settings">Settings</button>
            <!-- +++ Add Admin Panel Button +++ -->
            <button id="admin-panel-button">Admin Panel</button>
        </div>
    </div>

    <script src="/index.js"></script> <!-- Root relative path -->
</body>
</html>

--- FILE: client/ui/leaderboard.js ---


--- FILE: client/ui/updateAdmin.js ---
// client/ui/updateAdmin.js - UI Updater for Admin Panel
import { gameState } from '../gameState.js';
import * as Config from '../config.js';
import { uiElements } from './elements.js'; // Use cached elements

/** Updates admin UI elements based on the current gameState. */
export function updateUI() { // Renamed function locally
    // Wait until elements are cached, no need to wait for initial state like player view
    if (!uiElements.dayCounterUI) { return; }

    const phase = gameState.gamePhase;
    const allConnections = gameState.players;
    const playersOnly = Object.values(allConnections).filter(p => !p.isSpectator);
    const playerCount = playersOnly.length;
    const aliveCount = playersOnly.filter(p => p.isAlive).length;

    // --- Update Info (Top Left) ---
    // (Same as regular update.js)
    if (uiElements.dayCounterUI) uiElements.dayCounterUI.textContent = (phase !== 'loading') ? gameState.day : '-';
    if (uiElements.timeOfDayUI) { let timeText = ''; if (phase === 'lobby' || phase === 'loading' || phase === 'ended') timeText = phase.charAt(0).toUpperCase() + phase.slice(1); else if (phase === 'countdown') timeText = 'Starting Soon!'; else if (phase === 'playing') { if (gameState.isNight) timeText = 'Night'; else if (gameState.currentPeriodIndex >= 0) timeText = `Day Period ${gameState.currentPeriodIndex + 1}`; else timeText = 'Starting...'; } else timeText = 'Unknown Phase'; uiElements.timeOfDayUI.textContent = timeText; }
    if (uiElements.cycleTimerUI) { let timeLeft = 0; if (phase === 'playing') { if (gameState.isNight) { const timeIntoNight = gameState.timeInCycle - Config.DAY_TOTAL_DURATION; timeLeft = Config.NIGHT_DURATION - timeIntoNight; } else if (gameState.currentPeriodIndex >= 0) { const timeIntoPeriod = gameState.timeInCycle - (gameState.currentPeriodIndex * Config.PERIOD_DURATION); timeLeft = Config.PERIOD_DURATION - timeIntoPeriod; } else { timeLeft = Config.PERIOD_DURATION - gameState.timeInCycle; } uiElements.cycleTimerUI.textContent = Math.max(0, Math.floor(timeLeft)); } else { uiElements.cycleTimerUI.textContent = '--'; } }
    if (uiElements.weatherStatusUI) { let weatherText = ''; if(phase === 'lobby' || phase === 'loading' || phase === 'ended' || phase === 'countdown') weatherText = '--'; else if (phase === 'playing') { if (gameState.isNight) weatherText = 'Night'; else weatherText = (gameState.currentLightMultiplier === Config.LIGHT_MULT_SUNNY) ? 'Sunny' : 'Cloudy'; if (gameState.isRaining) weatherText += ', Raining'; if (gameState.currentDroughtFactor > Config.DROUGHT_MULT_BASE + Config.DROUGHT_VARIATION * 0.6) weatherText += ' (Dry)'; else if (gameState.currentDroughtFactor < Config.DROUGHT_MULT_BASE - Config.DROUGHT_VARIATION * 0.6) weatherText += ' (Wet)'; } else weatherText = 'Initializing...'; uiElements.weatherStatusUI.textContent = weatherText; }

    // --- Update Lobby/Countdown Info (Top Left) ---
    // (Same as regular update.js, but button is hidden via HTML)
    if (uiElements.lobbyInfoPanel) {
        const showLobby = (phase === 'lobby' || phase === 'countdown');
        uiElements.lobbyInfoPanel.style.display = showLobby ? 'block' : 'none';
        if (showLobby) {
            if (uiElements.lobbyPlayerCountUI) uiElements.lobbyPlayerCountUI.textContent = Object.keys(allConnections).length;
             // No start button logic needed here
            if (uiElements.countdownTimerDisplayUI) { if (phase === 'countdown' && gameState.countdownTimer !== null) { uiElements.countdownTimerDisplayUI.textContent = `Starting in: ${gameState.countdownTimer}s`; uiElements.countdownTimerDisplayUI.style.display = 'block'; } else { uiElements.countdownTimerDisplayUI.style.display = 'none'; } }
        }
    }

    // --- Update Leaderboard / Player List (Top Right) ---
    // (Same as regular update.js - shows non-spectators)
    if (uiElements.leaderboardTitleUI) { if (phase === 'lobby' || phase === 'countdown') uiElements.leaderboardTitleUI.textContent = `Lobby (${Object.keys(allConnections).length})`; else uiElements.leaderboardTitleUI.textContent = `Leaderboard (${aliveCount}/${playerCount})`; }
    if (uiElements.leaderboardListUI) { let listHTML = ''; const playersToDisplay = Object.values(allConnections).filter(p => !p.isSpectator); playersToDisplay.sort((a, b) => { if (phase === 'lobby' || phase === 'countdown') { return (a?.playerName || '').localeCompare(b?.playerName || ''); } else { return (b?.seedCount ?? 0) - (a?.seedCount ?? 0); } }); playersToDisplay.forEach(player => { const isMe = player.id === gameState.myId; let status = ''; if (player.isSpectator) status = ' (Spectating)'; else if (phase === 'playing' || phase === 'ended') status = player.isAlive ? '' : ' (Dead)'; else if (phase === 'lobby' || phase === 'countdown') status = player.hasChosenSpawn ? ' (Placed)' : ''; const name = player.playerName || `Player ${player.id.substring(0,4)}`; const seeds = (phase === 'playing' || phase === 'ended') ? `: ${player.seedCount} Seeds` : ''; listHTML += `<li${isMe ? ' style="font-weight: bold;"' : ''}>${name}${status}${seeds}</li>`; }); if(listHTML === '' && phase !== 'loading') { if (Object.keys(allConnections).length > 0 && playerCount === 0) listHTML = '<li>Only spectators connected...</li>'; else if (Object.keys(allConnections).length === 0) listHTML = '<li>Waiting for server...</li>'; } uiElements.leaderboardListUI.innerHTML = listHTML; }

    // No need to update player status bars or controls for admin view
}

--- FILE: client/settings.js ---
// settings.js (in project root)

document.addEventListener('DOMContentLoaded', () => {
    const playerNameInput = document.getElementById('player-name');
    const leafColorInput = document.getElementById('leaf-color');
    const trunkColorInput = document.getElementById('trunk-color');
    const saveButton = document.getElementById('save-settings');

    // --- Load existing settings from localStorage ---
    function loadSettings() {
        const storedName = localStorage.getItem('playerName');
        const storedLeafColor = localStorage.getItem('leafColor');
        const storedTrunkColor = localStorage.getItem('trunkColor');

        if (playerNameInput) {
            playerNameInput.value = storedName || 'Treebard'; // Use default if not set
        }
        if (leafColorInput) {
            leafColorInput.value = storedLeafColor || '#228B22'; // Default green
        }
        if (trunkColorInput) {
            trunkColorInput.value = storedTrunkColor || '#8B4513'; // Default brown
        }
        console.log('Settings loaded from localStorage');
    }

    // --- Save current settings to localStorage ---
    function saveSettings() {
        if (playerNameInput) {
            localStorage.setItem('playerName', playerNameInput.value || 'Treebard');
        }
        if (leafColorInput) {
            localStorage.setItem('leafColor', leafColorInput.value);
        }
        if (trunkColorInput) {
            localStorage.setItem('trunkColor', trunkColorInput.value);
        }
        console.log('Settings saved to localStorage');
    }

    // --- Event Listener for Save Button ---
    if (saveButton) {
        saveButton.addEventListener('click', () => {
            saveSettings();
            // Navigate back to the root landing page route
            window.location.href = '/';
        });
    }

    // --- Initial Load ---
    loadSettings();
});

--- FILE: server/network/connection.js ---
import { adminSockets } from '../server.js';
import * as Config from '../config.js';
// Game state, logic, and simulation are now handled by GameInstance and GameInstanceManager

const MIN_SPAWN_DISTANCE_SQ = 4 * 4;
const CONNECTION_TIMEOUT_MS = 5000; // 5 seconds to send intent or authenticate

/** Sets up event listeners for a newly connected socket. */
// Accept gameInstanceManager as argument
export function handleConnection(socket, io, gameInstanceManager) {
    console.log(`Connection: Player connected: ${socket.id}. Waiting for intent or admin auth...`);

    let connectionTimeout = setTimeout(() => {
        console.warn(`Connection: Timeout waiting for intent/auth from ${socket.id}. Disconnecting.`);
        socket.disconnect(true);
    }, CONNECTION_TIMEOUT_MS);

    let hasRouted = false; // Flag to prevent double routing

    // --- Listener for Admin Authentication ---
    socket.once('adminAuthenticate', (data) => {
        if (hasRouted) return; // Already handled by playerJoinRequest? Unlikely but safe.
        clearTimeout(connectionTimeout); // Clear the timeout

        const serverAdminPassword = process.env.ADMIN_PASSWORD || "defaultAdminPass123";
        if (data?.password && data.password === serverAdminPassword) {
            console.log(`Connection: Admin auth OK for ${socket.id}`);
            adminSockets.add(socket.id); // Mark as admin globally
            socket.emit('adminAuthResult', { success: true });

            hasRouted = true; // Mark as routed
            const targetInstance = gameInstanceManager.routePlayer(socket, 'spectate', true); // Route as admin spectator
            if (targetInstance) {
                setupInputAndActionListeners(socket, io, gameInstanceManager); // Setup listeners AFTER routing
            } else { console.error(`Connection: Failed to route authenticated admin ${socket.id}.`); }

        } else {
            console.warn(`Connection: Admin auth FAILED for ${socket.id}`);
            socket.emit('adminAuthResult', { success: false, reason: 'Invalid Password' });
            // Keep socket open briefly to send result, then disconnect
            setTimeout(() => socket.disconnect(true), 500);
        }
    });

    // --- Listener for Regular Player Join ---
    socket.once('playerJoinRequest', (data) => {
        if (hasRouted) return; // Already handled by adminAuthenticate?
        clearTimeout(connectionTimeout); // Clear the timeout

        // Basic validation of join data
        if (!data || !data.intent || !['single', 'multi', 'spectate'].includes(data.intent)) {
             console.warn(`Connection: Received invalid playerJoinRequest from ${socket.id}. Data:`, data);
             socket.disconnect(true);
             return;
        }
        // Prevent regular players from claiming admin status via join request
        if (adminSockets.has(socket.id)) {
            console.warn(`Connection: Denying playerJoinRequest from already identified admin ${socket.id}`);
            return; // Ignore request
        }

        console.log(`Connection: Received playerJoinRequest from ${socket.id}. Intent: ${data.intent}`);
        hasRouted = true; // Mark as routed
        const targetInstance = gameInstanceManager.routePlayer(socket, data.intent, false); // Route based on intent
        if (targetInstance) {
            setupInputAndActionListeners(socket, io, gameInstanceManager); // Setup listeners AFTER routing
        } else { console.error(`Connection: Failed to route player ${socket.id} with intent ${data.intent}.`); }
    });

    // --- Disconnect Handling ---
    socket.on('disconnect', (reason) => {
        // Clear timeout just in case disconnect happens before routing
        clearTimeout(connectionTimeout);
        console.log(`Connection: Disconnect event for ${socket.id}. Reason: ${reason}`);
        if (adminSockets.has(socket.id)) {
            adminSockets.delete(socket.id);
            console.log(`Connection: Removed ${socket.id} from global admin set.`);
        }
        // If the player was successfully routed, delegate removal to the manager
        if(hasRouted) {
            gameInstanceManager.removePlayerFromInstance(socket.id);
        } else {
             console.log(`Connection: Player ${socket.id} disconnected before routing.`);
        }
    });
} // End of handleConnection


/** Sets up listeners for controls AND actions coming from the client */
// Accept gameInstanceManager as argument
function setupInputAndActionListeners(socket, io, gameInstanceManager) {
    console.log(`Connection: Setting up input/action listeners for ${socket.id}`); // Add log

    // Helper function to get the instance for the current socket
    function getInstanceForSocket() {
        const instanceId = gameInstanceManager.getInstanceIdForPlayer(socket.id);
        if (!instanceId) { console.error(`InputHandler: Cannot find instance ID for socket ${socket.id}`); return null; }
        const instance = gameInstanceManager.getInstance(instanceId);
        if (!instance) { console.error(`InputHandler: Instance ${instanceId} not found for socket ${socket.id}`); return null; }
        return instance;
    }

    // --- Player Input Events ---
    socket.on('updateStomata', (data) => {
        const instance = getInstanceForSocket(); if (!instance) return;
        const ps = instance.getPlayerState(socket.id);
        if (ps && ps.isAlive && !ps.isSpectator && instance.state.gamePhase === 'playing' && typeof data?.value === 'number') {
             ps.stomatalConductance = Math.max(0, Math.min(1, data.value));
        }
    });
    socket.on('updateAllocation', (data) => {
        const instance = getInstanceForSocket(); if (!instance) return;
        const ps = instance.getPlayerState(socket.id);
        if (ps && ps.isAlive && !ps.isSpectator && instance.state.gamePhase === 'playing' && typeof data?.savings === 'number' && typeof data?.growthRatio === 'number') {
            ps.lastSavingsPercent = Math.max(0, Math.min(100, data.savings));
            ps.lastGrowthRatioPercent = Math.max(0, Math.min(100, data.growthRatio));
        }
    });
     socket.on('requestStartCountdown', () => {
         const instance = getInstanceForSocket(); if (!instance) return;
         console.log(`Conn: Received 'requestStartCountdown' from ${socket.id} for instance ${instance.state.instanceId}`);
         const ps = instance.getPlayerState(socket.id);
         if (instance.state.mode === 'multi' && ps && !ps.isSpectator && instance.state.gamePhase === 'lobby' /* && instance.state.allowPlayerCountdownStart TBD */) {
             instance.startCountdown();
         } else { console.log(`Conn: Ignoring start countdown. Mode:${instance.state.mode}, Phase:${instance.state.gamePhase}, Player:${!!ps}, Spectator:${ps?.isSpectator}`); }
     });
     socket.on('selectSpawnPoint', (coords) => {
         const instance = getInstanceForSocket(); if (!instance) return;
         const ps = instance.getPlayerState(socket.id);
         console.log(`Conn: Received 'selectSpawnPoint' from ${socket.id} for instance ${instance.state.instanceId}:`, coords);
         if (!ps || ps.isSpectator || !coords || typeof coords.x !== 'number' || typeof coords.z !== 'number') { socket.emit('spawnPointInvalid', { reason: 'Invalid data/spectator.' }); return; }
         if (instance.state.gamePhase !== 'lobby') { socket.emit('spawnPointInvalid', { reason: 'Can only select in lobby.' }); return; }
         if (ps.hasChosenSpawn) { socket.emit('spawnPointInvalid', { reason: 'Already chosen.' }); return; }
         const islandRadius = Config.ISLAND_RADIUS || 50; const distSqFromCenter = coords.x**2 + coords.z**2;
         if (distSqFromCenter > islandRadius*islandRadius) { socket.emit('spawnPointInvalid', { reason: 'Outside island.' }); return; }
         let tooClose = false;
         instance.getAllPlayers().forEach((op) => { if (op.id === socket.id) return; if (op.hasChosenSpawn && !op.isSpectator) { const dx = coords.x - op.spawnPoint.x; const dz = coords.z - op.spawnPoint.z; const distSq = dx*dx + dz*dz; if (distSq < MIN_SPAWN_DISTANCE_SQ) { tooClose = true; } } });
         if (tooClose) { socket.emit('spawnPointInvalid', { reason: 'Too close.' }); return; }
         console.log(`Conn: Spawn point for ${socket.id} confirmed.`);
         const baseHeight = Config.ISLAND_LEVEL !== undefined ? Config.ISLAND_LEVEL : 0.1;
         ps.spawnPoint = { x: coords.x, y: baseHeight, z: coords.z }; ps.hasChosenSpawn = true;
         socket.emit('spawnPointConfirmed', ps.spawnPoint);
         instance.broadcastState();
     });

     // --- Admin Commands (Target Multiplayer Instance) ---
     function handleAdminCommand(commandName, actionFn) {
         if (!adminSockets.has(socket.id)) { console.warn(`Unauthorized admin command '${commandName}' from ${socket.id}`); return; }
         const multiplayerInstance = gameInstanceManager.multiplayerInstanceId ? gameInstanceManager.getInstance(gameInstanceManager.multiplayerInstanceId) : null;
         if (!multiplayerInstance) { console.log(`ADMIN COMMAND ${commandName}: No active multiplayer instance found.`); socket.emit('serverMessage', { text: 'No active multiplayer game.', type: 'error'}); return; }
         console.log(`ADMIN COMMAND: ${commandName} from ${socket.id} targeting instance ${multiplayerInstance.state.instanceId}`);
         actionFn(multiplayerInstance); // Execute action, passing the target instance
     }

     socket.on('adminForceStart', () => handleAdminCommand('Force Start', (instance) => {
         const phase = instance.state.gamePhase;
         if (phase === 'lobby' || phase === 'countdown') {
             instance._prepareAndStartGame();
             instance.io.to(instance.state.roomId).emit('serverMessage', { text: 'Admin forced game start!', type: 'warning'});
             socket.emit('serverMessage', { text: 'Game force-started.', type: 'success'});
         } else { console.log("ADMIN: Cannot Force Start, invalid phase."); socket.emit('serverMessage', { text: 'Cannot force start now.', type: 'error'}); }
     }));
     socket.on('adminForceEnd', () => handleAdminCommand('Force End', (instance) => {
          const phase = instance.state.gamePhase;
         if (phase === 'playing' || phase === 'countdown') {
             instance.endGame("Game ended by admin.");
             instance.io.to(instance.state.roomId).emit('serverMessage', { text: 'Admin ended the game.', type: 'warning'});
             socket.emit('serverMessage', { text: 'Game force-ended.', type: 'success'});
         } else { console.log("ADMIN: Cannot Force End, invalid phase."); socket.emit('serverMessage', { text: 'Cannot force end now.', type: 'error'}); }
     }));
     socket.on('adminResetCountdown', () => handleAdminCommand('Reset Countdown', (instance) => {
         const phase = instance.state.gamePhase;
         let message = ''; let feedback = '';
         if (phase === 'countdown') { instance.stopCountdown(); instance.startCountdown(); message = 'Admin reset the countdown.'; feedback = 'Countdown reset.'; }
         else if (phase === 'lobby') { instance.startCountdown(); message = 'Admin started the countdown.'; feedback = 'Countdown started.'; }
         else { console.log("ADMIN: Cannot Reset/Start Countdown, invalid phase."); socket.emit('serverMessage', { text: 'Cannot reset/start countdown now.', type: 'error'}); return; }
         if (message) instance.io.to(instance.state.roomId).emit('serverMessage', { text: message, type: 'info'});
         if (feedback) socket.emit('serverMessage', { text: feedback, type: 'success'});
     }));

} // End of setupInputAndActionListeners

--- FILE: client/ui/gameOver.js ---
// client/ui/gameOver.js
import { gameState, getMyPlayerState } from '../gameState.js';
import { uiElements } from './elements.js';
// Import restart handler for the player button
import { handleRestart } from '../main.js';

/** Displays the Game Over modal. */
export function showGameOverUI() {
    console.log("UI: showGameOverUI called.");
    if (!uiElements.gameOverModal) { console.error("UI ERROR: gameOverModal element not found!"); return; }
    // Check optional elements safely
    if (!uiElements.gameOverReasonUI) { console.warn("UI element gameOverReasonUI missing."); }
    if (!uiElements.finalDayUI) { console.warn("UI element finalDayUI missing."); }
    if (!uiElements.finalSeedsUI) { console.warn("UI element finalSeedsUI missing."); }

    const myFinalState = getMyPlayerState();
    const finalDay = gameState.day;
    // Show N/A seeds if spectator or state missing
    const finalSeeds = (myFinalState && !gameState.isSpectator) ? myFinalState.seedCount : 'N/A';
    // Determine if this client is admin (by checking if admin controls exist on page)
    const isAdminView = !!document.getElementById('admin-controls'); // Check if admin controls are present

    // --- Populate Modal Content ---
    let reasonText = gameState.gameOverReason || "The game has ended!"; // Default reason
    if (gameState.winnerId) {
        const winnerState = gameState.players[gameState.winnerId];
        const winnerName = winnerState?.playerName || `Player ${gameState.winnerId.substring(0,4)}`;
        // Check if WE are the winner (and not a spectator)
        if (gameState.winnerId === gameState.myId && !gameState.isSpectator) { reasonText += `<br><strong>Congratulations, you had the most seeds!</strong>`; }
        else { reasonText += `<br>Winner: ${winnerName} with ${winnerState?.seedCount ?? '?'} seeds.`; }
    } else if (reasonText.indexOf("admin") === -1 && reasonText.indexOf("ended") > -1) { // Avoid adding "no winner" if admin ended it or just ended naturally
         reasonText += "<br>No winner declared.";
    }

    if(uiElements.gameOverReasonUI) uiElements.gameOverReasonUI.innerHTML = reasonText;

    // Show/Hide player-specific stats based on view type and spectator status
    const showPlayerStats = !isAdminView && !gameState.isSpectator; // Show stats only if regular player view AND not spectator

    if(uiElements.finalDayUI && uiElements.finalDayUI.parentElement) { // Check parent exists
        uiElements.finalDayUI.textContent = finalDay;
        uiElements.finalDayUI.parentElement.style.display = showPlayerStats ? 'block' : 'none'; // Show/hide the whole <p> tag
    }
    if(uiElements.finalSeedsUI && uiElements.finalSeedsUI.parentElement) { // Check parent exists
        uiElements.finalSeedsUI.textContent = finalSeeds;
         uiElements.finalSeedsUI.parentElement.style.display = showPlayerStats ? 'block' : 'none'; // Show/hide the whole <p> tag
    }

    // --- Show/Hide and Setup Buttons ---
    const adminCloseButton = document.getElementById('admin-close-modal'); // Reference admin specific button if it exists

    // Regular Player View: Show 'Play Again' (which reloads to '/')
    if (uiElements.restartButton) {
        uiElements.restartButton.style.display = showPlayerStats ? 'inline-block' : 'none';
        if (showPlayerStats) {
            // Attach listener (remove first to prevent duplicates if modal shown multiple times)
            uiElements.restartButton.removeEventListener('click', handleRestart);
            uiElements.restartButton.addEventListener('click', handleRestart);
        }
    }
    // Admin View: Show 'Close'
    if (adminCloseButton) {
        adminCloseButton.style.display = isAdminView ? 'inline-block' : 'none';
         if (isAdminView) {
             // Attach listener (remove first to prevent duplicates)
             adminCloseButton.removeEventListener('click', hideGameOverModal);
             adminCloseButton.addEventListener('click', hideGameOverModal);
         }
    } else if (isAdminView) {
         // Warn if admin view but expected button is missing
         console.warn("Admin view detected, but 'admin-close-modal' button not found in HTML.");
    }


    // Show the Modal itself
    uiElements.gameOverModal.classList.remove('hidden');
    console.log("UI: Game over modal made visible.");
}

/** Hides the Game Over modal. */
export function hideGameOverModal() {
    if (uiElements.gameOverModal) {
        uiElements.gameOverModal.classList.add('hidden');
        console.log("UI: Game over modal hidden.");
    } else { console.warn("UI: Tried to hide game over modal, element not found."); }
}

--- FILE: server/package.json ---
{
  "name": "server",
  "version": "1.0.0",
  "main": "server.js",
  "type": "module",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "express": "^5.1.0",
    "socket.io": "^4.8.1",
    "uuid": "^11.1.0"
  }
}

